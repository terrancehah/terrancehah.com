"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("components_travel-chat_tsx",{

/***/ "./managers/ai-chat-manager.ts":
/*!*************************************!*\
  !*** ./managers/ai-chat-manager.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AIChatManager: function() { return /* binding */ AIChatManager; }\n/* harmony export */ });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"./node_modules/next/dist/compiled/events/events.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ \"./managers/types.ts\");\n\n\nclass AIChatManager extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    initializeChatHistory() {\n        return {\n            messages: [],\n            metadata: {\n                lastInteractionTime: new Date(),\n                currentState: \"initial\",\n                validParameters: []\n            }\n        };\n    }\n    async handleMessage(message) {\n        try {\n            // Add user message to history\n            this.addMessage({\n                id: Date.now().toString(),\n                role: \"user\",\n                content: message\n            });\n            // Process message and update parameters\n            const response = await this.processMessage(message);\n            // Add AI response to history\n            this.addMessage({\n                id: (Date.now() + 1).toString(),\n                role: \"assistant\",\n                content: response.message,\n                data: {\n                    currentDetails: response.parameters\n                }\n            });\n            return response;\n        } catch (error) {\n            console.error(\"Error handling message:\", error);\n            return {\n                message: \"I encountered an error processing your message. Let's continue from where we left off.\",\n                error: error instanceof Error ? error.message : \"Unknown error\"\n            };\n        }\n    }\n    async processMessage(message) {\n        const currentState = this.chatHistory.metadata.currentState;\n        if (currentState === \"interrupted\") {\n            return this.recoverConversation();\n        }\n        // Update state based on message content and current parameters\n        const updatedParameters = await this.extractParameters(message);\n        const validationResult = this.validateParameters(updatedParameters);\n        if (validationResult.isValid) {\n            this.updateState(\"planning\");\n            return {\n                message: \"Great! I have all the information needed. Let me plan your trip.\",\n                parameters: updatedParameters\n            };\n        }\n        return {\n            message: \"Could you please provide your \".concat(validationResult.missingParams.join(\", \"), \"?\"),\n            parameters: updatedParameters,\n            suggestedAction: \"gather_info\"\n        };\n    }\n    validateParameters(parameters) {\n        var _parameters_preferences;\n        const missingParams = Array.from(this.requiredParameters).filter((param)=>!parameters[param]);\n        const invalidParams = [];\n        // Validate budget format\n        if (parameters.budget && ![\n            \"$\",\n            \"$$\",\n            \"$$$\",\n            \"$$$$\"\n        ].includes(parameters.budget)) {\n            invalidParams.push(\"budget\");\n        }\n        // Validate language\n        if (parameters.language && !Object.keys(_types__WEBPACK_IMPORTED_MODULE_1__.SupportedLanguage).includes(parameters.language)) {\n            invalidParams.push(\"language\");\n        }\n        // Validate preferences\n        if ((_parameters_preferences = parameters.preferences) === null || _parameters_preferences === void 0 ? void 0 : _parameters_preferences.some((pref)=>![\n                \"Culture and Heritage\",\n                \"Nature\",\n                \"Foodie\",\n                \"Leisure\",\n                \"Adventure\",\n                \"Arts and Museums\"\n            ].includes(pref))) {\n            invalidParams.push(\"preferences\");\n        }\n        return {\n            isValid: missingParams.length === 0 && invalidParams.length === 0,\n            missingParams,\n            invalidParams\n        };\n    }\n    async extractParameters(message) {\n        // Implement NLP or pattern matching logic to extract parameters\n        // For now, return current parameters\n        const currentDetails = this.getCurrentParameters();\n        return {\n            ...currentDetails\n        };\n    }\n    addMessage(message) {\n        this.chatHistory.messages.push(message);\n        this.chatHistory.metadata.lastInteractionTime = new Date();\n        // Trim history if it exceeds maxHistoryLength\n        if (this.chatHistory.messages.length > this.maxHistoryLength) {\n            this.chatHistory.messages = this.chatHistory.messages.slice(-this.maxHistoryLength);\n        }\n        this.emit(\"messageAdded\", message);\n    }\n    getContextHistory() {\n        return this.chatHistory;\n    }\n    getCurrentParameters() {\n        var _lastMessage_data;\n        const lastMessage = this.chatHistory.messages.reverse().find((msg)=>{\n            var _msg_data;\n            return (_msg_data = msg.data) === null || _msg_data === void 0 ? void 0 : _msg_data.currentDetails;\n        });\n        return (lastMessage === null || lastMessage === void 0 ? void 0 : (_lastMessage_data = lastMessage.data) === null || _lastMessage_data === void 0 ? void 0 : _lastMessage_data.currentDetails) || {};\n    }\n    updateState(newState) {\n        this.chatHistory.metadata.currentState = newState;\n        this.emit(\"stateChanged\", newState);\n    }\n    async recoverConversation() {\n        const currentParams = this.getCurrentParameters();\n        const validationResult = this.validateParameters(currentParams);\n        this.updateState(\"gathering_info\");\n        return {\n            message: \"Let me help you get back on track. \" + (validationResult.missingParams.length > 0 ? \"I still need your \".concat(validationResult.missingParams.join(\", \"), \".\") : \"We were about to start planning your trip.\"),\n            parameters: currentParams\n        };\n    }\n    clearHistory() {\n        this.chatHistory = this.initializeChatHistory();\n        this.emit(\"historyCleared\");\n    }\n    formatMessageContent(content) {\n        if (!content) return \"\";\n        // Remove excessive newlines\n        const trimmedContent = content.replace(/\\n{3,}/g, \"\\n\\n\");\n        // Ensure proper spacing around special characters\n        return trimmedContent.replace(/([.!?])\\s*(?=\\S)/g, \"$1 \") // Add space after punctuation if missing\n        .trim();\n    }\n    updateSystemContext(details) {\n        const systemMessage = this.chatHistory.messages.find((m)=>m.role === \"system\");\n        if (systemMessage) {\n            var _details_preferences;\n            systemMessage.content = \"You are a knowledgeable travel assistant. Your role is to help users plan their trips by:\\n1. Understanding and remembering their travel preferences, dates, and budget\\n2. Providing detailed information about their chosen destination\\n3. Making suggestions based on their interests and constraints\\n\\nCurrent Travel Details:\\n- Destination: \".concat(details.destination || \"Not specified\", \"\\n- Dates: \").concat(details.startDate ? \"\".concat(details.startDate, \" to \").concat(details.endDate) : \"Not specified\", \"\\n- Budget Level: \").concat(details.budget || \"Not specified\", \"\\n- Language: \").concat(details.language || \"Not specified\", \"\\n- Preferences: \").concat(((_details_preferences = details.preferences) === null || _details_preferences === void 0 ? void 0 : _details_preferences.join(\", \")) || \"Not specified\", \"\\n\\nKeep this context in mind throughout the conversation. If any detail changes, update your knowledge accordingly.\\nWhen providing information about destinations, include key attractions, local culture, best times to visit, and relevant travel tips.\");\n        }\n        this.emit(\"contextUpdated\", this.chatHistory);\n    }\n    handleFunctionCall(functionName, args) {\n        switch(functionName){\n            case \"getDetails\":\n                this.emit(\"getDetails\");\n                break;\n            case \"updatePreferences\":\n                this.emit(\"updatePreferences\", args.prefs);\n                break;\n            case \"updateDates\":\n                this.emit(\"updateDates\", args.start, args.end);\n                break;\n            case \"updateBudget\":\n                this.emit(\"updateBudget\", args.level);\n                break;\n            case \"updateLanguage\":\n                this.emit(\"updateLanguage\", args.lang);\n                break;\n            default:\n                console.warn(\"Unknown function call: \".concat(functionName));\n        }\n    }\n    processAIResponse(response) {\n        // Check for function calls in the response\n        const functionCallRegex = /\\b(getDetails|updatePreferences|updateDates|updateBudget|updateLanguage)\\((.*?)\\)/g;\n        let match;\n        while((match = functionCallRegex.exec(response)) !== null){\n            const [_, functionName, argsStr] = match;\n            try {\n                const args = argsStr ? JSON.parse(\"{\".concat(argsStr, \"}\")) : {};\n                this.handleFunctionCall(functionName, args);\n            } catch (error) {\n                console.error(\"Error processing function call: \".concat(error));\n            }\n        }\n    }\n    async sendMessage(message) {\n        var _response_body;\n        const userMessage = {\n            id: Date.now().toString(),\n            role: \"user\",\n            content: message\n        };\n        this.addMessage(userMessage);\n        const response = await fetch(\"/api/chat-update\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                messages: this.chatHistory.messages,\n                currentDetails: this.currentDetails,\n                componentUpdate: null\n            })\n        });\n        if (!response.ok) {\n            const errorData = await response.json();\n            throw new Error(errorData.error || \"Failed to get response\");\n        }\n        const reader = (_response_body = response.body) === null || _response_body === void 0 ? void 0 : _response_body.getReader();\n        if (!reader) {\n            throw new Error(\"No response body\");\n        }\n        // Add empty assistant message that will be updated during streaming\n        this.addMessage({\n            id: (Date.now() + 1).toString(),\n            role: \"assistant\",\n            content: \"\"\n        });\n        return reader;\n    }\n    updateDetails(details) {\n        this.currentDetails = {\n            ...this.currentDetails,\n            ...details\n        };\n        this.emit(\"detailsUpdated\", this.currentDetails);\n    }\n    getCurrentDetails() {\n        return this.currentDetails;\n    }\n    async handleToolUpdate(toolName, value) {\n        try {\n            var _response_body;\n            // Log the start of the operation\n            console.log(\"[handleToolUpdate] Starting update...\", {\n                toolName,\n                value\n            });\n            // Update details\n            const updatedDetails = {\n                ...this.currentDetails,\n                ...toolName === \"budgetSelector\" ? {\n                    budget: value\n                } : {}\n            };\n            // Log the request preparation\n            console.log(\"[handleToolUpdate] Preparing request with:\", {\n                type: toolName,\n                value,\n                details: updatedDetails\n            });\n            // Simplified request body\n            const requestBody = {\n                messages: [\n                    {\n                        role: \"user\",\n                        content: \"I've set my travel budget to: \".concat(value)\n                    }\n                ],\n                currentDetails: updatedDetails,\n                componentUpdate: {\n                    type: toolName,\n                    value\n                }\n            };\n            // Make the request\n            console.log(\"[handleToolUpdate] Making API request...\");\n            const response = await fetch(\"/api/chat-update\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify(requestBody)\n            });\n            console.log(\"[handleToolUpdate] Response received:\", response.status);\n            if (!response.ok) {\n                throw new Error(\"API returned \".concat(response.status));\n            }\n            const reader = (_response_body = response.body) === null || _response_body === void 0 ? void 0 : _response_body.getReader();\n            if (!reader) {\n                throw new Error(\"No response body available\");\n            }\n            console.log(\"[handleToolUpdate] Got reader successfully\");\n            this.currentDetails = updatedDetails;\n            this.emit(\"detailsUpdated\", updatedDetails);\n            return {\n                updatedDetails,\n                reader\n            };\n        } catch (error) {\n            console.error(\"[handleToolUpdate] Error:\", error);\n            throw error;\n        }\n    }\n    formatUpdateMessage(toolName, value) {\n        switch(toolName){\n            case \"datePicker\":\n                return \"I've selected these travel dates: \".concat(value.startDate, \" to \").concat(value.endDate);\n            case \"preferenceSelector\":\n                return \"I've updated my travel preferences to: \".concat(Array.isArray(value) ? value.join(\", \") : value);\n            case \"budgetSelector\":\n                return \"I've set my travel budget to: \".concat(value);\n            case \"languageSelector\":\n                return \"I'd like the PDF export in this language: \".concat(value);\n            default:\n                return \"I've updated my \".concat(toolName.replace(/([A-Z])/g, \" $1\").toLowerCase(), \" to: \").concat(Array.isArray(value) ? value.join(\", \") : value);\n        }\n    }\n    async processStreamingResponse(reader, onChunk) {\n        console.log(\"[processStreamingResponse] Starting to process stream\");\n        const decoder = new TextDecoder();\n        let buffer = \"\";\n        let currentMessage = this.chatHistory.messages[this.chatHistory.messages.length - 1];\n        try {\n            while(true){\n                console.log(\"[processStreamingResponse] Reading chunk...\");\n                const { done, value } = await reader.read();\n                if (done) {\n                    console.log(\"[processStreamingResponse] Stream complete\");\n                    break;\n                }\n                const chunk = decoder.decode(value, {\n                    stream: true\n                });\n                console.log(\"[processStreamingResponse] Raw chunk received:\", chunk);\n                buffer += chunk;\n                const lines = buffer.split(\"\\n\");\n                buffer = lines.pop() || \"\";\n                for (const line of lines){\n                    console.log(\"[processStreamingResponse] Processing line:\", line);\n                    if (line.startsWith(\"data: \")) {\n                        const data = line.slice(6);\n                        if (data === \"[DONE]\") {\n                            console.log(\"[processStreamingResponse] Received [DONE] signal\");\n                            continue;\n                        }\n                        try {\n                            var _parsed_choices__delta, _parsed_choices_, _parsed_choices;\n                            const parsed = JSON.parse(data);\n                            console.log(\"[processStreamingResponse] Parsed data:\", parsed);\n                            if ((_parsed_choices = parsed.choices) === null || _parsed_choices === void 0 ? void 0 : (_parsed_choices_ = _parsed_choices[0]) === null || _parsed_choices_ === void 0 ? void 0 : (_parsed_choices__delta = _parsed_choices_.delta) === null || _parsed_choices__delta === void 0 ? void 0 : _parsed_choices__delta.content) {\n                                const content = parsed.choices[0].delta.content;\n                                console.log(\"[processStreamingResponse] Content chunk:\", content);\n                                onChunk(content);\n                                // Update the current message content\n                                if (currentMessage) {\n                                    currentMessage.content += content;\n                                }\n                            }\n                        } catch (e) {\n                            console.error(\"[processStreamingResponse] Error parsing data:\", e, \"Raw data:\", data);\n                        }\n                    }\n                }\n            }\n            // Process any function calls in the complete message\n            if (currentMessage) {\n                console.log(\"[processStreamingResponse] Final message:\", currentMessage.content);\n                this.processAIResponse(currentMessage.content);\n            }\n            this.emit(\"messageUpdated\", currentMessage);\n        } catch (error) {\n            console.error(\"[processStreamingResponse] Stream processing error:\", error);\n            throw error;\n        } finally{\n            console.log(\"[processStreamingResponse] Cleaning up stream\");\n            reader.releaseLock();\n        }\n    }\n    constructor(initialDetails){\n        super();\n        this.chatHistory = this.initializeChatHistory();\n        this.currentDetails = initialDetails;\n        this.requiredParameters = new Set([\n            \"destination\",\n            \"startDate\",\n            \"endDate\",\n            \"budget\",\n            \"language\"\n        ]);\n        this.maxHistoryLength = 50;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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X0UvLi9tYW5hZ2Vycy9haS1jaGF0LW1hbmFnZXIudHM/YzYyYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuaW1wb3J0IHsgXG4gICAgQ2hhdEhpc3RvcnksIFxuICAgIENoYXRNZXNzYWdlLCBcbiAgICBDaGF0U3RhdGUsIFxuICAgIFRyYXZlbFBhcmFtZXRlcnMsXG4gICAgQUlSZXNwb25zZSxcbiAgICBNZXNzYWdlRGF0YSxcbiAgICBCdWRnZXRMZXZlbCxcbiAgICBUcmF2ZWxQcmVmZXJlbmNlLFxuICAgIFN1cHBvcnRlZExhbmd1YWdlLFxuICAgIFRyYXZlbERldGFpbHMsXG4gICAgQ29tcG9uZW50VHlwZVxufSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGNsYXNzIEFJQ2hhdE1hbmFnZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAgIHByaXZhdGUgY2hhdEhpc3Rvcnk6IENoYXRIaXN0b3J5O1xuICAgIHByaXZhdGUgcmVxdWlyZWRQYXJhbWV0ZXJzOiBTZXQ8c3RyaW5nPjtcbiAgICBwcml2YXRlIG1heEhpc3RvcnlMZW5ndGg6IG51bWJlcjtcbiAgICBwcml2YXRlIGN1cnJlbnREZXRhaWxzOiBUcmF2ZWxEZXRhaWxzO1xuXG4gICAgY29uc3RydWN0b3IoaW5pdGlhbERldGFpbHM6IFRyYXZlbERldGFpbHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jaGF0SGlzdG9yeSA9IHRoaXMuaW5pdGlhbGl6ZUNoYXRIaXN0b3J5KCk7XG4gICAgICAgIHRoaXMuY3VycmVudERldGFpbHMgPSBpbml0aWFsRGV0YWlscztcbiAgICAgICAgdGhpcy5yZXF1aXJlZFBhcmFtZXRlcnMgPSBuZXcgU2V0KFtcbiAgICAgICAgICAgICdkZXN0aW5hdGlvbicsXG4gICAgICAgICAgICAnc3RhcnREYXRlJyxcbiAgICAgICAgICAgICdlbmREYXRlJyxcbiAgICAgICAgICAgICdidWRnZXQnLFxuICAgICAgICAgICAgJ2xhbmd1YWdlJ1xuICAgICAgICBdKTtcbiAgICAgICAgdGhpcy5tYXhIaXN0b3J5TGVuZ3RoID0gNTA7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpbml0aWFsaXplQ2hhdEhpc3RvcnkoKTogQ2hhdEhpc3Rvcnkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWVzc2FnZXM6IFtdLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgICBsYXN0SW50ZXJhY3Rpb25UaW1lOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRTdGF0ZTogJ2luaXRpYWwnLFxuICAgICAgICAgICAgICAgIHZhbGlkUGFyYW1ldGVyczogW11cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBoYW5kbGVNZXNzYWdlKG1lc3NhZ2U6IHN0cmluZyk6IFByb21pc2U8QUlSZXNwb25zZT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gQWRkIHVzZXIgbWVzc2FnZSB0byBoaXN0b3J5XG4gICAgICAgICAgICB0aGlzLmFkZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGlkOiBEYXRlLm5vdygpLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgcm9sZTogJ3VzZXInLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2VcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBQcm9jZXNzIG1lc3NhZ2UgYW5kIHVwZGF0ZSBwYXJhbWV0ZXJzXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJvY2Vzc01lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEFkZCBBSSByZXNwb25zZSB0byBoaXN0b3J5XG4gICAgICAgICAgICB0aGlzLmFkZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGlkOiAoRGF0ZS5ub3coKSArIDEpLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgcm9sZTogJ2Fzc2lzdGFudCcsXG4gICAgICAgICAgICAgICAgY29udGVudDogcmVzcG9uc2UubWVzc2FnZSxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnREZXRhaWxzOiByZXNwb25zZS5wYXJhbWV0ZXJzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGhhbmRsaW5nIG1lc3NhZ2U6JywgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnSSBlbmNvdW50ZXJlZCBhbiBlcnJvciBwcm9jZXNzaW5nIHlvdXIgbWVzc2FnZS4gTGV0XFwncyBjb250aW51ZSBmcm9tIHdoZXJlIHdlIGxlZnQgb2ZmLicsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBwcm9jZXNzTWVzc2FnZShtZXNzYWdlOiBzdHJpbmcpOiBQcm9taXNlPEFJUmVzcG9uc2U+IHtcbiAgICAgICAgY29uc3QgY3VycmVudFN0YXRlID0gdGhpcy5jaGF0SGlzdG9yeS5tZXRhZGF0YS5jdXJyZW50U3RhdGU7XG4gICAgICAgIFxuICAgICAgICBpZiAoY3VycmVudFN0YXRlID09PSAnaW50ZXJydXB0ZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWNvdmVyQ29udmVyc2F0aW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgc3RhdGUgYmFzZWQgb24gbWVzc2FnZSBjb250ZW50IGFuZCBjdXJyZW50IHBhcmFtZXRlcnNcbiAgICAgICAgY29uc3QgdXBkYXRlZFBhcmFtZXRlcnMgPSBhd2FpdCB0aGlzLmV4dHJhY3RQYXJhbWV0ZXJzKG1lc3NhZ2UpO1xuICAgICAgICBjb25zdCB2YWxpZGF0aW9uUmVzdWx0ID0gdGhpcy52YWxpZGF0ZVBhcmFtZXRlcnModXBkYXRlZFBhcmFtZXRlcnMpO1xuXG4gICAgICAgIGlmICh2YWxpZGF0aW9uUmVzdWx0LmlzVmFsaWQpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoJ3BsYW5uaW5nJyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdHcmVhdCEgSSBoYXZlIGFsbCB0aGUgaW5mb3JtYXRpb24gbmVlZGVkLiBMZXQgbWUgcGxhbiB5b3VyIHRyaXAuJyxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiB1cGRhdGVkUGFyYW1ldGVyc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZXNzYWdlOiBgQ291bGQgeW91IHBsZWFzZSBwcm92aWRlIHlvdXIgJHt2YWxpZGF0aW9uUmVzdWx0Lm1pc3NpbmdQYXJhbXMuam9pbignLCAnKX0/YCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHVwZGF0ZWRQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgc3VnZ2VzdGVkQWN0aW9uOiAnZ2F0aGVyX2luZm8nXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB2YWxpZGF0ZVBhcmFtZXRlcnMocGFyYW1ldGVyczogVHJhdmVsUGFyYW1ldGVycyk6IHsgXG4gICAgICAgIGlzVmFsaWQ6IGJvb2xlYW47IFxuICAgICAgICBtaXNzaW5nUGFyYW1zOiBzdHJpbmdbXTtcbiAgICAgICAgaW52YWxpZFBhcmFtczogc3RyaW5nW107XG4gICAgfSB7XG4gICAgICAgIGNvbnN0IG1pc3NpbmdQYXJhbXMgPSBBcnJheS5mcm9tKHRoaXMucmVxdWlyZWRQYXJhbWV0ZXJzKVxuICAgICAgICAgICAgLmZpbHRlcihwYXJhbSA9PiAhcGFyYW1ldGVyc1twYXJhbSBhcyBrZXlvZiBUcmF2ZWxQYXJhbWV0ZXJzXSk7XG5cbiAgICAgICAgY29uc3QgaW52YWxpZFBhcmFtczogc3RyaW5nW10gPSBbXTtcblxuICAgICAgICAvLyBWYWxpZGF0ZSBidWRnZXQgZm9ybWF0XG4gICAgICAgIGlmIChwYXJhbWV0ZXJzLmJ1ZGdldCAmJiAhWyckJywgJyQkJywgJyQkJCcsICckJCQkJ10uaW5jbHVkZXMocGFyYW1ldGVycy5idWRnZXQpKSB7XG4gICAgICAgICAgICBpbnZhbGlkUGFyYW1zLnB1c2goJ2J1ZGdldCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgbGFuZ3VhZ2VcbiAgICAgICAgaWYgKHBhcmFtZXRlcnMubGFuZ3VhZ2UgJiYgIU9iamVjdC5rZXlzKFN1cHBvcnRlZExhbmd1YWdlKS5pbmNsdWRlcyhwYXJhbWV0ZXJzLmxhbmd1YWdlKSkge1xuICAgICAgICAgICAgaW52YWxpZFBhcmFtcy5wdXNoKCdsYW5ndWFnZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgcHJlZmVyZW5jZXNcbiAgICAgICAgaWYgKHBhcmFtZXRlcnMucHJlZmVyZW5jZXM/LnNvbWUocHJlZiA9PiBcbiAgICAgICAgICAgICFbJ0N1bHR1cmUgYW5kIEhlcml0YWdlJywgJ05hdHVyZScsICdGb29kaWUnLCAnTGVpc3VyZScsICdBZHZlbnR1cmUnLCAnQXJ0cyBhbmQgTXVzZXVtcyddXG4gICAgICAgICAgICAuaW5jbHVkZXMocHJlZikpKSB7XG4gICAgICAgICAgICBpbnZhbGlkUGFyYW1zLnB1c2goJ3ByZWZlcmVuY2VzJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNWYWxpZDogbWlzc2luZ1BhcmFtcy5sZW5ndGggPT09IDAgJiYgaW52YWxpZFBhcmFtcy5sZW5ndGggPT09IDAsXG4gICAgICAgICAgICBtaXNzaW5nUGFyYW1zLFxuICAgICAgICAgICAgaW52YWxpZFBhcmFtc1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgZXh0cmFjdFBhcmFtZXRlcnMobWVzc2FnZTogc3RyaW5nKTogUHJvbWlzZTxUcmF2ZWxQYXJhbWV0ZXJzPiB7XG4gICAgICAgIC8vIEltcGxlbWVudCBOTFAgb3IgcGF0dGVybiBtYXRjaGluZyBsb2dpYyB0byBleHRyYWN0IHBhcmFtZXRlcnNcbiAgICAgICAgLy8gRm9yIG5vdywgcmV0dXJuIGN1cnJlbnQgcGFyYW1ldGVyc1xuICAgICAgICBjb25zdCBjdXJyZW50RGV0YWlscyA9IHRoaXMuZ2V0Q3VycmVudFBhcmFtZXRlcnMoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmN1cnJlbnREZXRhaWxzXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhZGRNZXNzYWdlKG1lc3NhZ2U6IENoYXRNZXNzYWdlKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY2hhdEhpc3RvcnkubWVzc2FnZXMucHVzaChtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5jaGF0SGlzdG9yeS5tZXRhZGF0YS5sYXN0SW50ZXJhY3Rpb25UaW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFRyaW0gaGlzdG9yeSBpZiBpdCBleGNlZWRzIG1heEhpc3RvcnlMZW5ndGhcbiAgICAgICAgaWYgKHRoaXMuY2hhdEhpc3RvcnkubWVzc2FnZXMubGVuZ3RoID4gdGhpcy5tYXhIaXN0b3J5TGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmNoYXRIaXN0b3J5Lm1lc3NhZ2VzID0gdGhpcy5jaGF0SGlzdG9yeS5tZXNzYWdlcy5zbGljZSgtdGhpcy5tYXhIaXN0b3J5TGVuZ3RoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZUFkZGVkJywgbWVzc2FnZSk7XG4gICAgfVxuXG4gICAgZ2V0Q29udGV4dEhpc3RvcnkoKTogQ2hhdEhpc3Rvcnkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGF0SGlzdG9yeTtcbiAgICB9XG5cbiAgICBnZXRDdXJyZW50UGFyYW1ldGVycygpOiBUcmF2ZWxQYXJhbWV0ZXJzIHtcbiAgICAgICAgY29uc3QgbGFzdE1lc3NhZ2UgPSB0aGlzLmNoYXRIaXN0b3J5Lm1lc3NhZ2VzXG4gICAgICAgICAgICAucmV2ZXJzZSgpXG4gICAgICAgICAgICAuZmluZChtc2cgPT4gbXNnLmRhdGE/LmN1cnJlbnREZXRhaWxzKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBsYXN0TWVzc2FnZT8uZGF0YT8uY3VycmVudERldGFpbHMgfHwge307XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVTdGF0ZShuZXdTdGF0ZTogQ2hhdFN0YXRlKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY2hhdEhpc3RvcnkubWV0YWRhdGEuY3VycmVudFN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIHRoaXMuZW1pdCgnc3RhdGVDaGFuZ2VkJywgbmV3U3RhdGUpO1xuICAgIH1cblxuICAgIGFzeW5jIHJlY292ZXJDb252ZXJzYXRpb24oKTogUHJvbWlzZTxBSVJlc3BvbnNlPiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRQYXJhbXMgPSB0aGlzLmdldEN1cnJlbnRQYXJhbWV0ZXJzKCk7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRpb25SZXN1bHQgPSB0aGlzLnZhbGlkYXRlUGFyYW1ldGVycyhjdXJyZW50UGFyYW1zKTtcblxuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKCdnYXRoZXJpbmdfaW5mbycpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZXNzYWdlOiAnTGV0IG1lIGhlbHAgeW91IGdldCBiYWNrIG9uIHRyYWNrLiAnICtcbiAgICAgICAgICAgICAgICAgICAgKHZhbGlkYXRpb25SZXN1bHQubWlzc2luZ1BhcmFtcy5sZW5ndGggPiAwIFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBgSSBzdGlsbCBuZWVkIHlvdXIgJHt2YWxpZGF0aW9uUmVzdWx0Lm1pc3NpbmdQYXJhbXMuam9pbignLCAnKX0uYFxuICAgICAgICAgICAgICAgICAgICAgICAgOiAnV2Ugd2VyZSBhYm91dCB0byBzdGFydCBwbGFubmluZyB5b3VyIHRyaXAuJyksXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBjdXJyZW50UGFyYW1zXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgY2xlYXJIaXN0b3J5KCk6IHZvaWQge1xuICAgICAgICB0aGlzLmNoYXRIaXN0b3J5ID0gdGhpcy5pbml0aWFsaXplQ2hhdEhpc3RvcnkoKTtcbiAgICAgICAgdGhpcy5lbWl0KCdoaXN0b3J5Q2xlYXJlZCcpO1xuICAgIH1cblxuICAgIHB1YmxpYyBmb3JtYXRNZXNzYWdlQ29udGVudChjb250ZW50OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICBpZiAoIWNvbnRlbnQpIHJldHVybiAnJztcbiAgICAgICAgXG4gICAgICAgIC8vIFJlbW92ZSBleGNlc3NpdmUgbmV3bGluZXNcbiAgICAgICAgY29uc3QgdHJpbW1lZENvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoL1xcbnszLH0vZywgJ1xcblxcbicpO1xuICAgICAgICBcbiAgICAgICAgLy8gRW5zdXJlIHByb3BlciBzcGFjaW5nIGFyb3VuZCBzcGVjaWFsIGNoYXJhY3RlcnNcbiAgICAgICAgcmV0dXJuIHRyaW1tZWRDb250ZW50XG4gICAgICAgICAgICAucmVwbGFjZSgvKFsuIT9dKVxccyooPz1cXFMpL2csICckMSAnKSAgLy8gQWRkIHNwYWNlIGFmdGVyIHB1bmN0dWF0aW9uIGlmIG1pc3NpbmdcbiAgICAgICAgICAgIC50cmltKCk7XG4gICAgfVxuXG4gICAgcHVibGljIHVwZGF0ZVN5c3RlbUNvbnRleHQoZGV0YWlsczogVHJhdmVsUGFyYW1ldGVycyk6IHZvaWQge1xuICAgICAgICBjb25zdCBzeXN0ZW1NZXNzYWdlID0gdGhpcy5jaGF0SGlzdG9yeS5tZXNzYWdlcy5maW5kKG0gPT4gbS5yb2xlID09PSAnc3lzdGVtJyk7XG4gICAgICAgIGlmIChzeXN0ZW1NZXNzYWdlKSB7XG4gICAgICAgICAgICBzeXN0ZW1NZXNzYWdlLmNvbnRlbnQgPSBgWW91IGFyZSBhIGtub3dsZWRnZWFibGUgdHJhdmVsIGFzc2lzdGFudC4gWW91ciByb2xlIGlzIHRvIGhlbHAgdXNlcnMgcGxhbiB0aGVpciB0cmlwcyBieTpcbjEuIFVuZGVyc3RhbmRpbmcgYW5kIHJlbWVtYmVyaW5nIHRoZWlyIHRyYXZlbCBwcmVmZXJlbmNlcywgZGF0ZXMsIGFuZCBidWRnZXRcbjIuIFByb3ZpZGluZyBkZXRhaWxlZCBpbmZvcm1hdGlvbiBhYm91dCB0aGVpciBjaG9zZW4gZGVzdGluYXRpb25cbjMuIE1ha2luZyBzdWdnZXN0aW9ucyBiYXNlZCBvbiB0aGVpciBpbnRlcmVzdHMgYW5kIGNvbnN0cmFpbnRzXG5cbkN1cnJlbnQgVHJhdmVsIERldGFpbHM6XG4tIERlc3RpbmF0aW9uOiAke2RldGFpbHMuZGVzdGluYXRpb24gfHwgJ05vdCBzcGVjaWZpZWQnfVxuLSBEYXRlczogJHtkZXRhaWxzLnN0YXJ0RGF0ZSA/IGAke2RldGFpbHMuc3RhcnREYXRlfSB0byAke2RldGFpbHMuZW5kRGF0ZX1gIDogJ05vdCBzcGVjaWZpZWQnfVxuLSBCdWRnZXQgTGV2ZWw6ICR7ZGV0YWlscy5idWRnZXQgfHwgJ05vdCBzcGVjaWZpZWQnfVxuLSBMYW5ndWFnZTogJHtkZXRhaWxzLmxhbmd1YWdlIHx8ICdOb3Qgc3BlY2lmaWVkJ31cbi0gUHJlZmVyZW5jZXM6ICR7ZGV0YWlscy5wcmVmZXJlbmNlcz8uam9pbignLCAnKSB8fCAnTm90IHNwZWNpZmllZCd9XG5cbktlZXAgdGhpcyBjb250ZXh0IGluIG1pbmQgdGhyb3VnaG91dCB0aGUgY29udmVyc2F0aW9uLiBJZiBhbnkgZGV0YWlsIGNoYW5nZXMsIHVwZGF0ZSB5b3VyIGtub3dsZWRnZSBhY2NvcmRpbmdseS5cbldoZW4gcHJvdmlkaW5nIGluZm9ybWF0aW9uIGFib3V0IGRlc3RpbmF0aW9ucywgaW5jbHVkZSBrZXkgYXR0cmFjdGlvbnMsIGxvY2FsIGN1bHR1cmUsIGJlc3QgdGltZXMgdG8gdmlzaXQsIGFuZCByZWxldmFudCB0cmF2ZWwgdGlwcy5gO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdCgnY29udGV4dFVwZGF0ZWQnLCB0aGlzLmNoYXRIaXN0b3J5KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGhhbmRsZUZ1bmN0aW9uQ2FsbChmdW5jdGlvbk5hbWU6IHN0cmluZywgYXJnczogYW55KTogdm9pZCB7XG4gICAgICAgIHN3aXRjaCAoZnVuY3Rpb25OYW1lKSB7XG4gICAgICAgICAgICBjYXNlICdnZXREZXRhaWxzJzpcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2dldERldGFpbHMnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3VwZGF0ZVByZWZlcmVuY2VzJzpcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3VwZGF0ZVByZWZlcmVuY2VzJywgYXJncy5wcmVmcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd1cGRhdGVEYXRlcyc6XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCd1cGRhdGVEYXRlcycsIGFyZ3Muc3RhcnQsIGFyZ3MuZW5kKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3VwZGF0ZUJ1ZGdldCc6XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCd1cGRhdGVCdWRnZXQnLCBhcmdzLmxldmVsKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3VwZGF0ZUxhbmd1YWdlJzpcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3VwZGF0ZUxhbmd1YWdlJywgYXJncy5sYW5nKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBVbmtub3duIGZ1bmN0aW9uIGNhbGw6ICR7ZnVuY3Rpb25OYW1lfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIHByb2Nlc3NBSVJlc3BvbnNlKHJlc3BvbnNlOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGZ1bmN0aW9uIGNhbGxzIGluIHRoZSByZXNwb25zZVxuICAgICAgICBjb25zdCBmdW5jdGlvbkNhbGxSZWdleCA9IC9cXGIoZ2V0RGV0YWlsc3x1cGRhdGVQcmVmZXJlbmNlc3x1cGRhdGVEYXRlc3x1cGRhdGVCdWRnZXR8dXBkYXRlTGFuZ3VhZ2UpXFwoKC4qPylcXCkvZztcbiAgICAgICAgbGV0IG1hdGNoO1xuXG4gICAgICAgIHdoaWxlICgobWF0Y2ggPSBmdW5jdGlvbkNhbGxSZWdleC5leGVjKHJlc3BvbnNlKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IFtfLCBmdW5jdGlvbk5hbWUsIGFyZ3NTdHJdID0gbWF0Y2g7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBhcmdzU3RyID8gSlNPTi5wYXJzZShgeyR7YXJnc1N0cn19YCkgOiB7fTtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUZ1bmN0aW9uQ2FsbChmdW5jdGlvbk5hbWUsIGFyZ3MpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBwcm9jZXNzaW5nIGZ1bmN0aW9uIGNhbGw6ICR7ZXJyb3J9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgc2VuZE1lc3NhZ2UobWVzc2FnZTogc3RyaW5nKTogUHJvbWlzZTxSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI8VWludDhBcnJheT4+IHtcbiAgICAgICAgY29uc3QgdXNlck1lc3NhZ2UgPSB7XG4gICAgICAgICAgICBpZDogRGF0ZS5ub3coKS50b1N0cmluZygpLFxuICAgICAgICAgICAgcm9sZTogJ3VzZXInLFxuICAgICAgICAgICAgY29udGVudDogbWVzc2FnZVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuYWRkTWVzc2FnZSh1c2VyTWVzc2FnZSk7XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9jaGF0LXVwZGF0ZScsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IFxuICAgICAgICAgICAgICAgIG1lc3NhZ2VzOiB0aGlzLmNoYXRIaXN0b3J5Lm1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgIGN1cnJlbnREZXRhaWxzOiB0aGlzLmN1cnJlbnREZXRhaWxzLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudFVwZGF0ZTogbnVsbFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5lcnJvciB8fCAnRmFpbGVkIHRvIGdldCByZXNwb25zZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVhZGVyID0gcmVzcG9uc2UuYm9keT8uZ2V0UmVhZGVyKCk7XG4gICAgICAgIGlmICghcmVhZGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHJlc3BvbnNlIGJvZHknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBlbXB0eSBhc3Npc3RhbnQgbWVzc2FnZSB0aGF0IHdpbGwgYmUgdXBkYXRlZCBkdXJpbmcgc3RyZWFtaW5nXG4gICAgICAgIHRoaXMuYWRkTWVzc2FnZSh7XG4gICAgICAgICAgICBpZDogKERhdGUubm93KCkgKyAxKS50b1N0cmluZygpLFxuICAgICAgICAgICAgcm9sZTogJ2Fzc2lzdGFudCcsXG4gICAgICAgICAgICBjb250ZW50OiAnJ1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVhZGVyO1xuICAgIH1cblxuICAgIHB1YmxpYyB1cGRhdGVEZXRhaWxzKGRldGFpbHM6IFBhcnRpYWw8VHJhdmVsRGV0YWlscz4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jdXJyZW50RGV0YWlscyA9IHsgLi4udGhpcy5jdXJyZW50RGV0YWlscywgLi4uZGV0YWlscyB9O1xuICAgICAgICB0aGlzLmVtaXQoJ2RldGFpbHNVcGRhdGVkJywgdGhpcy5jdXJyZW50RGV0YWlscyk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldEN1cnJlbnREZXRhaWxzKCk6IFRyYXZlbERldGFpbHMge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50RGV0YWlscztcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgaGFuZGxlVG9vbFVwZGF0ZShcbiAgICAgICAgdG9vbE5hbWU6IENvbXBvbmVudFR5cGUsXG4gICAgICAgIHZhbHVlOiBhbnlcbiAgICApOiBQcm9taXNlPHtcbiAgICAgICAgdXBkYXRlZERldGFpbHM6IFRyYXZlbERldGFpbHM7XG4gICAgICAgIHJlYWRlcjogUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyPFVpbnQ4QXJyYXk+O1xuICAgIH0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIExvZyB0aGUgc3RhcnQgb2YgdGhlIG9wZXJhdGlvblxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1toYW5kbGVUb29sVXBkYXRlXSBTdGFydGluZyB1cGRhdGUuLi4nLCB7IHRvb2xOYW1lLCB2YWx1ZSB9KTtcbiAgICBcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBkZXRhaWxzXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkRGV0YWlscyA9IHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLmN1cnJlbnREZXRhaWxzLFxuICAgICAgICAgICAgICAgIC4uLih0b29sTmFtZSA9PT0gJ2J1ZGdldFNlbGVjdG9yJyA/IHsgYnVkZ2V0OiB2YWx1ZSB9IDoge30pXG4gICAgICAgICAgICB9O1xuICAgIFxuICAgICAgICAgICAgLy8gTG9nIHRoZSByZXF1ZXN0IHByZXBhcmF0aW9uXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW2hhbmRsZVRvb2xVcGRhdGVdIFByZXBhcmluZyByZXF1ZXN0IHdpdGg6JywgeyBcbiAgICAgICAgICAgICAgICB0eXBlOiB0b29sTmFtZSwgXG4gICAgICAgICAgICAgICAgdmFsdWUsIFxuICAgICAgICAgICAgICAgIGRldGFpbHM6IHVwZGF0ZWREZXRhaWxzIFxuICAgICAgICAgICAgfSk7XG4gICAgXG4gICAgICAgICAgICAvLyBTaW1wbGlmaWVkIHJlcXVlc3QgYm9keVxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdEJvZHkgPSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZXM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHJvbGU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogYEkndmUgc2V0IG15IHRyYXZlbCBidWRnZXQgdG86ICR7dmFsdWV9YFxuICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgIGN1cnJlbnREZXRhaWxzOiB1cGRhdGVkRGV0YWlscyxcbiAgICAgICAgICAgICAgICBjb21wb25lbnRVcGRhdGU6IHsgXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHRvb2xOYW1lLCBcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgIFxuICAgICAgICAgICAgLy8gTWFrZSB0aGUgcmVxdWVzdFxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1toYW5kbGVUb29sVXBkYXRlXSBNYWtpbmcgQVBJIHJlcXVlc3QuLi4nKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvY2hhdC11cGRhdGUnLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocmVxdWVzdEJvZHkpXG4gICAgICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbaGFuZGxlVG9vbFVwZGF0ZV0gUmVzcG9uc2UgcmVjZWl2ZWQ6JywgcmVzcG9uc2Uuc3RhdHVzKTtcbiAgICBcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFQSSByZXR1cm5lZCAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHk/LmdldFJlYWRlcigpO1xuICAgICAgICAgICAgaWYgKCFyZWFkZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHJlc3BvbnNlIGJvZHkgYXZhaWxhYmxlJyk7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW2hhbmRsZVRvb2xVcGRhdGVdIEdvdCByZWFkZXIgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnREZXRhaWxzID0gdXBkYXRlZERldGFpbHM7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2RldGFpbHNVcGRhdGVkJywgdXBkYXRlZERldGFpbHMpO1xuICAgIFxuICAgICAgICAgICAgcmV0dXJuIHsgdXBkYXRlZERldGFpbHMsIHJlYWRlciB9O1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignW2hhbmRsZVRvb2xVcGRhdGVdIEVycm9yOicsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGZvcm1hdFVwZGF0ZU1lc3NhZ2UodG9vbE5hbWU6IENvbXBvbmVudFR5cGUsIHZhbHVlOiBhbnkpOiBzdHJpbmcge1xuICAgICAgICBzd2l0Y2ggKHRvb2xOYW1lKSB7XG4gICAgICAgICAgICBjYXNlICdkYXRlUGlja2VyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYEkndmUgc2VsZWN0ZWQgdGhlc2UgdHJhdmVsIGRhdGVzOiAke3ZhbHVlLnN0YXJ0RGF0ZX0gdG8gJHt2YWx1ZS5lbmREYXRlfWA7XG4gICAgICAgICAgICBjYXNlICdwcmVmZXJlbmNlU2VsZWN0b3InOlxuICAgICAgICAgICAgICAgIHJldHVybiBgSSd2ZSB1cGRhdGVkIG15IHRyYXZlbCBwcmVmZXJlbmNlcyB0bzogJHtBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLmpvaW4oJywgJykgOiB2YWx1ZX1gO1xuICAgICAgICAgICAgY2FzZSAnYnVkZ2V0U2VsZWN0b3InOlxuICAgICAgICAgICAgICAgIHJldHVybiBgSSd2ZSBzZXQgbXkgdHJhdmVsIGJ1ZGdldCB0bzogJHt2YWx1ZX1gO1xuICAgICAgICAgICAgY2FzZSAnbGFuZ3VhZ2VTZWxlY3Rvcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBJJ2QgbGlrZSB0aGUgUERGIGV4cG9ydCBpbiB0aGlzIGxhbmd1YWdlOiAke3ZhbHVlfWA7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBgSSd2ZSB1cGRhdGVkIG15ICR7dG9vbE5hbWUucmVwbGFjZSgvKFtBLVpdKS9nLCAnICQxJykudG9Mb3dlckNhc2UoKX0gdG86ICR7QXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5qb2luKCcsICcpIDogdmFsdWV9YDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBwcm9jZXNzU3RyZWFtaW5nUmVzcG9uc2UoXG4gICAgICAgIHJlYWRlcjogUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyPFVpbnQ4QXJyYXk+LFxuICAgICAgICBvbkNodW5rOiAoY29udGVudDogc3RyaW5nKSA9PiB2b2lkXG4gICAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdbcHJvY2Vzc1N0cmVhbWluZ1Jlc3BvbnNlXSBTdGFydGluZyB0byBwcm9jZXNzIHN0cmVhbScpO1xuICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgICAgIGxldCBidWZmZXIgPSAnJztcbiAgICAgICAgbGV0IGN1cnJlbnRNZXNzYWdlID0gdGhpcy5jaGF0SGlzdG9yeS5tZXNzYWdlc1t0aGlzLmNoYXRIaXN0b3J5Lm1lc3NhZ2VzLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbcHJvY2Vzc1N0cmVhbWluZ1Jlc3BvbnNlXSBSZWFkaW5nIGNodW5rLi4uJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW3Byb2Nlc3NTdHJlYW1pbmdSZXNwb25zZV0gU3RyZWFtIGNvbXBsZXRlJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gZGVjb2Rlci5kZWNvZGUodmFsdWUsIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbcHJvY2Vzc1N0cmVhbWluZ1Jlc3BvbnNlXSBSYXcgY2h1bmsgcmVjZWl2ZWQ6JywgY2h1bmspO1xuICAgICAgICAgICAgICAgIGJ1ZmZlciArPSBjaHVuaztcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lcyA9IGJ1ZmZlci5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgYnVmZmVyID0gbGluZXMucG9wKCkgfHwgJyc7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1twcm9jZXNzU3RyZWFtaW5nUmVzcG9uc2VdIFByb2Nlc3NpbmcgbGluZTonLCBsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmUuc3RhcnRzV2l0aCgnZGF0YTogJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBsaW5lLnNsaWNlKDYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEgPT09ICdbRE9ORV0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1twcm9jZXNzU3RyZWFtaW5nUmVzcG9uc2VdIFJlY2VpdmVkIFtET05FXSBzaWduYWwnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbcHJvY2Vzc1N0cmVhbWluZ1Jlc3BvbnNlXSBQYXJzZWQgZGF0YTonLCBwYXJzZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZWQuY2hvaWNlcz8uWzBdPy5kZWx0YT8uY29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gcGFyc2VkLmNob2ljZXNbMF0uZGVsdGEuY29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1twcm9jZXNzU3RyZWFtaW5nUmVzcG9uc2VdIENvbnRlbnQgY2h1bms6JywgY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2h1bmsoY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGN1cnJlbnQgbWVzc2FnZSBjb250ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50TWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE1lc3NhZ2UuY29udGVudCArPSBjb250ZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1twcm9jZXNzU3RyZWFtaW5nUmVzcG9uc2VdIEVycm9yIHBhcnNpbmcgZGF0YTonLCBlLCAnUmF3IGRhdGE6JywgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFByb2Nlc3MgYW55IGZ1bmN0aW9uIGNhbGxzIGluIHRoZSBjb21wbGV0ZSBtZXNzYWdlXG4gICAgICAgICAgICBpZiAoY3VycmVudE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW3Byb2Nlc3NTdHJlYW1pbmdSZXNwb25zZV0gRmluYWwgbWVzc2FnZTonLCBjdXJyZW50TWVzc2FnZS5jb250ZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NBSVJlc3BvbnNlKGN1cnJlbnRNZXNzYWdlLmNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2VVcGRhdGVkJywgY3VycmVudE1lc3NhZ2UpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignW3Byb2Nlc3NTdHJlYW1pbmdSZXNwb25zZV0gU3RyZWFtIHByb2Nlc3NpbmcgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW3Byb2Nlc3NTdHJlYW1pbmdSZXNwb25zZV0gQ2xlYW5pbmcgdXAgc3RyZWFtJyk7XG4gICAgICAgICAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdLCJuYW1lcyI6WyJFdmVudEVtaXR0ZXIiLCJTdXBwb3J0ZWRMYW5ndWFnZSIsIkFJQ2hhdE1hbmFnZXIiLCJpbml0aWFsaXplQ2hhdEhpc3RvcnkiLCJtZXNzYWdlcyIsIm1ldGFkYXRhIiwibGFzdEludGVyYWN0aW9uVGltZSIsIkRhdGUiLCJjdXJyZW50U3RhdGUiLCJ2YWxpZFBhcmFtZXRlcnMiLCJoYW5kbGVNZXNzYWdlIiwibWVzc2FnZSIsImFkZE1lc3NhZ2UiLCJpZCIsIm5vdyIsInRvU3RyaW5nIiwicm9sZSIsImNvbnRlbnQiLCJyZXNwb25zZSIsInByb2Nlc3NNZXNzYWdlIiwiZGF0YSIsImN1cnJlbnREZXRhaWxzIiwicGFyYW1ldGVycyIsImVycm9yIiwiY29uc29sZSIsIkVycm9yIiwiY2hhdEhpc3RvcnkiLCJyZWNvdmVyQ29udmVyc2F0aW9uIiwidXBkYXRlZFBhcmFtZXRlcnMiLCJleHRyYWN0UGFyYW1ldGVycyIsInZhbGlkYXRpb25SZXN1bHQiLCJ2YWxpZGF0ZVBhcmFtZXRlcnMiLCJpc1ZhbGlkIiwidXBkYXRlU3RhdGUiLCJtaXNzaW5nUGFyYW1zIiwiam9pbiIsInN1Z2dlc3RlZEFjdGlvbiIsIkFycmF5IiwiZnJvbSIsInJlcXVpcmVkUGFyYW1ldGVycyIsImZpbHRlciIsInBhcmFtIiwiaW52YWxpZFBhcmFtcyIsImJ1ZGdldCIsImluY2x1ZGVzIiwicHVzaCIsImxhbmd1YWdlIiwiT2JqZWN0Iiwia2V5cyIsInByZWZlcmVuY2VzIiwic29tZSIsInByZWYiLCJsZW5ndGgiLCJnZXRDdXJyZW50UGFyYW1ldGVycyIsIm1heEhpc3RvcnlMZW5ndGgiLCJzbGljZSIsImVtaXQiLCJnZXRDb250ZXh0SGlzdG9yeSIsImxhc3RNZXNzYWdlIiwicmV2ZXJzZSIsImZpbmQiLCJtc2ciLCJuZXdTdGF0ZSIsImN1cnJlbnRQYXJhbXMiLCJjbGVhckhpc3RvcnkiLCJmb3JtYXRNZXNzYWdlQ29udGVudCIsInRyaW1tZWRDb250ZW50IiwicmVwbGFjZSIsInRyaW0iLCJ1cGRhdGVTeXN0ZW1Db250ZXh0IiwiZGV0YWlscyIsInN5c3RlbU1lc3NhZ2UiLCJtIiwiZGVzdGluYXRpb24iLCJzdGFydERhdGUiLCJlbmREYXRlIiwiaGFuZGxlRnVuY3Rpb25DYWxsIiwiZnVuY3Rpb25OYW1lIiwiYXJncyIsInByZWZzIiwic3RhcnQiLCJlbmQiLCJsZXZlbCIsImxhbmciLCJ3YXJuIiwicHJvY2Vzc0FJUmVzcG9uc2UiLCJmdW5jdGlvbkNhbGxSZWdleCIsIm1hdGNoIiwiZXhlYyIsIl8iLCJhcmdzU3RyIiwiSlNPTiIsInBhcnNlIiwic2VuZE1lc3NhZ2UiLCJ1c2VyTWVzc2FnZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJzdHJpbmdpZnkiLCJjb21wb25lbnRVcGRhdGUiLCJvayIsImVycm9yRGF0YSIsImpzb24iLCJyZWFkZXIiLCJnZXRSZWFkZXIiLCJ1cGRhdGVEZXRhaWxzIiwiZ2V0Q3VycmVudERldGFpbHMiLCJoYW5kbGVUb29sVXBkYXRlIiwidG9vbE5hbWUiLCJ2YWx1ZSIsImxvZyIsInVwZGF0ZWREZXRhaWxzIiwidHlwZSIsInJlcXVlc3RCb2R5Iiwic3RhdHVzIiwiZm9ybWF0VXBkYXRlTWVzc2FnZSIsImlzQXJyYXkiLCJ0b0xvd2VyQ2FzZSIsInByb2Nlc3NTdHJlYW1pbmdSZXNwb25zZSIsIm9uQ2h1bmsiLCJkZWNvZGVyIiwiVGV4dERlY29kZXIiLCJidWZmZXIiLCJjdXJyZW50TWVzc2FnZSIsImRvbmUiLCJyZWFkIiwiY2h1bmsiLCJkZWNvZGUiLCJzdHJlYW0iLCJsaW5lcyIsInNwbGl0IiwicG9wIiwibGluZSIsInN0YXJ0c1dpdGgiLCJwYXJzZWQiLCJjaG9pY2VzIiwiZGVsdGEiLCJlIiwicmVsZWFzZUxvY2siLCJjb25zdHJ1Y3RvciIsImluaXRpYWxEZXRhaWxzIiwiU2V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./managers/ai-chat-manager.ts\n"));

/***/ })

});