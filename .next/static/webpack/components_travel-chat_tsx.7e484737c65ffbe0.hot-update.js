"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("components_travel-chat_tsx",{

/***/ "./managers/ai-chat-manager.ts":
/*!*************************************!*\
  !*** ./managers/ai-chat-manager.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AIChatManager: function() { return /* binding */ AIChatManager; }\n/* harmony export */ });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"./node_modules/next/dist/compiled/events/events.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ \"./managers/types.ts\");\n\n\nclass AIChatManager extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    initializeChatHistory() {\n        return {\n            messages: [],\n            metadata: {\n                lastInteractionTime: new Date(),\n                currentState: \"initial\",\n                validParameters: []\n            }\n        };\n    }\n    async handleMessage(message) {\n        try {\n            // Add user message to history\n            this.addMessage({\n                id: Date.now().toString(),\n                role: \"user\",\n                content: message\n            });\n            // Process message and update parameters\n            const response = await this.processMessage(message);\n            // Add AI response to history\n            this.addMessage({\n                id: (Date.now() + 1).toString(),\n                role: \"assistant\",\n                content: response.message,\n                data: {\n                    currentDetails: response.parameters\n                }\n            });\n            return response;\n        } catch (error) {\n            console.error(\"Error handling message:\", error);\n            return {\n                message: \"I encountered an error processing your message. Let's continue from where we left off.\",\n                error: error instanceof Error ? error.message : \"Unknown error\"\n            };\n        }\n    }\n    async processMessage(message) {\n        const currentState = this.chatHistory.metadata.currentState;\n        if (currentState === \"interrupted\") {\n            return this.recoverConversation();\n        }\n        // Update state based on message content and current parameters\n        const updatedParameters = await this.extractParameters(message);\n        const validationResult = this.validateParameters(updatedParameters);\n        if (validationResult.isValid) {\n            this.updateState(\"planning\");\n            return {\n                message: \"Great! I have all the information needed. Let me plan your trip.\",\n                parameters: updatedParameters\n            };\n        }\n        return {\n            message: \"Could you please provide your \".concat(validationResult.missingParams.join(\", \"), \"?\"),\n            parameters: updatedParameters,\n            suggestedAction: \"gather_info\"\n        };\n    }\n    validateParameters(parameters) {\n        var _parameters_preferences;\n        const missingParams = Array.from(this.requiredParameters).filter((param)=>!parameters[param]);\n        const invalidParams = [];\n        // Validate budget format\n        if (parameters.budget && ![\n            \"$\",\n            \"$$\",\n            \"$$$\",\n            \"$$$$\"\n        ].includes(parameters.budget)) {\n            invalidParams.push(\"budget\");\n        }\n        // Validate language\n        if (parameters.language && !Object.keys(_types__WEBPACK_IMPORTED_MODULE_1__.SupportedLanguage).includes(parameters.language)) {\n            invalidParams.push(\"language\");\n        }\n        // Validate preferences\n        if ((_parameters_preferences = parameters.preferences) === null || _parameters_preferences === void 0 ? void 0 : _parameters_preferences.some((pref)=>![\n                \"Culture and Heritage\",\n                \"Nature\",\n                \"Foodie\",\n                \"Leisure\",\n                \"Adventure\",\n                \"Arts and Museums\"\n            ].includes(pref))) {\n            invalidParams.push(\"preferences\");\n        }\n        return {\n            isValid: missingParams.length === 0 && invalidParams.length === 0,\n            missingParams,\n            invalidParams\n        };\n    }\n    async extractParameters(message) {\n        // Implement NLP or pattern matching logic to extract parameters\n        // For now, return current parameters\n        const currentDetails = this.getCurrentParameters();\n        return {\n            ...currentDetails\n        };\n    }\n    addMessage(message) {\n        this.chatHistory.messages.push(message);\n        this.chatHistory.metadata.lastInteractionTime = new Date();\n        // Trim history if it exceeds maxHistoryLength\n        if (this.chatHistory.messages.length > this.maxHistoryLength) {\n            this.chatHistory.messages = this.chatHistory.messages.slice(-this.maxHistoryLength);\n        }\n        this.emit(\"messageAdded\", message);\n    }\n    getContextHistory() {\n        return this.chatHistory;\n    }\n    getCurrentParameters() {\n        var _lastMessage_data;\n        const lastMessage = this.chatHistory.messages.reverse().find((msg)=>{\n            var _msg_data;\n            return (_msg_data = msg.data) === null || _msg_data === void 0 ? void 0 : _msg_data.currentDetails;\n        });\n        return (lastMessage === null || lastMessage === void 0 ? void 0 : (_lastMessage_data = lastMessage.data) === null || _lastMessage_data === void 0 ? void 0 : _lastMessage_data.currentDetails) || {};\n    }\n    updateState(newState) {\n        this.chatHistory.metadata.currentState = newState;\n        this.emit(\"stateChanged\", newState);\n    }\n    async recoverConversation() {\n        const currentParams = this.getCurrentParameters();\n        const validationResult = this.validateParameters(currentParams);\n        this.updateState(\"gathering_info\");\n        return {\n            message: \"Let me help you get back on track. \" + (validationResult.missingParams.length > 0 ? \"I still need your \".concat(validationResult.missingParams.join(\", \"), \".\") : \"We were about to start planning your trip.\"),\n            parameters: currentParams\n        };\n    }\n    clearHistory() {\n        this.chatHistory = this.initializeChatHistory();\n        this.emit(\"historyCleared\");\n    }\n    formatMessageContent(content) {\n        if (!content) return \"\";\n        // Remove excessive newlines\n        const trimmedContent = content.replace(/\\n{3,}/g, \"\\n\\n\");\n        // Ensure proper spacing around special characters\n        return trimmedContent.replace(/([.!?])\\s*(?=\\S)/g, \"$1 \") // Add space after punctuation if missing\n        .trim();\n    }\n    updateSystemContext(details) {\n        const systemMessage = this.chatHistory.messages.find((m)=>m.role === \"system\");\n        if (systemMessage) {\n            var _details_preferences;\n            systemMessage.content = \"You are a knowledgeable travel assistant. Your role is to help users plan their trips by:\\n1. Understanding and remembering their travel preferences, dates, and budget\\n2. Providing detailed information about their chosen destination\\n3. Making suggestions based on their interests and constraints\\n\\nCurrent Travel Details:\\n- Destination: \".concat(details.destination || \"Not specified\", \"\\n- Dates: \").concat(details.startDate ? \"\".concat(details.startDate, \" to \").concat(details.endDate) : \"Not specified\", \"\\n- Budget Level: \").concat(details.budget || \"Not specified\", \"\\n- Language: \").concat(details.language || \"Not specified\", \"\\n- Preferences: \").concat(((_details_preferences = details.preferences) === null || _details_preferences === void 0 ? void 0 : _details_preferences.join(\", \")) || \"Not specified\", \"\\n\\nKeep this context in mind throughout the conversation. If any detail changes, update your knowledge accordingly.\\nWhen providing information about destinations, include key attractions, local culture, best times to visit, and relevant travel tips.\");\n        }\n        this.emit(\"contextUpdated\", this.chatHistory);\n    }\n    handleFunctionCall(functionName, args) {\n        switch(functionName){\n            case \"getDetails\":\n                this.emit(\"getDetails\");\n                break;\n            case \"updatePreferences\":\n                this.emit(\"updatePreferences\", args.prefs);\n                break;\n            case \"updateDates\":\n                this.emit(\"updateDates\", args.start, args.end);\n                break;\n            case \"updateBudget\":\n                this.emit(\"updateBudget\", args.level);\n                break;\n            case \"updateLanguage\":\n                this.emit(\"updateLanguage\", args.lang);\n                break;\n            default:\n                console.warn(\"Unknown function call: \".concat(functionName));\n        }\n    }\n    processAIResponse(response) {\n        // Check for function calls in the response\n        const functionCallRegex = /\\b(getDetails|updatePreferences|updateDates|updateBudget|updateLanguage)\\((.*?)\\)/g;\n        let match;\n        while((match = functionCallRegex.exec(response)) !== null){\n            const [_, functionName, argsStr] = match;\n            try {\n                const args = argsStr ? JSON.parse(\"{\".concat(argsStr, \"}\")) : {};\n                this.handleFunctionCall(functionName, args);\n            } catch (error) {\n                console.error(\"Error processing function call: \".concat(error));\n            }\n        }\n    }\n    async sendMessage(message) {\n        var _response_body;\n        const response = await fetch(\"/api/chat-update\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                messages: this.chatHistory.messages,\n                currentDetails: this.currentDetails,\n                componentUpdate: null\n            })\n        });\n        if (!response.ok) {\n            const errorData = await response.json();\n            throw new Error(errorData.error || \"Failed to get response\");\n        }\n        const reader = (_response_body = response.body) === null || _response_body === void 0 ? void 0 : _response_body.getReader();\n        if (!reader) {\n            throw new Error(\"No response body\");\n        }\n        return reader;\n    }\n    updateDetails(details) {\n        this.currentDetails = {\n            ...this.currentDetails,\n            ...details\n        };\n        this.emit(\"detailsUpdated\", this.currentDetails);\n    }\n    getCurrentDetails() {\n        return this.currentDetails;\n    }\n    async handleToolUpdate(toolName, value) {\n        try {\n            var _response_body;\n            // Log the start of the operation\n            console.log(\"[handleToolUpdate] Starting update...\", {\n                toolName,\n                value\n            });\n            // Update details\n            const updatedDetails = {\n                ...this.currentDetails,\n                ...toolName === \"budgetSelector\" ? {\n                    budget: value\n                } : {}\n            };\n            // Log the request preparation\n            console.log(\"[handleToolUpdate] Preparing request with:\", {\n                type: toolName,\n                value,\n                details: updatedDetails\n            });\n            // Simplified request body\n            const requestBody = {\n                messages: [\n                    {\n                        role: \"user\",\n                        content: \"I've set my travel budget to: \".concat(value)\n                    }\n                ],\n                currentDetails: updatedDetails,\n                componentUpdate: {\n                    type: toolName,\n                    value\n                }\n            };\n            // Make the request\n            console.log(\"[handleToolUpdate] Making API request...\");\n            const response = await fetch(\"/api/chat-update\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify(requestBody)\n            });\n            console.log(\"[handleToolUpdate] Response received:\", response.status);\n            if (!response.ok) {\n                throw new Error(\"API returned \".concat(response.status));\n            }\n            const reader = (_response_body = response.body) === null || _response_body === void 0 ? void 0 : _response_body.getReader();\n            if (!reader) {\n                throw new Error(\"No response body available\");\n            }\n            console.log(\"[handleToolUpdate] Got reader successfully\");\n            this.currentDetails = updatedDetails;\n            this.emit(\"detailsUpdated\", updatedDetails);\n            return {\n                updatedDetails,\n                reader\n            };\n        } catch (error) {\n            console.error(\"[handleToolUpdate] Error:\", error);\n            throw error;\n        }\n    }\n    formatUpdateMessage(toolName, value) {\n        switch(toolName){\n            case \"datePicker\":\n                return \"I've selected these travel dates: \".concat(value.startDate, \" to \").concat(value.endDate);\n            case \"preferenceSelector\":\n                return \"I've updated my travel preferences to: \".concat(Array.isArray(value) ? value.join(\", \") : value);\n            case \"budgetSelector\":\n                return \"I've set my travel budget to: \".concat(value);\n            case \"languageSelector\":\n                return \"I'd like the PDF export in this language: \".concat(value);\n            default:\n                return \"I've updated my \".concat(toolName.replace(/([A-Z])/g, \" $1\").toLowerCase(), \" to: \").concat(Array.isArray(value) ? value.join(\", \") : value);\n        }\n    }\n    async processStreamingResponse(reader, onChunk) {\n        console.log(\"[processStreamingResponse] Starting to process stream\");\n        const decoder = new TextDecoder();\n        let currentMessage = this.chatHistory.messages[this.chatHistory.messages.length - 1];\n        try {\n            while(true){\n                console.log(\"[processStreamingResponse] Reading chunk...\");\n                const { done, value } = await reader.read();\n                if (done) {\n                    console.log(\"[processStreamingResponse] Stream complete\");\n                    break;\n                }\n                // Directly decode and use the chunk\n                const text = decoder.decode(value, {\n                    stream: true\n                });\n                console.log(\"[processStreamingResponse] Text chunk received:\", text);\n                // Update message content\n                if (currentMessage) {\n                    currentMessage.content += text;\n                }\n                // Call the chunk handler\n                onChunk(text);\n            }\n            // Process any function calls in the complete message\n            if (currentMessage) {\n                console.log(\"[processStreamingResponse] Final message:\", currentMessage.content);\n                this.processAIResponse(currentMessage.content);\n            }\n            this.emit(\"messageUpdated\", currentMessage);\n        } catch (error) {\n            console.error(\"[processStreamingResponse] Stream processing error:\", error);\n            throw error;\n        } finally{\n            console.log(\"[processStreamingResponse] Cleaning up stream\");\n            reader.releaseLock();\n        }\n    }\n    constructor(initialDetails){\n        super();\n        this.chatHistory = this.initializeChatHistory();\n        this.currentDetails = initialDetails;\n        this.requiredParameters = new Set([\n            \"destination\",\n            \"startDate\",\n            \"endDate\",\n            \"budget\",\n            \"language\"\n        ]);\n        this.maxHistoryLength = 50;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9tYW5hZ2Vycy9haS1jaGF0LW1hbmFnZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFzQztBQWFyQjtBQUVWLE1BQU1FLHNCQUFzQkYsZ0RBQVlBO0lBb0JuQ0csd0JBQXFDO1FBQ3pDLE9BQU87WUFDSEMsVUFBVSxFQUFFO1lBQ1pDLFVBQVU7Z0JBQ05DLHFCQUFxQixJQUFJQztnQkFDekJDLGNBQWM7Z0JBQ2RDLGlCQUFpQixFQUFFO1lBQ3ZCO1FBQ0o7SUFDSjtJQUVBLE1BQU1DLGNBQWNDLE9BQWUsRUFBdUI7UUFDdEQsSUFBSTtZQUNBLDhCQUE4QjtZQUM5QixJQUFJLENBQUNDLFVBQVUsQ0FBQztnQkFDWkMsSUFBSU4sS0FBS08sR0FBRyxHQUFHQyxRQUFRO2dCQUN2QkMsTUFBTTtnQkFDTkMsU0FBU047WUFDYjtZQUVBLHdDQUF3QztZQUN4QyxNQUFNTyxXQUFXLE1BQU0sSUFBSSxDQUFDQyxjQUFjLENBQUNSO1lBRTNDLDZCQUE2QjtZQUM3QixJQUFJLENBQUNDLFVBQVUsQ0FBQztnQkFDWkMsSUFBSSxDQUFDTixLQUFLTyxHQUFHLEtBQUssR0FBR0MsUUFBUTtnQkFDN0JDLE1BQU07Z0JBQ05DLFNBQVNDLFNBQVNQLE9BQU87Z0JBQ3pCUyxNQUFNO29CQUNGQyxnQkFBZ0JILFNBQVNJLFVBQVU7Z0JBQ3ZDO1lBQ0o7WUFFQSxPQUFPSjtRQUNYLEVBQUUsT0FBT0ssT0FBTztZQUNaQyxRQUFRRCxLQUFLLENBQUMsMkJBQTJCQTtZQUN6QyxPQUFPO2dCQUNIWixTQUFTO2dCQUNUWSxPQUFPQSxpQkFBaUJFLFFBQVFGLE1BQU1aLE9BQU8sR0FBRztZQUNwRDtRQUNKO0lBQ0o7SUFFQSxNQUFjUSxlQUFlUixPQUFlLEVBQXVCO1FBQy9ELE1BQU1ILGVBQWUsSUFBSSxDQUFDa0IsV0FBVyxDQUFDckIsUUFBUSxDQUFDRyxZQUFZO1FBRTNELElBQUlBLGlCQUFpQixlQUFlO1lBQ2hDLE9BQU8sSUFBSSxDQUFDbUIsbUJBQW1CO1FBQ25DO1FBRUEsK0RBQStEO1FBQy9ELE1BQU1DLG9CQUFvQixNQUFNLElBQUksQ0FBQ0MsaUJBQWlCLENBQUNsQjtRQUN2RCxNQUFNbUIsbUJBQW1CLElBQUksQ0FBQ0Msa0JBQWtCLENBQUNIO1FBRWpELElBQUlFLGlCQUFpQkUsT0FBTyxFQUFFO1lBQzFCLElBQUksQ0FBQ0MsV0FBVyxDQUFDO1lBQ2pCLE9BQU87Z0JBQ0h0QixTQUFTO2dCQUNUVyxZQUFZTTtZQUNoQjtRQUNKO1FBRUEsT0FBTztZQUNIakIsU0FBUyxpQ0FBMkUsT0FBMUNtQixpQkFBaUJJLGFBQWEsQ0FBQ0MsSUFBSSxDQUFDLE9BQU07WUFDcEZiLFlBQVlNO1lBQ1pRLGlCQUFpQjtRQUNyQjtJQUNKO0lBRVFMLG1CQUFtQlQsVUFBNEIsRUFJckQ7WUFpQk1BO1FBaEJKLE1BQU1ZLGdCQUFnQkcsTUFBTUMsSUFBSSxDQUFDLElBQUksQ0FBQ0Msa0JBQWtCLEVBQ25EQyxNQUFNLENBQUNDLENBQUFBLFFBQVMsQ0FBQ25CLFVBQVUsQ0FBQ21CLE1BQWdDO1FBRWpFLE1BQU1DLGdCQUEwQixFQUFFO1FBRWxDLHlCQUF5QjtRQUN6QixJQUFJcEIsV0FBV3FCLE1BQU0sSUFBSSxDQUFDO1lBQUM7WUFBSztZQUFNO1lBQU87U0FBTyxDQUFDQyxRQUFRLENBQUN0QixXQUFXcUIsTUFBTSxHQUFHO1lBQzlFRCxjQUFjRyxJQUFJLENBQUM7UUFDdkI7UUFFQSxvQkFBb0I7UUFDcEIsSUFBSXZCLFdBQVd3QixRQUFRLElBQUksQ0FBQ0MsT0FBT0MsSUFBSSxDQUFDL0MscURBQWlCQSxFQUFFMkMsUUFBUSxDQUFDdEIsV0FBV3dCLFFBQVEsR0FBRztZQUN0RkosY0FBY0csSUFBSSxDQUFDO1FBQ3ZCO1FBRUEsdUJBQXVCO1FBQ3ZCLEtBQUl2QiwwQkFBQUEsV0FBVzJCLFdBQVcsY0FBdEIzQiw4Q0FBQUEsd0JBQXdCNEIsSUFBSSxDQUFDQyxDQUFBQSxPQUM3QixDQUFDO2dCQUFDO2dCQUF3QjtnQkFBVTtnQkFBVTtnQkFBVztnQkFBYTthQUFtQixDQUN4RlAsUUFBUSxDQUFDTyxRQUFRO1lBQ2xCVCxjQUFjRyxJQUFJLENBQUM7UUFDdkI7UUFFQSxPQUFPO1lBQ0hiLFNBQVNFLGNBQWNrQixNQUFNLEtBQUssS0FBS1YsY0FBY1UsTUFBTSxLQUFLO1lBQ2hFbEI7WUFDQVE7UUFDSjtJQUNKO0lBRUEsTUFBY2Isa0JBQWtCbEIsT0FBZSxFQUE2QjtRQUN4RSxnRUFBZ0U7UUFDaEUscUNBQXFDO1FBQ3JDLE1BQU1VLGlCQUFpQixJQUFJLENBQUNnQyxvQkFBb0I7UUFDaEQsT0FBTztZQUNILEdBQUdoQyxjQUFjO1FBQ3JCO0lBQ0o7SUFFUVQsV0FBV0QsT0FBb0IsRUFBUTtRQUMzQyxJQUFJLENBQUNlLFdBQVcsQ0FBQ3RCLFFBQVEsQ0FBQ3lDLElBQUksQ0FBQ2xDO1FBQy9CLElBQUksQ0FBQ2UsV0FBVyxDQUFDckIsUUFBUSxDQUFDQyxtQkFBbUIsR0FBRyxJQUFJQztRQUVwRCw4Q0FBOEM7UUFDOUMsSUFBSSxJQUFJLENBQUNtQixXQUFXLENBQUN0QixRQUFRLENBQUNnRCxNQUFNLEdBQUcsSUFBSSxDQUFDRSxnQkFBZ0IsRUFBRTtZQUMxRCxJQUFJLENBQUM1QixXQUFXLENBQUN0QixRQUFRLEdBQUcsSUFBSSxDQUFDc0IsV0FBVyxDQUFDdEIsUUFBUSxDQUFDbUQsS0FBSyxDQUFDLENBQUMsSUFBSSxDQUFDRCxnQkFBZ0I7UUFDdEY7UUFFQSxJQUFJLENBQUNFLElBQUksQ0FBQyxnQkFBZ0I3QztJQUM5QjtJQUVBOEMsb0JBQWlDO1FBQzdCLE9BQU8sSUFBSSxDQUFDL0IsV0FBVztJQUMzQjtJQUVBMkIsdUJBQXlDO1lBSzlCSztRQUpQLE1BQU1BLGNBQWMsSUFBSSxDQUFDaEMsV0FBVyxDQUFDdEIsUUFBUSxDQUN4Q3VELE9BQU8sR0FDUEMsSUFBSSxDQUFDQyxDQUFBQTtnQkFBT0E7b0JBQUFBLFlBQUFBLElBQUl6QyxJQUFJLGNBQVJ5QyxnQ0FBQUEsVUFBVXhDLGNBQWM7O1FBRXpDLE9BQU9xQyxDQUFBQSx3QkFBQUEsbUNBQUFBLG9CQUFBQSxZQUFhdEMsSUFBSSxjQUFqQnNDLHdDQUFBQSxrQkFBbUJyQyxjQUFjLEtBQUksQ0FBQztJQUNqRDtJQUVRWSxZQUFZNkIsUUFBbUIsRUFBUTtRQUMzQyxJQUFJLENBQUNwQyxXQUFXLENBQUNyQixRQUFRLENBQUNHLFlBQVksR0FBR3NEO1FBQ3pDLElBQUksQ0FBQ04sSUFBSSxDQUFDLGdCQUFnQk07SUFDOUI7SUFFQSxNQUFNbkMsc0JBQTJDO1FBQzdDLE1BQU1vQyxnQkFBZ0IsSUFBSSxDQUFDVixvQkFBb0I7UUFDL0MsTUFBTXZCLG1CQUFtQixJQUFJLENBQUNDLGtCQUFrQixDQUFDZ0M7UUFFakQsSUFBSSxDQUFDOUIsV0FBVyxDQUFDO1FBRWpCLE9BQU87WUFDSHRCLFNBQVMsd0NBQ0FtQixDQUFBQSxpQkFBaUJJLGFBQWEsQ0FBQ2tCLE1BQU0sR0FBRyxJQUNuQyxxQkFBK0QsT0FBMUN0QixpQkFBaUJJLGFBQWEsQ0FBQ0MsSUFBSSxDQUFDLE9BQU0sT0FDL0QsNENBQTJDO1lBQ3pEYixZQUFZeUM7UUFDaEI7SUFDSjtJQUVBQyxlQUFxQjtRQUNqQixJQUFJLENBQUN0QyxXQUFXLEdBQUcsSUFBSSxDQUFDdkIscUJBQXFCO1FBQzdDLElBQUksQ0FBQ3FELElBQUksQ0FBQztJQUNkO0lBRU9TLHFCQUFxQmhELE9BQWUsRUFBVTtRQUNqRCxJQUFJLENBQUNBLFNBQVMsT0FBTztRQUVyQiw0QkFBNEI7UUFDNUIsTUFBTWlELGlCQUFpQmpELFFBQVFrRCxPQUFPLENBQUMsV0FBVztRQUVsRCxrREFBa0Q7UUFDbEQsT0FBT0QsZUFDRkMsT0FBTyxDQUFDLHFCQUFxQixPQUFRLHlDQUF5QztTQUM5RUMsSUFBSTtJQUNiO0lBRU9DLG9CQUFvQkMsT0FBeUIsRUFBUTtRQUN4RCxNQUFNQyxnQkFBZ0IsSUFBSSxDQUFDN0MsV0FBVyxDQUFDdEIsUUFBUSxDQUFDd0QsSUFBSSxDQUFDWSxDQUFBQSxJQUFLQSxFQUFFeEQsSUFBSSxLQUFLO1FBQ3JFLElBQUl1RCxlQUFlO2dCQVdWRDtZQVZMQyxjQUFjdEQsT0FBTyxHQUFHLHdWQU96QnFELE9BRE1BLFFBQVFHLFdBQVcsSUFBSSxpQkFBZ0IsZUFFdENILE9BRFBBLFFBQVFJLFNBQVMsR0FBRyxHQUEyQkosT0FBeEJBLFFBQVFJLFNBQVMsRUFBQyxRQUFzQixPQUFoQkosUUFBUUssT0FBTyxJQUFLLGlCQUFnQixzQkFFaEZMLE9BRElBLFFBQVEzQixNQUFNLElBQUksaUJBQWdCLGtCQUVuQzJCLE9BREhBLFFBQVF4QixRQUFRLElBQUksaUJBQWdCLHFCQUNrQixPQUFuRHdCLEVBQUFBLHVCQUFBQSxRQUFRckIsV0FBVyxjQUFuQnFCLDJDQUFBQSxxQkFBcUJuQyxJQUFJLENBQUMsVUFBUyxpQkFBZ0I7UUFJNUQ7UUFDQSxJQUFJLENBQUNxQixJQUFJLENBQUMsa0JBQWtCLElBQUksQ0FBQzlCLFdBQVc7SUFDaEQ7SUFFUWtELG1CQUFtQkMsWUFBb0IsRUFBRUMsSUFBUyxFQUFRO1FBQzlELE9BQVFEO1lBQ0osS0FBSztnQkFDRCxJQUFJLENBQUNyQixJQUFJLENBQUM7Z0JBQ1Y7WUFDSixLQUFLO2dCQUNELElBQUksQ0FBQ0EsSUFBSSxDQUFDLHFCQUFxQnNCLEtBQUtDLEtBQUs7Z0JBQ3pDO1lBQ0osS0FBSztnQkFDRCxJQUFJLENBQUN2QixJQUFJLENBQUMsZUFBZXNCLEtBQUtFLEtBQUssRUFBRUYsS0FBS0csR0FBRztnQkFDN0M7WUFDSixLQUFLO2dCQUNELElBQUksQ0FBQ3pCLElBQUksQ0FBQyxnQkFBZ0JzQixLQUFLSSxLQUFLO2dCQUNwQztZQUNKLEtBQUs7Z0JBQ0QsSUFBSSxDQUFDMUIsSUFBSSxDQUFDLGtCQUFrQnNCLEtBQUtLLElBQUk7Z0JBQ3JDO1lBQ0o7Z0JBQ0kzRCxRQUFRNEQsSUFBSSxDQUFDLDBCQUF1QyxPQUFiUDtRQUMvQztJQUNKO0lBRU9RLGtCQUFrQm5FLFFBQWdCLEVBQVE7UUFDN0MsMkNBQTJDO1FBQzNDLE1BQU1vRSxvQkFBb0I7UUFDMUIsSUFBSUM7UUFFSixNQUFPLENBQUNBLFFBQVFELGtCQUFrQkUsSUFBSSxDQUFDdEUsU0FBUSxNQUFPLEtBQU07WUFDeEQsTUFBTSxDQUFDdUUsR0FBR1osY0FBY2EsUUFBUSxHQUFHSDtZQUNuQyxJQUFJO2dCQUNBLE1BQU1ULE9BQU9ZLFVBQVVDLEtBQUtDLEtBQUssQ0FBQyxJQUFZLE9BQVJGLFNBQVEsUUFBTSxDQUFDO2dCQUNyRCxJQUFJLENBQUNkLGtCQUFrQixDQUFDQyxjQUFjQztZQUMxQyxFQUFFLE9BQU92RCxPQUFPO2dCQUNaQyxRQUFRRCxLQUFLLENBQUMsbUNBQXlDLE9BQU5BO1lBQ3JEO1FBQ0o7SUFDSjtJQUVBLE1BQWFzRSxZQUFZbEYsT0FBZSxFQUFvRDtZQWlCekVPO1FBZmYsTUFBTUEsV0FBVyxNQUFNNEUsTUFBTSxvQkFBb0I7WUFDN0NDLFFBQVE7WUFDUkMsU0FBUztnQkFBRSxnQkFBZ0I7WUFBbUI7WUFDOUNDLE1BQU1OLEtBQUtPLFNBQVMsQ0FBQztnQkFDakI5RixVQUFVLElBQUksQ0FBQ3NCLFdBQVcsQ0FBQ3RCLFFBQVE7Z0JBQ25DaUIsZ0JBQWdCLElBQUksQ0FBQ0EsY0FBYztnQkFDbkM4RSxpQkFBaUI7WUFDckI7UUFDSjtRQUVBLElBQUksQ0FBQ2pGLFNBQVNrRixFQUFFLEVBQUU7WUFDZCxNQUFNQyxZQUFZLE1BQU1uRixTQUFTb0YsSUFBSTtZQUNyQyxNQUFNLElBQUk3RSxNQUFNNEUsVUFBVTlFLEtBQUssSUFBSTtRQUN2QztRQUVBLE1BQU1nRixVQUFTckYsaUJBQUFBLFNBQVMrRSxJQUFJLGNBQWIvRSxxQ0FBQUEsZUFBZXNGLFNBQVM7UUFDdkMsSUFBSSxDQUFDRCxRQUFRO1lBQ1QsTUFBTSxJQUFJOUUsTUFBTTtRQUNwQjtRQUVBLE9BQU84RTtJQUNYO0lBRU9FLGNBQWNuQyxPQUErQixFQUFRO1FBQ3hELElBQUksQ0FBQ2pELGNBQWMsR0FBRztZQUFFLEdBQUcsSUFBSSxDQUFDQSxjQUFjO1lBQUUsR0FBR2lELE9BQU87UUFBQztRQUMzRCxJQUFJLENBQUNkLElBQUksQ0FBQyxrQkFBa0IsSUFBSSxDQUFDbkMsY0FBYztJQUNuRDtJQUVPcUYsb0JBQW1DO1FBQ3RDLE9BQU8sSUFBSSxDQUFDckYsY0FBYztJQUM5QjtJQUVBLE1BQWFzRixpQkFDVEMsUUFBdUIsRUFDdkJDLEtBQVUsRUFJWDtRQUNDLElBQUk7Z0JBNENlM0Y7WUEzQ2YsaUNBQWlDO1lBQ2pDTSxRQUFRc0YsR0FBRyxDQUFDLHlDQUF5QztnQkFBRUY7Z0JBQVVDO1lBQU07WUFFdkUsaUJBQWlCO1lBQ2pCLE1BQU1FLGlCQUFpQjtnQkFDbkIsR0FBRyxJQUFJLENBQUMxRixjQUFjO2dCQUN0QixHQUFJdUYsYUFBYSxtQkFBbUI7b0JBQUVqRSxRQUFRa0U7Z0JBQU0sSUFBSSxDQUFDLENBQUM7WUFDOUQ7WUFFQSw4QkFBOEI7WUFDOUJyRixRQUFRc0YsR0FBRyxDQUFDLDhDQUE4QztnQkFDdERFLE1BQU1KO2dCQUNOQztnQkFDQXZDLFNBQVN5QztZQUNiO1lBRUEsMEJBQTBCO1lBQzFCLE1BQU1FLGNBQWM7Z0JBQ2hCN0csVUFBVTtvQkFBQzt3QkFDUFksTUFBTTt3QkFDTkMsU0FBUyxpQ0FBdUMsT0FBTjRGO29CQUM5QztpQkFBRTtnQkFDRnhGLGdCQUFnQjBGO2dCQUNoQlosaUJBQWlCO29CQUNiYSxNQUFNSjtvQkFDTkM7Z0JBQ0o7WUFDSjtZQUVBLG1CQUFtQjtZQUNuQnJGLFFBQVFzRixHQUFHLENBQUM7WUFDWixNQUFNNUYsV0FBVyxNQUFNNEUsTUFBTSxvQkFBb0I7Z0JBQzdDQyxRQUFRO2dCQUNSQyxTQUFTO29CQUFFLGdCQUFnQjtnQkFBbUI7Z0JBQzlDQyxNQUFNTixLQUFLTyxTQUFTLENBQUNlO1lBQ3pCO1lBRUF6RixRQUFRc0YsR0FBRyxDQUFDLHlDQUF5QzVGLFNBQVNnRyxNQUFNO1lBRXBFLElBQUksQ0FBQ2hHLFNBQVNrRixFQUFFLEVBQUU7Z0JBQ2QsTUFBTSxJQUFJM0UsTUFBTSxnQkFBZ0MsT0FBaEJQLFNBQVNnRyxNQUFNO1lBQ25EO1lBRUEsTUFBTVgsVUFBU3JGLGlCQUFBQSxTQUFTK0UsSUFBSSxjQUFiL0UscUNBQUFBLGVBQWVzRixTQUFTO1lBQ3ZDLElBQUksQ0FBQ0QsUUFBUTtnQkFDVCxNQUFNLElBQUk5RSxNQUFNO1lBQ3BCO1lBRUFELFFBQVFzRixHQUFHLENBQUM7WUFDWixJQUFJLENBQUN6RixjQUFjLEdBQUcwRjtZQUN0QixJQUFJLENBQUN2RCxJQUFJLENBQUMsa0JBQWtCdUQ7WUFFNUIsT0FBTztnQkFBRUE7Z0JBQWdCUjtZQUFPO1FBQ3BDLEVBQUUsT0FBT2hGLE9BQU87WUFDWkMsUUFBUUQsS0FBSyxDQUFDLDZCQUE2QkE7WUFDM0MsTUFBTUE7UUFDVjtJQUNKO0lBRU80RixvQkFBb0JQLFFBQXVCLEVBQUVDLEtBQVUsRUFBVTtRQUNwRSxPQUFRRDtZQUNKLEtBQUs7Z0JBQ0QsT0FBTyxxQ0FBMkRDLE9BQXRCQSxNQUFNbkMsU0FBUyxFQUFDLFFBQW9CLE9BQWRtQyxNQUFNbEMsT0FBTztZQUNuRixLQUFLO2dCQUNELE9BQU8sMENBQTBGLE9BQWhEdEMsTUFBTStFLE9BQU8sQ0FBQ1AsU0FBU0EsTUFBTTFFLElBQUksQ0FBQyxRQUFRMEU7WUFDL0YsS0FBSztnQkFDRCxPQUFPLGlDQUF1QyxPQUFOQTtZQUM1QyxLQUFLO2dCQUNELE9BQU8sNkNBQW1ELE9BQU5BO1lBQ3hEO2dCQUNJLE9BQU8sbUJBQTRFeEUsT0FBekR1RSxTQUFTekMsT0FBTyxDQUFDLFlBQVksT0FBT2tELFdBQVcsSUFBRyxTQUF1RCxPQUFoRGhGLE1BQU0rRSxPQUFPLENBQUNQLFNBQVNBLE1BQU0xRSxJQUFJLENBQUMsUUFBUTBFO1FBQ3JJO0lBQ0o7SUFFQSxNQUFhUyx5QkFDVGYsTUFBK0MsRUFDL0NnQixPQUFrQyxFQUNyQjtRQUNiL0YsUUFBUXNGLEdBQUcsQ0FBQztRQUNaLE1BQU1VLFVBQVUsSUFBSUM7UUFDcEIsSUFBSUMsaUJBQWlCLElBQUksQ0FBQ2hHLFdBQVcsQ0FBQ3RCLFFBQVEsQ0FBQyxJQUFJLENBQUNzQixXQUFXLENBQUN0QixRQUFRLENBQUNnRCxNQUFNLEdBQUcsRUFBRTtRQUVwRixJQUFJO1lBQ0EsTUFBTyxLQUFNO2dCQUNUNUIsUUFBUXNGLEdBQUcsQ0FBQztnQkFDWixNQUFNLEVBQUVhLElBQUksRUFBRWQsS0FBSyxFQUFFLEdBQUcsTUFBTU4sT0FBT3FCLElBQUk7Z0JBQ3pDLElBQUlELE1BQU07b0JBQ05uRyxRQUFRc0YsR0FBRyxDQUFDO29CQUNaO2dCQUNKO2dCQUVBLG9DQUFvQztnQkFDcEMsTUFBTWUsT0FBT0wsUUFBUU0sTUFBTSxDQUFDakIsT0FBTztvQkFBRWtCLFFBQVE7Z0JBQUs7Z0JBQ2xEdkcsUUFBUXNGLEdBQUcsQ0FBQyxtREFBbURlO2dCQUUvRCx5QkFBeUI7Z0JBQ3pCLElBQUlILGdCQUFnQjtvQkFDaEJBLGVBQWV6RyxPQUFPLElBQUk0RztnQkFDOUI7Z0JBRUEseUJBQXlCO2dCQUN6Qk4sUUFBUU07WUFDWjtZQUVBLHFEQUFxRDtZQUNyRCxJQUFJSCxnQkFBZ0I7Z0JBQ2hCbEcsUUFBUXNGLEdBQUcsQ0FBQyw2Q0FBNkNZLGVBQWV6RyxPQUFPO2dCQUMvRSxJQUFJLENBQUNvRSxpQkFBaUIsQ0FBQ3FDLGVBQWV6RyxPQUFPO1lBQ2pEO1lBRUEsSUFBSSxDQUFDdUMsSUFBSSxDQUFDLGtCQUFrQmtFO1FBQ2hDLEVBQUUsT0FBT25HLE9BQU87WUFDWkMsUUFBUUQsS0FBSyxDQUFDLHVEQUF1REE7WUFDckUsTUFBTUE7UUFDVixTQUFVO1lBQ05DLFFBQVFzRixHQUFHLENBQUM7WUFDWlAsT0FBT3lCLFdBQVc7UUFDdEI7SUFDSjtJQXRaQUMsWUFBWUMsY0FBNkIsQ0FBRTtRQUN2QyxLQUFLO1FBQ0wsSUFBSSxDQUFDeEcsV0FBVyxHQUFHLElBQUksQ0FBQ3ZCLHFCQUFxQjtRQUM3QyxJQUFJLENBQUNrQixjQUFjLEdBQUc2RztRQUN0QixJQUFJLENBQUMzRixrQkFBa0IsR0FBRyxJQUFJNEYsSUFBSTtZQUM5QjtZQUNBO1lBQ0E7WUFDQTtZQUNBO1NBQ0g7UUFDRCxJQUFJLENBQUM3RSxnQkFBZ0IsR0FBRztJQUM1QjtBQTJZSiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9tYW5hZ2Vycy9haS1jaGF0LW1hbmFnZXIudHM/YzYyYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuaW1wb3J0IHsgXG4gICAgQ2hhdEhpc3RvcnksIFxuICAgIENoYXRNZXNzYWdlLCBcbiAgICBDaGF0U3RhdGUsIFxuICAgIFRyYXZlbFBhcmFtZXRlcnMsXG4gICAgQUlSZXNwb25zZSxcbiAgICBNZXNzYWdlRGF0YSxcbiAgICBCdWRnZXRMZXZlbCxcbiAgICBUcmF2ZWxQcmVmZXJlbmNlLFxuICAgIFN1cHBvcnRlZExhbmd1YWdlLFxuICAgIFRyYXZlbERldGFpbHMsXG4gICAgQ29tcG9uZW50VHlwZVxufSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGNsYXNzIEFJQ2hhdE1hbmFnZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAgIHByaXZhdGUgY2hhdEhpc3Rvcnk6IENoYXRIaXN0b3J5O1xuICAgIHByaXZhdGUgcmVxdWlyZWRQYXJhbWV0ZXJzOiBTZXQ8c3RyaW5nPjtcbiAgICBwcml2YXRlIG1heEhpc3RvcnlMZW5ndGg6IG51bWJlcjtcbiAgICBwcml2YXRlIGN1cnJlbnREZXRhaWxzOiBUcmF2ZWxEZXRhaWxzO1xuXG4gICAgY29uc3RydWN0b3IoaW5pdGlhbERldGFpbHM6IFRyYXZlbERldGFpbHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jaGF0SGlzdG9yeSA9IHRoaXMuaW5pdGlhbGl6ZUNoYXRIaXN0b3J5KCk7XG4gICAgICAgIHRoaXMuY3VycmVudERldGFpbHMgPSBpbml0aWFsRGV0YWlscztcbiAgICAgICAgdGhpcy5yZXF1aXJlZFBhcmFtZXRlcnMgPSBuZXcgU2V0KFtcbiAgICAgICAgICAgICdkZXN0aW5hdGlvbicsXG4gICAgICAgICAgICAnc3RhcnREYXRlJyxcbiAgICAgICAgICAgICdlbmREYXRlJyxcbiAgICAgICAgICAgICdidWRnZXQnLFxuICAgICAgICAgICAgJ2xhbmd1YWdlJ1xuICAgICAgICBdKTtcbiAgICAgICAgdGhpcy5tYXhIaXN0b3J5TGVuZ3RoID0gNTA7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpbml0aWFsaXplQ2hhdEhpc3RvcnkoKTogQ2hhdEhpc3Rvcnkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWVzc2FnZXM6IFtdLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgICBsYXN0SW50ZXJhY3Rpb25UaW1lOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRTdGF0ZTogJ2luaXRpYWwnLFxuICAgICAgICAgICAgICAgIHZhbGlkUGFyYW1ldGVyczogW11cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBoYW5kbGVNZXNzYWdlKG1lc3NhZ2U6IHN0cmluZyk6IFByb21pc2U8QUlSZXNwb25zZT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gQWRkIHVzZXIgbWVzc2FnZSB0byBoaXN0b3J5XG4gICAgICAgICAgICB0aGlzLmFkZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGlkOiBEYXRlLm5vdygpLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgcm9sZTogJ3VzZXInLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2VcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBQcm9jZXNzIG1lc3NhZ2UgYW5kIHVwZGF0ZSBwYXJhbWV0ZXJzXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJvY2Vzc01lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEFkZCBBSSByZXNwb25zZSB0byBoaXN0b3J5XG4gICAgICAgICAgICB0aGlzLmFkZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGlkOiAoRGF0ZS5ub3coKSArIDEpLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgcm9sZTogJ2Fzc2lzdGFudCcsXG4gICAgICAgICAgICAgICAgY29udGVudDogcmVzcG9uc2UubWVzc2FnZSxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnREZXRhaWxzOiByZXNwb25zZS5wYXJhbWV0ZXJzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGhhbmRsaW5nIG1lc3NhZ2U6JywgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnSSBlbmNvdW50ZXJlZCBhbiBlcnJvciBwcm9jZXNzaW5nIHlvdXIgbWVzc2FnZS4gTGV0XFwncyBjb250aW51ZSBmcm9tIHdoZXJlIHdlIGxlZnQgb2ZmLicsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBwcm9jZXNzTWVzc2FnZShtZXNzYWdlOiBzdHJpbmcpOiBQcm9taXNlPEFJUmVzcG9uc2U+IHtcbiAgICAgICAgY29uc3QgY3VycmVudFN0YXRlID0gdGhpcy5jaGF0SGlzdG9yeS5tZXRhZGF0YS5jdXJyZW50U3RhdGU7XG4gICAgICAgIFxuICAgICAgICBpZiAoY3VycmVudFN0YXRlID09PSAnaW50ZXJydXB0ZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWNvdmVyQ29udmVyc2F0aW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgc3RhdGUgYmFzZWQgb24gbWVzc2FnZSBjb250ZW50IGFuZCBjdXJyZW50IHBhcmFtZXRlcnNcbiAgICAgICAgY29uc3QgdXBkYXRlZFBhcmFtZXRlcnMgPSBhd2FpdCB0aGlzLmV4dHJhY3RQYXJhbWV0ZXJzKG1lc3NhZ2UpO1xuICAgICAgICBjb25zdCB2YWxpZGF0aW9uUmVzdWx0ID0gdGhpcy52YWxpZGF0ZVBhcmFtZXRlcnModXBkYXRlZFBhcmFtZXRlcnMpO1xuXG4gICAgICAgIGlmICh2YWxpZGF0aW9uUmVzdWx0LmlzVmFsaWQpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoJ3BsYW5uaW5nJyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdHcmVhdCEgSSBoYXZlIGFsbCB0aGUgaW5mb3JtYXRpb24gbmVlZGVkLiBMZXQgbWUgcGxhbiB5b3VyIHRyaXAuJyxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiB1cGRhdGVkUGFyYW1ldGVyc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZXNzYWdlOiBgQ291bGQgeW91IHBsZWFzZSBwcm92aWRlIHlvdXIgJHt2YWxpZGF0aW9uUmVzdWx0Lm1pc3NpbmdQYXJhbXMuam9pbignLCAnKX0/YCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHVwZGF0ZWRQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgc3VnZ2VzdGVkQWN0aW9uOiAnZ2F0aGVyX2luZm8nXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB2YWxpZGF0ZVBhcmFtZXRlcnMocGFyYW1ldGVyczogVHJhdmVsUGFyYW1ldGVycyk6IHsgXG4gICAgICAgIGlzVmFsaWQ6IGJvb2xlYW47IFxuICAgICAgICBtaXNzaW5nUGFyYW1zOiBzdHJpbmdbXTtcbiAgICAgICAgaW52YWxpZFBhcmFtczogc3RyaW5nW107XG4gICAgfSB7XG4gICAgICAgIGNvbnN0IG1pc3NpbmdQYXJhbXMgPSBBcnJheS5mcm9tKHRoaXMucmVxdWlyZWRQYXJhbWV0ZXJzKVxuICAgICAgICAgICAgLmZpbHRlcihwYXJhbSA9PiAhcGFyYW1ldGVyc1twYXJhbSBhcyBrZXlvZiBUcmF2ZWxQYXJhbWV0ZXJzXSk7XG5cbiAgICAgICAgY29uc3QgaW52YWxpZFBhcmFtczogc3RyaW5nW10gPSBbXTtcblxuICAgICAgICAvLyBWYWxpZGF0ZSBidWRnZXQgZm9ybWF0XG4gICAgICAgIGlmIChwYXJhbWV0ZXJzLmJ1ZGdldCAmJiAhWyckJywgJyQkJywgJyQkJCcsICckJCQkJ10uaW5jbHVkZXMocGFyYW1ldGVycy5idWRnZXQpKSB7XG4gICAgICAgICAgICBpbnZhbGlkUGFyYW1zLnB1c2goJ2J1ZGdldCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgbGFuZ3VhZ2VcbiAgICAgICAgaWYgKHBhcmFtZXRlcnMubGFuZ3VhZ2UgJiYgIU9iamVjdC5rZXlzKFN1cHBvcnRlZExhbmd1YWdlKS5pbmNsdWRlcyhwYXJhbWV0ZXJzLmxhbmd1YWdlKSkge1xuICAgICAgICAgICAgaW52YWxpZFBhcmFtcy5wdXNoKCdsYW5ndWFnZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgcHJlZmVyZW5jZXNcbiAgICAgICAgaWYgKHBhcmFtZXRlcnMucHJlZmVyZW5jZXM/LnNvbWUocHJlZiA9PiBcbiAgICAgICAgICAgICFbJ0N1bHR1cmUgYW5kIEhlcml0YWdlJywgJ05hdHVyZScsICdGb29kaWUnLCAnTGVpc3VyZScsICdBZHZlbnR1cmUnLCAnQXJ0cyBhbmQgTXVzZXVtcyddXG4gICAgICAgICAgICAuaW5jbHVkZXMocHJlZikpKSB7XG4gICAgICAgICAgICBpbnZhbGlkUGFyYW1zLnB1c2goJ3ByZWZlcmVuY2VzJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNWYWxpZDogbWlzc2luZ1BhcmFtcy5sZW5ndGggPT09IDAgJiYgaW52YWxpZFBhcmFtcy5sZW5ndGggPT09IDAsXG4gICAgICAgICAgICBtaXNzaW5nUGFyYW1zLFxuICAgICAgICAgICAgaW52YWxpZFBhcmFtc1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgZXh0cmFjdFBhcmFtZXRlcnMobWVzc2FnZTogc3RyaW5nKTogUHJvbWlzZTxUcmF2ZWxQYXJhbWV0ZXJzPiB7XG4gICAgICAgIC8vIEltcGxlbWVudCBOTFAgb3IgcGF0dGVybiBtYXRjaGluZyBsb2dpYyB0byBleHRyYWN0IHBhcmFtZXRlcnNcbiAgICAgICAgLy8gRm9yIG5vdywgcmV0dXJuIGN1cnJlbnQgcGFyYW1ldGVyc1xuICAgICAgICBjb25zdCBjdXJyZW50RGV0YWlscyA9IHRoaXMuZ2V0Q3VycmVudFBhcmFtZXRlcnMoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmN1cnJlbnREZXRhaWxzXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhZGRNZXNzYWdlKG1lc3NhZ2U6IENoYXRNZXNzYWdlKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY2hhdEhpc3RvcnkubWVzc2FnZXMucHVzaChtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5jaGF0SGlzdG9yeS5tZXRhZGF0YS5sYXN0SW50ZXJhY3Rpb25UaW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFRyaW0gaGlzdG9yeSBpZiBpdCBleGNlZWRzIG1heEhpc3RvcnlMZW5ndGhcbiAgICAgICAgaWYgKHRoaXMuY2hhdEhpc3RvcnkubWVzc2FnZXMubGVuZ3RoID4gdGhpcy5tYXhIaXN0b3J5TGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmNoYXRIaXN0b3J5Lm1lc3NhZ2VzID0gdGhpcy5jaGF0SGlzdG9yeS5tZXNzYWdlcy5zbGljZSgtdGhpcy5tYXhIaXN0b3J5TGVuZ3RoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZUFkZGVkJywgbWVzc2FnZSk7XG4gICAgfVxuXG4gICAgZ2V0Q29udGV4dEhpc3RvcnkoKTogQ2hhdEhpc3Rvcnkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGF0SGlzdG9yeTtcbiAgICB9XG5cbiAgICBnZXRDdXJyZW50UGFyYW1ldGVycygpOiBUcmF2ZWxQYXJhbWV0ZXJzIHtcbiAgICAgICAgY29uc3QgbGFzdE1lc3NhZ2UgPSB0aGlzLmNoYXRIaXN0b3J5Lm1lc3NhZ2VzXG4gICAgICAgICAgICAucmV2ZXJzZSgpXG4gICAgICAgICAgICAuZmluZChtc2cgPT4gbXNnLmRhdGE/LmN1cnJlbnREZXRhaWxzKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBsYXN0TWVzc2FnZT8uZGF0YT8uY3VycmVudERldGFpbHMgfHwge307XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVTdGF0ZShuZXdTdGF0ZTogQ2hhdFN0YXRlKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY2hhdEhpc3RvcnkubWV0YWRhdGEuY3VycmVudFN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIHRoaXMuZW1pdCgnc3RhdGVDaGFuZ2VkJywgbmV3U3RhdGUpO1xuICAgIH1cblxuICAgIGFzeW5jIHJlY292ZXJDb252ZXJzYXRpb24oKTogUHJvbWlzZTxBSVJlc3BvbnNlPiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRQYXJhbXMgPSB0aGlzLmdldEN1cnJlbnRQYXJhbWV0ZXJzKCk7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRpb25SZXN1bHQgPSB0aGlzLnZhbGlkYXRlUGFyYW1ldGVycyhjdXJyZW50UGFyYW1zKTtcblxuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKCdnYXRoZXJpbmdfaW5mbycpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZXNzYWdlOiAnTGV0IG1lIGhlbHAgeW91IGdldCBiYWNrIG9uIHRyYWNrLiAnICtcbiAgICAgICAgICAgICAgICAgICAgKHZhbGlkYXRpb25SZXN1bHQubWlzc2luZ1BhcmFtcy5sZW5ndGggPiAwIFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBgSSBzdGlsbCBuZWVkIHlvdXIgJHt2YWxpZGF0aW9uUmVzdWx0Lm1pc3NpbmdQYXJhbXMuam9pbignLCAnKX0uYFxuICAgICAgICAgICAgICAgICAgICAgICAgOiAnV2Ugd2VyZSBhYm91dCB0byBzdGFydCBwbGFubmluZyB5b3VyIHRyaXAuJyksXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBjdXJyZW50UGFyYW1zXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgY2xlYXJIaXN0b3J5KCk6IHZvaWQge1xuICAgICAgICB0aGlzLmNoYXRIaXN0b3J5ID0gdGhpcy5pbml0aWFsaXplQ2hhdEhpc3RvcnkoKTtcbiAgICAgICAgdGhpcy5lbWl0KCdoaXN0b3J5Q2xlYXJlZCcpO1xuICAgIH1cblxuICAgIHB1YmxpYyBmb3JtYXRNZXNzYWdlQ29udGVudChjb250ZW50OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICBpZiAoIWNvbnRlbnQpIHJldHVybiAnJztcbiAgICAgICAgXG4gICAgICAgIC8vIFJlbW92ZSBleGNlc3NpdmUgbmV3bGluZXNcbiAgICAgICAgY29uc3QgdHJpbW1lZENvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoL1xcbnszLH0vZywgJ1xcblxcbicpO1xuICAgICAgICBcbiAgICAgICAgLy8gRW5zdXJlIHByb3BlciBzcGFjaW5nIGFyb3VuZCBzcGVjaWFsIGNoYXJhY3RlcnNcbiAgICAgICAgcmV0dXJuIHRyaW1tZWRDb250ZW50XG4gICAgICAgICAgICAucmVwbGFjZSgvKFsuIT9dKVxccyooPz1cXFMpL2csICckMSAnKSAgLy8gQWRkIHNwYWNlIGFmdGVyIHB1bmN0dWF0aW9uIGlmIG1pc3NpbmdcbiAgICAgICAgICAgIC50cmltKCk7XG4gICAgfVxuXG4gICAgcHVibGljIHVwZGF0ZVN5c3RlbUNvbnRleHQoZGV0YWlsczogVHJhdmVsUGFyYW1ldGVycyk6IHZvaWQge1xuICAgICAgICBjb25zdCBzeXN0ZW1NZXNzYWdlID0gdGhpcy5jaGF0SGlzdG9yeS5tZXNzYWdlcy5maW5kKG0gPT4gbS5yb2xlID09PSAnc3lzdGVtJyk7XG4gICAgICAgIGlmIChzeXN0ZW1NZXNzYWdlKSB7XG4gICAgICAgICAgICBzeXN0ZW1NZXNzYWdlLmNvbnRlbnQgPSBgWW91IGFyZSBhIGtub3dsZWRnZWFibGUgdHJhdmVsIGFzc2lzdGFudC4gWW91ciByb2xlIGlzIHRvIGhlbHAgdXNlcnMgcGxhbiB0aGVpciB0cmlwcyBieTpcbjEuIFVuZGVyc3RhbmRpbmcgYW5kIHJlbWVtYmVyaW5nIHRoZWlyIHRyYXZlbCBwcmVmZXJlbmNlcywgZGF0ZXMsIGFuZCBidWRnZXRcbjIuIFByb3ZpZGluZyBkZXRhaWxlZCBpbmZvcm1hdGlvbiBhYm91dCB0aGVpciBjaG9zZW4gZGVzdGluYXRpb25cbjMuIE1ha2luZyBzdWdnZXN0aW9ucyBiYXNlZCBvbiB0aGVpciBpbnRlcmVzdHMgYW5kIGNvbnN0cmFpbnRzXG5cbkN1cnJlbnQgVHJhdmVsIERldGFpbHM6XG4tIERlc3RpbmF0aW9uOiAke2RldGFpbHMuZGVzdGluYXRpb24gfHwgJ05vdCBzcGVjaWZpZWQnfVxuLSBEYXRlczogJHtkZXRhaWxzLnN0YXJ0RGF0ZSA/IGAke2RldGFpbHMuc3RhcnREYXRlfSB0byAke2RldGFpbHMuZW5kRGF0ZX1gIDogJ05vdCBzcGVjaWZpZWQnfVxuLSBCdWRnZXQgTGV2ZWw6ICR7ZGV0YWlscy5idWRnZXQgfHwgJ05vdCBzcGVjaWZpZWQnfVxuLSBMYW5ndWFnZTogJHtkZXRhaWxzLmxhbmd1YWdlIHx8ICdOb3Qgc3BlY2lmaWVkJ31cbi0gUHJlZmVyZW5jZXM6ICR7ZGV0YWlscy5wcmVmZXJlbmNlcz8uam9pbignLCAnKSB8fCAnTm90IHNwZWNpZmllZCd9XG5cbktlZXAgdGhpcyBjb250ZXh0IGluIG1pbmQgdGhyb3VnaG91dCB0aGUgY29udmVyc2F0aW9uLiBJZiBhbnkgZGV0YWlsIGNoYW5nZXMsIHVwZGF0ZSB5b3VyIGtub3dsZWRnZSBhY2NvcmRpbmdseS5cbldoZW4gcHJvdmlkaW5nIGluZm9ybWF0aW9uIGFib3V0IGRlc3RpbmF0aW9ucywgaW5jbHVkZSBrZXkgYXR0cmFjdGlvbnMsIGxvY2FsIGN1bHR1cmUsIGJlc3QgdGltZXMgdG8gdmlzaXQsIGFuZCByZWxldmFudCB0cmF2ZWwgdGlwcy5gO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdCgnY29udGV4dFVwZGF0ZWQnLCB0aGlzLmNoYXRIaXN0b3J5KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGhhbmRsZUZ1bmN0aW9uQ2FsbChmdW5jdGlvbk5hbWU6IHN0cmluZywgYXJnczogYW55KTogdm9pZCB7XG4gICAgICAgIHN3aXRjaCAoZnVuY3Rpb25OYW1lKSB7XG4gICAgICAgICAgICBjYXNlICdnZXREZXRhaWxzJzpcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2dldERldGFpbHMnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3VwZGF0ZVByZWZlcmVuY2VzJzpcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3VwZGF0ZVByZWZlcmVuY2VzJywgYXJncy5wcmVmcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd1cGRhdGVEYXRlcyc6XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCd1cGRhdGVEYXRlcycsIGFyZ3Muc3RhcnQsIGFyZ3MuZW5kKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3VwZGF0ZUJ1ZGdldCc6XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCd1cGRhdGVCdWRnZXQnLCBhcmdzLmxldmVsKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3VwZGF0ZUxhbmd1YWdlJzpcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3VwZGF0ZUxhbmd1YWdlJywgYXJncy5sYW5nKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBVbmtub3duIGZ1bmN0aW9uIGNhbGw6ICR7ZnVuY3Rpb25OYW1lfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIHByb2Nlc3NBSVJlc3BvbnNlKHJlc3BvbnNlOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGZ1bmN0aW9uIGNhbGxzIGluIHRoZSByZXNwb25zZVxuICAgICAgICBjb25zdCBmdW5jdGlvbkNhbGxSZWdleCA9IC9cXGIoZ2V0RGV0YWlsc3x1cGRhdGVQcmVmZXJlbmNlc3x1cGRhdGVEYXRlc3x1cGRhdGVCdWRnZXR8dXBkYXRlTGFuZ3VhZ2UpXFwoKC4qPylcXCkvZztcbiAgICAgICAgbGV0IG1hdGNoO1xuXG4gICAgICAgIHdoaWxlICgobWF0Y2ggPSBmdW5jdGlvbkNhbGxSZWdleC5leGVjKHJlc3BvbnNlKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IFtfLCBmdW5jdGlvbk5hbWUsIGFyZ3NTdHJdID0gbWF0Y2g7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBhcmdzU3RyID8gSlNPTi5wYXJzZShgeyR7YXJnc1N0cn19YCkgOiB7fTtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUZ1bmN0aW9uQ2FsbChmdW5jdGlvbk5hbWUsIGFyZ3MpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBwcm9jZXNzaW5nIGZ1bmN0aW9uIGNhbGw6ICR7ZXJyb3J9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgc2VuZE1lc3NhZ2UobWVzc2FnZTogc3RyaW5nKTogUHJvbWlzZTxSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI8VWludDhBcnJheT4+IHtcblxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL2NoYXQtdXBkYXRlJywge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgXG4gICAgICAgICAgICAgICAgbWVzc2FnZXM6IHRoaXMuY2hhdEhpc3RvcnkubWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgY3VycmVudERldGFpbHM6IHRoaXMuY3VycmVudERldGFpbHMsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50VXBkYXRlOiBudWxsXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLmVycm9yIHx8ICdGYWlsZWQgdG8gZ2V0IHJlc3BvbnNlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5Py5nZXRSZWFkZXIoKTtcbiAgICAgICAgaWYgKCFyZWFkZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcmVzcG9uc2UgYm9keScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlYWRlcjtcbiAgICB9XG5cbiAgICBwdWJsaWMgdXBkYXRlRGV0YWlscyhkZXRhaWxzOiBQYXJ0aWFsPFRyYXZlbERldGFpbHM+KTogdm9pZCB7XG4gICAgICAgIHRoaXMuY3VycmVudERldGFpbHMgPSB7IC4uLnRoaXMuY3VycmVudERldGFpbHMsIC4uLmRldGFpbHMgfTtcbiAgICAgICAgdGhpcy5lbWl0KCdkZXRhaWxzVXBkYXRlZCcsIHRoaXMuY3VycmVudERldGFpbHMpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRDdXJyZW50RGV0YWlscygpOiBUcmF2ZWxEZXRhaWxzIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudERldGFpbHM7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGhhbmRsZVRvb2xVcGRhdGUoXG4gICAgICAgIHRvb2xOYW1lOiBDb21wb25lbnRUeXBlLFxuICAgICAgICB2YWx1ZTogYW55XG4gICAgKTogUHJvbWlzZTx7XG4gICAgICAgIHVwZGF0ZWREZXRhaWxzOiBUcmF2ZWxEZXRhaWxzO1xuICAgICAgICByZWFkZXI6IFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcjxVaW50OEFycmF5PjtcbiAgICB9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMb2cgdGhlIHN0YXJ0IG9mIHRoZSBvcGVyYXRpb25cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbaGFuZGxlVG9vbFVwZGF0ZV0gU3RhcnRpbmcgdXBkYXRlLi4uJywgeyB0b29sTmFtZSwgdmFsdWUgfSk7XG4gICAgXG4gICAgICAgICAgICAvLyBVcGRhdGUgZGV0YWlsc1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlZERldGFpbHMgPSB7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5jdXJyZW50RGV0YWlscyxcbiAgICAgICAgICAgICAgICAuLi4odG9vbE5hbWUgPT09ICdidWRnZXRTZWxlY3RvcicgPyB7IGJ1ZGdldDogdmFsdWUgfSA6IHt9KVxuICAgICAgICAgICAgfTtcbiAgICBcbiAgICAgICAgICAgIC8vIExvZyB0aGUgcmVxdWVzdCBwcmVwYXJhdGlvblxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1toYW5kbGVUb29sVXBkYXRlXSBQcmVwYXJpbmcgcmVxdWVzdCB3aXRoOicsIHsgXG4gICAgICAgICAgICAgICAgdHlwZTogdG9vbE5hbWUsIFxuICAgICAgICAgICAgICAgIHZhbHVlLCBcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiB1cGRhdGVkRGV0YWlscyBcbiAgICAgICAgICAgIH0pO1xuICAgIFxuICAgICAgICAgICAgLy8gU2ltcGxpZmllZCByZXF1ZXN0IGJvZHlcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RCb2R5ID0ge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VzOiBbe1xuICAgICAgICAgICAgICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGBJJ3ZlIHNldCBteSB0cmF2ZWwgYnVkZ2V0IHRvOiAke3ZhbHVlfWBcbiAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICBjdXJyZW50RGV0YWlsczogdXBkYXRlZERldGFpbHMsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50VXBkYXRlOiB7IFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0b29sTmFtZSwgXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICBcbiAgICAgICAgICAgIC8vIE1ha2UgdGhlIHJlcXVlc3RcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbaGFuZGxlVG9vbFVwZGF0ZV0gTWFraW5nIEFQSSByZXF1ZXN0Li4uJyk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL2NoYXQtdXBkYXRlJywge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcXVlc3RCb2R5KVxuICAgICAgICAgICAgfSk7XG4gICAgXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW2hhbmRsZVRvb2xVcGRhdGVdIFJlc3BvbnNlIHJlY2VpdmVkOicsIHJlc3BvbnNlLnN0YXR1cyk7XG4gICAgXG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBUEkgcmV0dXJuZWQgJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5Py5nZXRSZWFkZXIoKTtcbiAgICAgICAgICAgIGlmICghcmVhZGVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyByZXNwb25zZSBib2R5IGF2YWlsYWJsZScpO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1toYW5kbGVUb29sVXBkYXRlXSBHb3QgcmVhZGVyIHN1Y2Nlc3NmdWxseScpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50RGV0YWlscyA9IHVwZGF0ZWREZXRhaWxzO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdkZXRhaWxzVXBkYXRlZCcsIHVwZGF0ZWREZXRhaWxzKTtcbiAgICBcbiAgICAgICAgICAgIHJldHVybiB7IHVwZGF0ZWREZXRhaWxzLCByZWFkZXIgfTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1toYW5kbGVUb29sVXBkYXRlXSBFcnJvcjonLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBmb3JtYXRVcGRhdGVNZXNzYWdlKHRvb2xOYW1lOiBDb21wb25lbnRUeXBlLCB2YWx1ZTogYW55KTogc3RyaW5nIHtcbiAgICAgICAgc3dpdGNoICh0b29sTmFtZSkge1xuICAgICAgICAgICAgY2FzZSAnZGF0ZVBpY2tlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBJJ3ZlIHNlbGVjdGVkIHRoZXNlIHRyYXZlbCBkYXRlczogJHt2YWx1ZS5zdGFydERhdGV9IHRvICR7dmFsdWUuZW5kRGF0ZX1gO1xuICAgICAgICAgICAgY2FzZSAncHJlZmVyZW5jZVNlbGVjdG9yJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYEkndmUgdXBkYXRlZCBteSB0cmF2ZWwgcHJlZmVyZW5jZXMgdG86ICR7QXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5qb2luKCcsICcpIDogdmFsdWV9YDtcbiAgICAgICAgICAgIGNhc2UgJ2J1ZGdldFNlbGVjdG9yJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYEkndmUgc2V0IG15IHRyYXZlbCBidWRnZXQgdG86ICR7dmFsdWV9YDtcbiAgICAgICAgICAgIGNhc2UgJ2xhbmd1YWdlU2VsZWN0b3InOlxuICAgICAgICAgICAgICAgIHJldHVybiBgSSdkIGxpa2UgdGhlIFBERiBleHBvcnQgaW4gdGhpcyBsYW5ndWFnZTogJHt2YWx1ZX1gO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gYEkndmUgdXBkYXRlZCBteSAke3Rvb2xOYW1lLnJlcGxhY2UoLyhbQS1aXSkvZywgJyAkMScpLnRvTG93ZXJDYXNlKCl9IHRvOiAke0FycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUuam9pbignLCAnKSA6IHZhbHVlfWA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgcHJvY2Vzc1N0cmVhbWluZ1Jlc3BvbnNlKFxuICAgICAgICByZWFkZXI6IFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcjxVaW50OEFycmF5PixcbiAgICAgICAgb25DaHVuazogKGNvbnRlbnQ6IHN0cmluZykgPT4gdm9pZFxuICAgICk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zb2xlLmxvZygnW3Byb2Nlc3NTdHJlYW1pbmdSZXNwb25zZV0gU3RhcnRpbmcgdG8gcHJvY2VzcyBzdHJlYW0nKTtcbiAgICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICAgICAgICBsZXQgY3VycmVudE1lc3NhZ2UgPSB0aGlzLmNoYXRIaXN0b3J5Lm1lc3NhZ2VzW3RoaXMuY2hhdEhpc3RvcnkubWVzc2FnZXMubGVuZ3RoIC0gMV07XG4gICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbcHJvY2Vzc1N0cmVhbWluZ1Jlc3BvbnNlXSBSZWFkaW5nIGNodW5rLi4uJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW3Byb2Nlc3NTdHJlYW1pbmdSZXNwb25zZV0gU3RyZWFtIGNvbXBsZXRlJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAvLyBEaXJlY3RseSBkZWNvZGUgYW5kIHVzZSB0aGUgY2h1bmtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gZGVjb2Rlci5kZWNvZGUodmFsdWUsIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbcHJvY2Vzc1N0cmVhbWluZ1Jlc3BvbnNlXSBUZXh0IGNodW5rIHJlY2VpdmVkOicsIHRleHQpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBtZXNzYWdlIGNvbnRlbnRcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE1lc3NhZ2UuY29udGVudCArPSB0ZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBDYWxsIHRoZSBjaHVuayBoYW5kbGVyXG4gICAgICAgICAgICAgICAgb25DaHVuayh0ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIC8vIFByb2Nlc3MgYW55IGZ1bmN0aW9uIGNhbGxzIGluIHRoZSBjb21wbGV0ZSBtZXNzYWdlXG4gICAgICAgICAgICBpZiAoY3VycmVudE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW3Byb2Nlc3NTdHJlYW1pbmdSZXNwb25zZV0gRmluYWwgbWVzc2FnZTonLCBjdXJyZW50TWVzc2FnZS5jb250ZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NBSVJlc3BvbnNlKGN1cnJlbnRNZXNzYWdlLmNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlVXBkYXRlZCcsIGN1cnJlbnRNZXNzYWdlKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1twcm9jZXNzU3RyZWFtaW5nUmVzcG9uc2VdIFN0cmVhbSBwcm9jZXNzaW5nIGVycm9yOicsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1twcm9jZXNzU3RyZWFtaW5nUmVzcG9uc2VdIENsZWFuaW5nIHVwIHN0cmVhbScpO1xuICAgICAgICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iXSwibmFtZXMiOlsiRXZlbnRFbWl0dGVyIiwiU3VwcG9ydGVkTGFuZ3VhZ2UiLCJBSUNoYXRNYW5hZ2VyIiwiaW5pdGlhbGl6ZUNoYXRIaXN0b3J5IiwibWVzc2FnZXMiLCJtZXRhZGF0YSIsImxhc3RJbnRlcmFjdGlvblRpbWUiLCJEYXRlIiwiY3VycmVudFN0YXRlIiwidmFsaWRQYXJhbWV0ZXJzIiwiaGFuZGxlTWVzc2FnZSIsIm1lc3NhZ2UiLCJhZGRNZXNzYWdlIiwiaWQiLCJub3ciLCJ0b1N0cmluZyIsInJvbGUiLCJjb250ZW50IiwicmVzcG9uc2UiLCJwcm9jZXNzTWVzc2FnZSIsImRhdGEiLCJjdXJyZW50RGV0YWlscyIsInBhcmFtZXRlcnMiLCJlcnJvciIsImNvbnNvbGUiLCJFcnJvciIsImNoYXRIaXN0b3J5IiwicmVjb3ZlckNvbnZlcnNhdGlvbiIsInVwZGF0ZWRQYXJhbWV0ZXJzIiwiZXh0cmFjdFBhcmFtZXRlcnMiLCJ2YWxpZGF0aW9uUmVzdWx0IiwidmFsaWRhdGVQYXJhbWV0ZXJzIiwiaXNWYWxpZCIsInVwZGF0ZVN0YXRlIiwibWlzc2luZ1BhcmFtcyIsImpvaW4iLCJzdWdnZXN0ZWRBY3Rpb24iLCJBcnJheSIsImZyb20iLCJyZXF1aXJlZFBhcmFtZXRlcnMiLCJmaWx0ZXIiLCJwYXJhbSIsImludmFsaWRQYXJhbXMiLCJidWRnZXQiLCJpbmNsdWRlcyIsInB1c2giLCJsYW5ndWFnZSIsIk9iamVjdCIsImtleXMiLCJwcmVmZXJlbmNlcyIsInNvbWUiLCJwcmVmIiwibGVuZ3RoIiwiZ2V0Q3VycmVudFBhcmFtZXRlcnMiLCJtYXhIaXN0b3J5TGVuZ3RoIiwic2xpY2UiLCJlbWl0IiwiZ2V0Q29udGV4dEhpc3RvcnkiLCJsYXN0TWVzc2FnZSIsInJldmVyc2UiLCJmaW5kIiwibXNnIiwibmV3U3RhdGUiLCJjdXJyZW50UGFyYW1zIiwiY2xlYXJIaXN0b3J5IiwiZm9ybWF0TWVzc2FnZUNvbnRlbnQiLCJ0cmltbWVkQ29udGVudCIsInJlcGxhY2UiLCJ0cmltIiwidXBkYXRlU3lzdGVtQ29udGV4dCIsImRldGFpbHMiLCJzeXN0ZW1NZXNzYWdlIiwibSIsImRlc3RpbmF0aW9uIiwic3RhcnREYXRlIiwiZW5kRGF0ZSIsImhhbmRsZUZ1bmN0aW9uQ2FsbCIsImZ1bmN0aW9uTmFtZSIsImFyZ3MiLCJwcmVmcyIsInN0YXJ0IiwiZW5kIiwibGV2ZWwiLCJsYW5nIiwid2FybiIsInByb2Nlc3NBSVJlc3BvbnNlIiwiZnVuY3Rpb25DYWxsUmVnZXgiLCJtYXRjaCIsImV4ZWMiLCJfIiwiYXJnc1N0ciIsIkpTT04iLCJwYXJzZSIsInNlbmRNZXNzYWdlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsInN0cmluZ2lmeSIsImNvbXBvbmVudFVwZGF0ZSIsIm9rIiwiZXJyb3JEYXRhIiwianNvbiIsInJlYWRlciIsImdldFJlYWRlciIsInVwZGF0ZURldGFpbHMiLCJnZXRDdXJyZW50RGV0YWlscyIsImhhbmRsZVRvb2xVcGRhdGUiLCJ0b29sTmFtZSIsInZhbHVlIiwibG9nIiwidXBkYXRlZERldGFpbHMiLCJ0eXBlIiwicmVxdWVzdEJvZHkiLCJzdGF0dXMiLCJmb3JtYXRVcGRhdGVNZXNzYWdlIiwiaXNBcnJheSIsInRvTG93ZXJDYXNlIiwicHJvY2Vzc1N0cmVhbWluZ1Jlc3BvbnNlIiwib25DaHVuayIsImRlY29kZXIiLCJUZXh0RGVjb2RlciIsImN1cnJlbnRNZXNzYWdlIiwiZG9uZSIsInJlYWQiLCJ0ZXh0IiwiZGVjb2RlIiwic3RyZWFtIiwicmVsZWFzZUxvY2siLCJjb25zdHJ1Y3RvciIsImluaXRpYWxEZXRhaWxzIiwiU2V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./managers/ai-chat-manager.ts\n"));

/***/ })

});