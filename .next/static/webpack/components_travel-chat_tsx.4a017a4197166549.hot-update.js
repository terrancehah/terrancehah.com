"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("components_travel-chat_tsx",{

/***/ "./utils/places-utils.ts":
/*!*******************************!*\
  !*** ./utils/places-utils.ts ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchPlaces: function() { return /* binding */ fetchPlaces; },\n/* harmony export */   filterUniquePlaces: function() { return /* binding */ filterUniquePlaces; },\n/* harmony export */   formatPrimaryType: function() { return /* binding */ formatPrimaryType; },\n/* harmony export */   getPlaceTypeDisplayName: function() { return /* binding */ getPlaceTypeDisplayName; },\n/* harmony export */   getPlaceTypesFromPreferences: function() { return /* binding */ getPlaceTypesFromPreferences; },\n/* harmony export */   preferenceToPlaceTypes: function() { return /* binding */ preferenceToPlaceTypes; },\n/* harmony export */   resetReturnedPlaces: function() { return /* binding */ resetReturnedPlaces; },\n/* harmony export */   searchMultiplePlacesByText: function() { return /* binding */ searchMultiplePlacesByText; },\n/* harmony export */   searchPlaceByText: function() { return /* binding */ searchPlaceByText; }\n/* harmony export */ });\n/* harmony import */ var _managers_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../managers/types */ \"./managers/types.ts\");\n// Place related interfaces\n\n// Updated preference to place types mapping based on travel-rizz.html\nconst preferenceToPlaceTypes = {\n    [_managers_types__WEBPACK_IMPORTED_MODULE_0__.TravelPreference.Culture]: [\n        \"museum\",\n        \"cultural_center\",\n        \"cultural_landmark\",\n        \"historical_landmark\",\n        \"monument\",\n        \"art_gallery\",\n        \"historical_place\"\n    ],\n    [_managers_types__WEBPACK_IMPORTED_MODULE_0__.TravelPreference.Nature]: [\n        \"national_park\",\n        \"state_park\",\n        \"botanical_garden\",\n        \"wildlife_park\",\n        \"garden\",\n        \"hiking_area\",\n        \"wildlife_refuge\"\n    ],\n    [_managers_types__WEBPACK_IMPORTED_MODULE_0__.TravelPreference.Food]: [\n        \"restaurant\",\n        \"fine_dining_restaurant\",\n        \"cafe\",\n        \"food_court\",\n        \"bakery\",\n        \"dessert_shop\",\n        \"bar_and_grill\"\n    ],\n    [_managers_types__WEBPACK_IMPORTED_MODULE_0__.TravelPreference.Relaxation]: [\n        \"spa\",\n        \"wellness_center\",\n        \"shopping_mall\",\n        \"beach\",\n        \"garden\",\n        \"plaza\",\n        \"yoga_studio\"\n    ],\n    [_managers_types__WEBPACK_IMPORTED_MODULE_0__.TravelPreference.Adventure]: [\n        \"adventure_sports_center\",\n        \"amusement_park\",\n        \"hiking_area\",\n        \"sports_complex\",\n        \"water_park\",\n        \"off_roading_area\",\n        \"sports_activity_location\"\n    ],\n    [_managers_types__WEBPACK_IMPORTED_MODULE_0__.TravelPreference.Shopping]: [\n        \"art_gallery\",\n        \"art_studio\",\n        \"performing_arts_theater\",\n        \"auditorium\",\n        \"concert_hall\",\n        \"museum\",\n        \"opera_house\"\n    ]\n};\n// Helper function to get place types based on preferences\nfunction getPlaceTypesFromPreferences(preferences) {\n    try {\n        // Track used types to avoid repeats\n        const usedTypes = new Set();\n        const resultTypes = [];\n        // Process each preference\n        preferences.forEach((pref)=>{\n            var _preferenceToPlaceTypes_pref;\n            const availableTypes = ((_preferenceToPlaceTypes_pref = preferenceToPlaceTypes[pref]) === null || _preferenceToPlaceTypes_pref === void 0 ? void 0 : _preferenceToPlaceTypes_pref.filter((type)=>!usedTypes.has(type))) || [];\n            // Take 2-3 random types from each preference\n            const numTypes = Math.min(Math.floor(Math.random() * 2) + 2, availableTypes.length);\n            const selectedTypes = availableTypes.sort(()=>Math.random() - 0.5).slice(0, numTypes);\n            // Add to results and mark as used\n            selectedTypes.forEach((type)=>{\n                resultTypes.push(type);\n                usedTypes.add(type);\n            });\n        });\n        return resultTypes;\n    } catch (error) {\n        console.error(\"Error getting place types from preferences:\", error);\n        return [\n            \"tourist_attraction\"\n        ]; // Default fallback\n    }\n}\n// Helper function to format primary type\nconst formatPrimaryType = (type)=>{\n    return type.split(\"_\").map((word)=>word.charAt(0).toUpperCase() + word.slice(1)).join(\" \");\n};\n// Helper function to get display name for place type\nconst getPlaceTypeDisplayName = (place)=>{\n    var _place_primaryTypeDisplayName;\n    if (place === null || place === void 0 ? void 0 : (_place_primaryTypeDisplayName = place.primaryTypeDisplayName) === null || _place_primaryTypeDisplayName === void 0 ? void 0 : _place_primaryTypeDisplayName.text) {\n        return place.primaryTypeDisplayName.text;\n    }\n    // Fallback to formatting the primaryType if displayName is not available\n    return place.primaryType ? formatPrimaryType(place.primaryType) : \"Place\";\n};\n// Keep track of returned places\nconst returnedPlaceIds = new Set();\n// Function to reset returned places tracking (call this when starting a new search session)\nfunction resetReturnedPlaces() {\n    returnedPlaceIds.clear();\n}\n// Function to filter out duplicate places\nfunction filterUniquePlaces(places) {\n    if (!places || !Array.isArray(places)) return [];\n    const uniquePlaces = places.filter((place)=>{\n        if (!place.id || returnedPlaceIds.has(place.id)) {\n            return false;\n        }\n        returnedPlaceIds.add(place.id);\n        return true;\n    });\n    return uniquePlaces;\n}\n// Search for a single place by text query\nconst searchPlaceByText = async (searchText, location, destination)=>{\n    try {\n        if (false) {}\n        // Extract city name without country\n        const cityName = destination.split(\",\")[0].trim();\n        const searchQuery = \"\".concat(searchText, \" \").concat(cityName);\n        console.log(\"Searching for:\", searchQuery);\n        const requestBody = {\n            textQuery: searchQuery,\n            locationBias: {\n                circle: {\n                    center: {\n                        latitude: location.latitude,\n                        longitude: location.longitude\n                    },\n                    radius: 20000.0 // 20km radius\n                }\n            }\n        };\n        const headers = new Headers({\n            \"Content-Type\": \"application/json\",\n            \"X-Goog-Api-Key\": \"AIzaSyDvcgBgSprgTRQO_6BWh5EAOPu1vdS6KD4\",\n            \"X-Goog-FieldMask\": \"places.id,places.displayName,places.formattedAddress,places.location,places.primaryType,places.primaryTypeDisplayName,places.photos.name\"\n        });\n        const response = await fetch(\"https://places.googleapis.com/v1/places:searchText\", {\n            method: \"POST\",\n            headers: headers,\n            body: JSON.stringify(requestBody)\n        });\n        if (!response.ok) {\n            const errorData = await response.text();\n            console.error(\"Failed to search place:\", {\n                status: response.status,\n                statusText: response.statusText,\n                error: errorData\n            });\n            return null;\n        }\n        const data = await response.json();\n        // console.log('Places API text search response:', data);\n        if (!data.places || !Array.isArray(data.places) || data.places.length === 0) {\n            console.error(\"No places found for text search:\", searchText);\n            return null;\n        }\n        // Apply unique filter to results\n        const uniquePlaces = filterUniquePlaces(data.places.map((place)=>{\n            var _place_displayName, _place_photos;\n            return {\n                id: place.id,\n                name: place.name,\n                displayName: ((_place_displayName = place.displayName) === null || _place_displayName === void 0 ? void 0 : _place_displayName.text) ? {\n                    text: place.displayName.text,\n                    languageCode: place.displayName.languageCode\n                } : place.displayName,\n                primaryType: place.primaryType || \"place\",\n                photos: ((_place_photos = place.photos) === null || _place_photos === void 0 ? void 0 : _place_photos.map((photo)=>({\n                        name: photo.name,\n                        widthPx: photo.widthPx,\n                        heightPx: photo.heightPx,\n                        authorAttributions: photo.authorAttributions\n                    }))) || [],\n                formattedAddress: place.formattedAddress,\n                location: place.location,\n                primaryTypeDisplayName: place.primaryTypeDisplayName ? {\n                    text: place.primaryTypeDisplayName.text,\n                    languageCode: place.primaryTypeDisplayName.languageCode\n                } : undefined\n            };\n        }));\n        // Return first unique place or null if no unique places found\n        return uniquePlaces.length > 0 ? uniquePlaces[0] : null;\n    } catch (error) {\n        console.error(\"Error searching for place:\", error);\n        return null;\n    }\n};\n// Search for multiple places by text query\nconst searchMultiplePlacesByText = async function(searchText, location) {\n    let maxResults = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 5;\n    try {\n        if (false) {}\n        console.log(\"Executing searchMultiplePlacesByText with params:\", {\n            searchText,\n            location,\n            maxResults\n        });\n        const requestBody = {\n            textQuery: searchText,\n            locationBias: {\n                circle: {\n                    center: {\n                        latitude: location.latitude,\n                        longitude: location.longitude\n                    },\n                    radius: 20000.0 // 20km radius\n                }\n            },\n            maxResultCount: maxResults\n        };\n        const headers = new Headers({\n            \"Content-Type\": \"application/json\",\n            \"X-Goog-Api-Key\": \"AIzaSyDvcgBgSprgTRQO_6BWh5EAOPu1vdS6KD4\",\n            \"X-Goog-FieldMask\": \"places.id,places.displayName,places.formattedAddress,places.location,places.primaryType,places.primaryTypeDisplayName,places.photos.name\"\n        });\n        const response = await fetch(\"https://places.googleapis.com/v1/places:searchText\", {\n            method: \"POST\",\n            headers: headers,\n            body: JSON.stringify(requestBody)\n        });\n        if (!response.ok) {\n            const errorData = await response.text();\n            console.error(\"Failed to search places:\", {\n                status: response.status,\n                statusText: response.statusText,\n                error: errorData\n            });\n            return [];\n        }\n        const data = await response.json();\n        if (!data.places || !Array.isArray(data.places) || data.places.length === 0) {\n            console.log(\"No places found for text search:\", searchText);\n            return [];\n        }\n        return data.places.map((place)=>{\n            var _place_displayName, _place_photos;\n            return {\n                id: place.id,\n                displayName: ((_place_displayName = place.displayName) === null || _place_displayName === void 0 ? void 0 : _place_displayName.text) ? {\n                    text: place.displayName.text,\n                    languageCode: place.displayName.languageCode\n                } : place.displayName,\n                primaryType: place.primaryType || \"place\",\n                photos: ((_place_photos = place.photos) === null || _place_photos === void 0 ? void 0 : _place_photos.map((photo)=>({\n                        name: photo.name\n                    }))) || [],\n                formattedAddress: place.formattedAddress,\n                location: place.location,\n                primaryTypeDisplayName: place.primaryTypeDisplayName ? {\n                    text: place.primaryTypeDisplayName.text,\n                    languageCode: place.primaryTypeDisplayName.languageCode\n                } : undefined\n            };\n        });\n    } catch (error) {\n        console.error(\"Error searching for places:\", error);\n        return [];\n    }\n};\n// Fetch places from Google Places API\nconst fetchPlaces = async function(latitude, longitude, preferences) {\n    let maxResults = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 5, placeTypes = arguments.length > 4 ? arguments[4] : void 0;\n    try {\n        if (false) {}\n        const fromPreferences = !!preferences && preferences.length > 0;\n        const fromPlaceTypes = !!placeTypes && placeTypes.length > 0;\n        if (!fromPreferences && !fromPlaceTypes) {\n            console.error(\"No preferences or place types provided\");\n            return [];\n        }\n        // Use preferences if provided, otherwise use placeTypes, otherwise use defaults\n        let includedTypes = [];\n        if (fromPreferences) {\n            includedTypes = getPlaceTypesFromPreferences(preferences);\n        } else if (fromPlaceTypes) {\n            includedTypes = placeTypes;\n        }\n        console.log(\"Executing fetchplaces with params:\", {\n            latitude,\n            longitude,\n            includedTypes,\n            maxResults,\n            fromPreferences: !!(preferences === null || preferences === void 0 ? void 0 : preferences.length),\n            fromPlaceTypes: !!(placeTypes === null || placeTypes === void 0 ? void 0 : placeTypes.length)\n        });\n        // First try nearby search\n        try {\n            const requestBody = {\n                includedTypes,\n                maxResultCount: maxResults,\n                locationRestriction: {\n                    circle: {\n                        center: {\n                            latitude: latitude,\n                            longitude: longitude\n                        },\n                        radius: 20000.0 // 20km radius\n                    }\n                }\n            };\n            const headers = new Headers({\n                \"Content-Type\": \"application/json\",\n                \"X-Goog-Api-Key\": \"AIzaSyDvcgBgSprgTRQO_6BWh5EAOPu1vdS6KD4\",\n                \"X-Goog-FieldMask\": \"places.id,places.displayName,places.formattedAddress,places.location,places.primaryType,places.primaryTypeDisplayName,places.photos.name\"\n            });\n            const response = await fetch(\"https://places.googleapis.com/v1/places:searchNearby\", {\n                method: \"POST\",\n                headers: headers,\n                body: JSON.stringify(requestBody)\n            });\n            if (response.ok) {\n                const data = await response.json();\n                if (data.places && Array.isArray(data.places) && data.places.length > 0) {\n                    return data.places.map((place)=>{\n                        var _place_displayName, _place_photos;\n                        return {\n                            id: place.id,\n                            displayName: ((_place_displayName = place.displayName) === null || _place_displayName === void 0 ? void 0 : _place_displayName.text) ? {\n                                text: place.displayName.text,\n                                languageCode: place.displayName.languageCode\n                            } : place.displayName,\n                            primaryType: place.primaryType || \"place\",\n                            photos: ((_place_photos = place.photos) === null || _place_photos === void 0 ? void 0 : _place_photos.map((photo)=>({\n                                    name: photo.name\n                                }))) || [],\n                            formattedAddress: place.formattedAddress,\n                            location: place.location,\n                            primaryTypeDisplayName: place.primaryTypeDisplayName ? {\n                                text: place.primaryTypeDisplayName.text,\n                                languageCode: place.primaryTypeDisplayName.languageCode\n                            } : undefined\n                        };\n                    });\n                }\n            }\n            const errorData = await response.text();\n            console.error(\"Failed to fetch places:\", {\n                status: response.status,\n                statusText: response.statusText,\n                error: errorData\n            });\n        } catch (error) {\n            console.error(\"Error in nearby search:\", error);\n        }\n        // If nearby search fails, try text search as fallback\n        console.log(\"Falling back to text search...\");\n        const searchQuery = fromPlaceTypes ? placeTypes[0] : preferences[0];\n        return await searchMultiplePlacesByText(searchQuery, {\n            latitude,\n            longitude\n        }, maxResults);\n    } catch (error) {\n        console.error(\"Error fetching places:\", error);\n        return [];\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LElBQUk7Z0NBQ3ZDOEMsY0FBY2hELE1BQU1DLHNCQUFzQixDQUFDK0MsWUFBWTs0QkFDM0QsSUFBSU87d0JBQ1I7O2dCQUNKO1lBQ0o7WUFFQSxNQUFNZCxZQUFZLE1BQU1QLFNBQVNoQyxJQUFJO1lBQ3JDWCxRQUFRRCxLQUFLLENBQUMsMkJBQTJCO2dCQUNyQ29ELFFBQVFSLFNBQVNRLE1BQU07Z0JBQ3ZCQyxZQUFZVCxTQUFTUyxVQUFVO2dCQUMvQnJELE9BQU9tRDtZQUNYO1FBQ0osRUFBRSxPQUFPbkQsT0FBTztZQUNaQyxRQUFRRCxLQUFLLENBQUMsMkJBQTJCQTtRQUM3QztRQUVBLHNEQUFzRDtRQUN0REMsUUFBUWdDLEdBQUcsQ0FBQztRQUNaLE1BQU1ELGNBQWN3QyxpQkFBaUJGLFVBQVcsQ0FBQyxFQUFFLEdBQUczRixXQUFZLENBQUMsRUFBRTtRQUNyRSxPQUFPLE1BQU11RiwyQkFBMkJsQyxhQUFhO1lBQUVPO1lBQVVDO1FBQVUsR0FBRzJCO0lBRWxGLEVBQUUsT0FBT25FLE9BQU87UUFDWkMsUUFBUUQsS0FBSyxDQUFDLDBCQUEwQkE7UUFDeEMsT0FBTyxFQUFFO0lBQ2I7QUFDSixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3V0aWxzL3BsYWNlcy11dGlscy50cz81NTVjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFBsYWNlIHJlbGF0ZWQgaW50ZXJmYWNlc1xuZXhwb3J0IGludGVyZmFjZSBQbGFjZSB7XG4gICAgbmFtZTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIGlkOiBzdHJpbmc7XG4gICAgZGlzcGxheU5hbWU6IHtcbiAgICAgICAgdGV4dDogc3RyaW5nO1xuICAgICAgICBsYW5ndWFnZUNvZGU6IHN0cmluZztcbiAgICB9IHwgc3RyaW5nO1xuICAgIGZvcm1hdHRlZEFkZHJlc3M/OiBzdHJpbmc7XG4gICAgbG9jYXRpb24/OiB7XG4gICAgICAgIGxhdGl0dWRlOiBudW1iZXI7XG4gICAgICAgIGxvbmdpdHVkZTogbnVtYmVyO1xuICAgIH07XG4gICAgcHJpbWFyeVR5cGU6IHN0cmluZztcbiAgICBwcmltYXJ5VHlwZURpc3BsYXlOYW1lPzoge1xuICAgICAgICB0ZXh0OiBzdHJpbmc7XG4gICAgICAgIGxhbmd1YWdlQ29kZTogc3RyaW5nO1xuICAgIH07XG4gICAgcGhvdG9zPzogeyBcbiAgICAgICAgbmFtZTogc3RyaW5nO1xuICAgICAgICB3aWR0aFB4PzogbnVtYmVyO1xuICAgICAgICBoZWlnaHRQeD86IG51bWJlcjtcbiAgICAgICAgYXV0aG9yQXR0cmlidXRpb25zPzogQXJyYXk8e1xuICAgICAgICAgICAgZGlzcGxheU5hbWU/OiBzdHJpbmc7XG4gICAgICAgICAgICB1cmk/OiBzdHJpbmc7XG4gICAgICAgICAgICBwaG90b1VyaT86IHN0cmluZztcbiAgICAgICAgfT47XG4gICAgfVtdO1xufVxuXG5pbnRlcmZhY2UgR29vZ2xlUGxhY2VSZXNwb25zZSB7XG4gICAgaWQ6IHN0cmluZztcbiAgICBuYW1lPzogc3RyaW5nO1xuICAgIGRpc3BsYXlOYW1lPzoge1xuICAgICAgICB0ZXh0OiBzdHJpbmc7XG4gICAgICAgIGxhbmd1YWdlQ29kZTogc3RyaW5nO1xuICAgIH07XG4gICAgZm9ybWF0dGVkQWRkcmVzcz86IHN0cmluZztcbiAgICBsb2NhdGlvbj86IHtcbiAgICAgICAgbGF0aXR1ZGU6IG51bWJlcjtcbiAgICAgICAgbG9uZ2l0dWRlOiBudW1iZXI7XG4gICAgfTtcbiAgICBwcmltYXJ5VHlwZT86IHN0cmluZztcbiAgICBwcmltYXJ5VHlwZURpc3BsYXlOYW1lPzoge1xuICAgICAgICB0ZXh0OiBzdHJpbmc7XG4gICAgICAgIGxhbmd1YWdlQ29kZTogc3RyaW5nO1xuICAgIH07XG4gICAgcGhvdG9zPzogQXJyYXk8e1xuICAgICAgICBuYW1lOiBzdHJpbmc7XG4gICAgICAgIHdpZHRoUHg/OiBudW1iZXI7XG4gICAgICAgIGhlaWdodFB4PzogbnVtYmVyO1xuICAgICAgICBhdXRob3JBdHRyaWJ1dGlvbnM/OiBBcnJheTx7XG4gICAgICAgICAgICBkaXNwbGF5TmFtZT86IHN0cmluZztcbiAgICAgICAgICAgIHVyaT86IHN0cmluZztcbiAgICAgICAgICAgIHBob3RvVXJpPzogc3RyaW5nO1xuICAgICAgICB9PjtcbiAgICB9Pjtcbn1cblxuaW1wb3J0IHsgVHJhdmVsUHJlZmVyZW5jZSB9IGZyb20gJy4uL21hbmFnZXJzL3R5cGVzJztcblxuLy8gVXBkYXRlZCBwcmVmZXJlbmNlIHRvIHBsYWNlIHR5cGVzIG1hcHBpbmcgYmFzZWQgb24gdHJhdmVsLXJpenouaHRtbFxuZXhwb3J0IGNvbnN0IHByZWZlcmVuY2VUb1BsYWNlVHlwZXM6IFJlY29yZDxUcmF2ZWxQcmVmZXJlbmNlLCBzdHJpbmdbXT4gPSB7XG4gICAgW1RyYXZlbFByZWZlcmVuY2UuQ3VsdHVyZV06IFtcbiAgICAgICAgJ211c2V1bScsXG4gICAgICAgICdjdWx0dXJhbF9jZW50ZXInLFxuICAgICAgICAnY3VsdHVyYWxfbGFuZG1hcmsnLFxuICAgICAgICAnaGlzdG9yaWNhbF9sYW5kbWFyaycsXG4gICAgICAgICdtb251bWVudCcsXG4gICAgICAgICdhcnRfZ2FsbGVyeScsXG4gICAgICAgICdoaXN0b3JpY2FsX3BsYWNlJ1xuICAgIF0sXG4gICAgW1RyYXZlbFByZWZlcmVuY2UuTmF0dXJlXTogW1xuICAgICAgICAnbmF0aW9uYWxfcGFyaycsXG4gICAgICAgICdzdGF0ZV9wYXJrJyxcbiAgICAgICAgJ2JvdGFuaWNhbF9nYXJkZW4nLFxuICAgICAgICAnd2lsZGxpZmVfcGFyaycsXG4gICAgICAgICdnYXJkZW4nLFxuICAgICAgICAnaGlraW5nX2FyZWEnLFxuICAgICAgICAnd2lsZGxpZmVfcmVmdWdlJ1xuICAgIF0sXG4gICAgW1RyYXZlbFByZWZlcmVuY2UuRm9vZF06IFtcbiAgICAgICAgJ3Jlc3RhdXJhbnQnLFxuICAgICAgICAnZmluZV9kaW5pbmdfcmVzdGF1cmFudCcsXG4gICAgICAgICdjYWZlJyxcbiAgICAgICAgJ2Zvb2RfY291cnQnLFxuICAgICAgICAnYmFrZXJ5JyxcbiAgICAgICAgJ2Rlc3NlcnRfc2hvcCcsXG4gICAgICAgICdiYXJfYW5kX2dyaWxsJ1xuICAgIF0sXG4gICAgW1RyYXZlbFByZWZlcmVuY2UuUmVsYXhhdGlvbl06IFtcbiAgICAgICAgJ3NwYScsXG4gICAgICAgICd3ZWxsbmVzc19jZW50ZXInLFxuICAgICAgICAnc2hvcHBpbmdfbWFsbCcsXG4gICAgICAgICdiZWFjaCcsXG4gICAgICAgICdnYXJkZW4nLFxuICAgICAgICAncGxhemEnLFxuICAgICAgICAneW9nYV9zdHVkaW8nXG4gICAgXSxcbiAgICBbVHJhdmVsUHJlZmVyZW5jZS5BZHZlbnR1cmVdOiBbXG4gICAgICAgICdhZHZlbnR1cmVfc3BvcnRzX2NlbnRlcicsXG4gICAgICAgICdhbXVzZW1lbnRfcGFyaycsXG4gICAgICAgICdoaWtpbmdfYXJlYScsXG4gICAgICAgICdzcG9ydHNfY29tcGxleCcsXG4gICAgICAgICd3YXRlcl9wYXJrJyxcbiAgICAgICAgJ29mZl9yb2FkaW5nX2FyZWEnLFxuICAgICAgICAnc3BvcnRzX2FjdGl2aXR5X2xvY2F0aW9uJ1xuICAgIF0sXG4gICAgW1RyYXZlbFByZWZlcmVuY2UuU2hvcHBpbmddOiBbIC8vIEFydHMgJiBNdXNldW1cbiAgICAgICAgJ2FydF9nYWxsZXJ5JyxcbiAgICAgICAgJ2FydF9zdHVkaW8nLFxuICAgICAgICAncGVyZm9ybWluZ19hcnRzX3RoZWF0ZXInLFxuICAgICAgICAnYXVkaXRvcml1bScsXG4gICAgICAgICdjb25jZXJ0X2hhbGwnLFxuICAgICAgICAnbXVzZXVtJyxcbiAgICAgICAgJ29wZXJhX2hvdXNlJ1xuICAgIF1cbn07XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgcGxhY2UgdHlwZXMgYmFzZWQgb24gcHJlZmVyZW5jZXNcbmV4cG9ydCBmdW5jdGlvbiBnZXRQbGFjZVR5cGVzRnJvbVByZWZlcmVuY2VzKHByZWZlcmVuY2VzOiBUcmF2ZWxQcmVmZXJlbmNlW10pOiBzdHJpbmdbXSB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gVHJhY2sgdXNlZCB0eXBlcyB0byBhdm9pZCByZXBlYXRzXG4gICAgICAgIGNvbnN0IHVzZWRUeXBlcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgICAgICBjb25zdCByZXN1bHRUeXBlczogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgXG4gICAgICAgIC8vIFByb2Nlc3MgZWFjaCBwcmVmZXJlbmNlXG4gICAgICAgIHByZWZlcmVuY2VzLmZvckVhY2gocHJlZiA9PiB7XG4gICAgICAgICAgICBjb25zdCBhdmFpbGFibGVUeXBlcyA9IHByZWZlcmVuY2VUb1BsYWNlVHlwZXNbcHJlZl0/LmZpbHRlcihcbiAgICAgICAgICAgICAgICB0eXBlID0+ICF1c2VkVHlwZXMuaGFzKHR5cGUpXG4gICAgICAgICAgICApIHx8IFtdO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBUYWtlIDItMyByYW5kb20gdHlwZXMgZnJvbSBlYWNoIHByZWZlcmVuY2VcbiAgICAgICAgICAgIGNvbnN0IG51bVR5cGVzID0gTWF0aC5taW4oTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMikgKyAyLCBhdmFpbGFibGVUeXBlcy5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRUeXBlcyA9IGF2YWlsYWJsZVR5cGVzXG4gICAgICAgICAgICAgICAgLnNvcnQoKCkgPT4gTWF0aC5yYW5kb20oKSAtIDAuNSlcbiAgICAgICAgICAgICAgICAuc2xpY2UoMCwgbnVtVHlwZXMpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQWRkIHRvIHJlc3VsdHMgYW5kIG1hcmsgYXMgdXNlZFxuICAgICAgICAgICAgc2VsZWN0ZWRUeXBlcy5mb3JFYWNoKHR5cGUgPT4ge1xuICAgICAgICAgICAgICAgIHJlc3VsdFR5cGVzLnB1c2godHlwZSk7XG4gICAgICAgICAgICAgICAgdXNlZFR5cGVzLmFkZCh0eXBlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0VHlwZXM7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBwbGFjZSB0eXBlcyBmcm9tIHByZWZlcmVuY2VzOicsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIFsndG91cmlzdF9hdHRyYWN0aW9uJ107IC8vIERlZmF1bHQgZmFsbGJhY2tcbiAgICB9XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBmb3JtYXQgcHJpbWFyeSB0eXBlXG5leHBvcnQgY29uc3QgZm9ybWF0UHJpbWFyeVR5cGUgPSAodHlwZTogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgICByZXR1cm4gdHlwZS5zcGxpdCgnXycpXG4gICAgICAgIC5tYXAod29yZCA9PiB3b3JkLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgd29yZC5zbGljZSgxKSlcbiAgICAgICAgLmpvaW4oJyAnKTtcbn07XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgZGlzcGxheSBuYW1lIGZvciBwbGFjZSB0eXBlXG5leHBvcnQgY29uc3QgZ2V0UGxhY2VUeXBlRGlzcGxheU5hbWUgPSAocGxhY2U6IGFueSk6IHN0cmluZyA9PiB7XG4gICAgaWYgKHBsYWNlPy5wcmltYXJ5VHlwZURpc3BsYXlOYW1lPy50ZXh0KSB7XG4gICAgICAgIHJldHVybiBwbGFjZS5wcmltYXJ5VHlwZURpc3BsYXlOYW1lLnRleHQ7XG4gICAgfVxuICAgIC8vIEZhbGxiYWNrIHRvIGZvcm1hdHRpbmcgdGhlIHByaW1hcnlUeXBlIGlmIGRpc3BsYXlOYW1lIGlzIG5vdCBhdmFpbGFibGVcbiAgICByZXR1cm4gcGxhY2UucHJpbWFyeVR5cGUgPyBmb3JtYXRQcmltYXJ5VHlwZShwbGFjZS5wcmltYXJ5VHlwZSkgOiAnUGxhY2UnO1xufTtcblxuLy8gS2VlcCB0cmFjayBvZiByZXR1cm5lZCBwbGFjZXNcbmNvbnN0IHJldHVybmVkUGxhY2VJZHMgPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuLy8gRnVuY3Rpb24gdG8gcmVzZXQgcmV0dXJuZWQgcGxhY2VzIHRyYWNraW5nIChjYWxsIHRoaXMgd2hlbiBzdGFydGluZyBhIG5ldyBzZWFyY2ggc2Vzc2lvbilcbmV4cG9ydCBmdW5jdGlvbiByZXNldFJldHVybmVkUGxhY2VzKCk6IHZvaWQge1xuICAgIHJldHVybmVkUGxhY2VJZHMuY2xlYXIoKTtcbn1cblxuLy8gRnVuY3Rpb24gdG8gZmlsdGVyIG91dCBkdXBsaWNhdGUgcGxhY2VzXG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyVW5pcXVlUGxhY2VzKHBsYWNlczogUGxhY2VbXSk6IFBsYWNlW10ge1xuICAgIGlmICghcGxhY2VzIHx8ICFBcnJheS5pc0FycmF5KHBsYWNlcykpIHJldHVybiBbXTtcblxuICAgIGNvbnN0IHVuaXF1ZVBsYWNlcyA9IHBsYWNlcy5maWx0ZXIocGxhY2UgPT4ge1xuICAgICAgICBpZiAoIXBsYWNlLmlkIHx8IHJldHVybmVkUGxhY2VJZHMuaGFzKHBsYWNlLmlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybmVkUGxhY2VJZHMuYWRkKHBsYWNlLmlkKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdW5pcXVlUGxhY2VzO1xufVxuXG4vLyBTZWFyY2ggZm9yIGEgc2luZ2xlIHBsYWNlIGJ5IHRleHQgcXVlcnlcbmV4cG9ydCBjb25zdCBzZWFyY2hQbGFjZUJ5VGV4dCA9IGFzeW5jIChcbiAgICBzZWFyY2hUZXh0OiBzdHJpbmcsXG4gICAgbG9jYXRpb246IHsgbGF0aXR1ZGU6IG51bWJlcjsgbG9uZ2l0dWRlOiBudW1iZXIgfSxcbiAgICBkZXN0aW5hdGlvbjogc3RyaW5nXG4pOiBQcm9taXNlPFBsYWNlIHwgbnVsbD4gPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICghcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfR09PR0xFX01BUFNfQVBJX0tFWSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignR29vZ2xlIE1hcHMgQVBJIGtleSBpcyBtaXNzaW5nJyk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEV4dHJhY3QgY2l0eSBuYW1lIHdpdGhvdXQgY291bnRyeVxuICAgICAgICBjb25zdCBjaXR5TmFtZSA9IGRlc3RpbmF0aW9uLnNwbGl0KCcsJylbMF0udHJpbSgpO1xuXG4gICAgICAgIGNvbnN0IHNlYXJjaFF1ZXJ5ID0gYCR7c2VhcmNoVGV4dH0gJHtjaXR5TmFtZX1gO1xuICAgICAgICBjb25zb2xlLmxvZygnU2VhcmNoaW5nIGZvcjonLCBzZWFyY2hRdWVyeSk7XG5cbiAgICAgICAgY29uc3QgcmVxdWVzdEJvZHkgPSB7XG4gICAgICAgICAgICB0ZXh0UXVlcnk6IHNlYXJjaFF1ZXJ5LFxuICAgICAgICAgICAgbG9jYXRpb25CaWFzOiB7XG4gICAgICAgICAgICAgICAgY2lyY2xlOiB7XG4gICAgICAgICAgICAgICAgICAgIGNlbnRlcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGF0aXR1ZGU6IGxvY2F0aW9uLmxhdGl0dWRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9uZ2l0dWRlOiBsb2NhdGlvbi5sb25naXR1ZGVcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiAyMDAwMC4wIC8vIDIwa20gcmFkaXVzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyh7XG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgJ1gtR29vZy1BcGktS2V5JzogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfR09PR0xFX01BUFNfQVBJX0tFWSxcbiAgICAgICAgICAgICdYLUdvb2ctRmllbGRNYXNrJzogJ3BsYWNlcy5pZCxwbGFjZXMuZGlzcGxheU5hbWUscGxhY2VzLmZvcm1hdHRlZEFkZHJlc3MscGxhY2VzLmxvY2F0aW9uLHBsYWNlcy5wcmltYXJ5VHlwZSxwbGFjZXMucHJpbWFyeVR5cGVEaXNwbGF5TmFtZSxwbGFjZXMucGhvdG9zLm5hbWUnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJ2h0dHBzOi8vcGxhY2VzLmdvb2dsZWFwaXMuY29tL3YxL3BsYWNlczpzZWFyY2hUZXh0Jywge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocmVxdWVzdEJvZHkpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBzZWFyY2ggcGxhY2U6Jywge1xuICAgICAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yRGF0YVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdQbGFjZXMgQVBJIHRleHQgc2VhcmNoIHJlc3BvbnNlOicsIGRhdGEpO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFkYXRhLnBsYWNlcyB8fCAhQXJyYXkuaXNBcnJheShkYXRhLnBsYWNlcykgfHwgZGF0YS5wbGFjZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdObyBwbGFjZXMgZm91bmQgZm9yIHRleHQgc2VhcmNoOicsIHNlYXJjaFRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBcHBseSB1bmlxdWUgZmlsdGVyIHRvIHJlc3VsdHNcbiAgICAgICAgY29uc3QgdW5pcXVlUGxhY2VzID0gZmlsdGVyVW5pcXVlUGxhY2VzKGRhdGEucGxhY2VzLm1hcCgocGxhY2U6IEdvb2dsZVBsYWNlUmVzcG9uc2UpID0+ICh7XG4gICAgICAgICAgICBpZDogcGxhY2UuaWQsXG4gICAgICAgICAgICBuYW1lOiBwbGFjZS5uYW1lLFxuICAgICAgICAgICAgZGlzcGxheU5hbWU6IHBsYWNlLmRpc3BsYXlOYW1lPy50ZXh0ID8ge1xuICAgICAgICAgICAgICAgIHRleHQ6IHBsYWNlLmRpc3BsYXlOYW1lLnRleHQsXG4gICAgICAgICAgICAgICAgbGFuZ3VhZ2VDb2RlOiBwbGFjZS5kaXNwbGF5TmFtZS5sYW5ndWFnZUNvZGVcbiAgICAgICAgICAgIH0gOiBwbGFjZS5kaXNwbGF5TmFtZSxcbiAgICAgICAgICAgIHByaW1hcnlUeXBlOiBwbGFjZS5wcmltYXJ5VHlwZSB8fCAncGxhY2UnLFxuICAgICAgICAgICAgcGhvdG9zOiBwbGFjZS5waG90b3M/Lm1hcChwaG90byA9PiAoeyBcbiAgICAgICAgICAgICAgICBuYW1lOiBwaG90by5uYW1lLFxuICAgICAgICAgICAgICAgIHdpZHRoUHg6IHBob3RvLndpZHRoUHgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0UHg6IHBob3RvLmhlaWdodFB4LFxuICAgICAgICAgICAgICAgIGF1dGhvckF0dHJpYnV0aW9uczogcGhvdG8uYXV0aG9yQXR0cmlidXRpb25zXG4gICAgICAgICAgICB9KSkgfHwgW10sXG4gICAgICAgICAgICBmb3JtYXR0ZWRBZGRyZXNzOiBwbGFjZS5mb3JtYXR0ZWRBZGRyZXNzLFxuICAgICAgICAgICAgbG9jYXRpb246IHBsYWNlLmxvY2F0aW9uLFxuICAgICAgICAgICAgcHJpbWFyeVR5cGVEaXNwbGF5TmFtZTogcGxhY2UucHJpbWFyeVR5cGVEaXNwbGF5TmFtZSA/IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBwbGFjZS5wcmltYXJ5VHlwZURpc3BsYXlOYW1lLnRleHQsXG4gICAgICAgICAgICAgICAgbGFuZ3VhZ2VDb2RlOiBwbGFjZS5wcmltYXJ5VHlwZURpc3BsYXlOYW1lLmxhbmd1YWdlQ29kZVxuICAgICAgICAgICAgfSA6IHVuZGVmaW5lZFxuICAgICAgICB9KSkpO1xuXG4gICAgICAgIC8vIFJldHVybiBmaXJzdCB1bmlxdWUgcGxhY2Ugb3IgbnVsbCBpZiBubyB1bmlxdWUgcGxhY2VzIGZvdW5kXG4gICAgICAgIHJldHVybiB1bmlxdWVQbGFjZXMubGVuZ3RoID4gMCA/IHVuaXF1ZVBsYWNlc1swXSA6IG51bGw7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igc2VhcmNoaW5nIGZvciBwbGFjZTonLCBlcnJvcik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5cbi8vIFNlYXJjaCBmb3IgbXVsdGlwbGUgcGxhY2VzIGJ5IHRleHQgcXVlcnlcbmV4cG9ydCBjb25zdCBzZWFyY2hNdWx0aXBsZVBsYWNlc0J5VGV4dCA9IGFzeW5jIChcbiAgICBzZWFyY2hUZXh0OiBzdHJpbmcsXG4gICAgbG9jYXRpb246IHsgbGF0aXR1ZGU6IG51bWJlcjsgbG9uZ2l0dWRlOiBudW1iZXIgfSxcbiAgICBtYXhSZXN1bHRzOiBudW1iZXIgPSA1XG4pOiBQcm9taXNlPFBsYWNlW10+ID0+IHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoIXByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0dPT0dMRV9NQVBTX0FQSV9LRVkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0dvb2dsZSBNYXBzIEFQSSBrZXkgaXMgbWlzc2luZycpO1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2coJ0V4ZWN1dGluZyBzZWFyY2hNdWx0aXBsZVBsYWNlc0J5VGV4dCB3aXRoIHBhcmFtczonLCB7XG4gICAgICAgICAgICBzZWFyY2hUZXh0LFxuICAgICAgICAgICAgbG9jYXRpb24sXG4gICAgICAgICAgICBtYXhSZXN1bHRzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlcXVlc3RCb2R5ID0ge1xuICAgICAgICAgICAgdGV4dFF1ZXJ5OiBzZWFyY2hUZXh0LFxuICAgICAgICAgICAgbG9jYXRpb25CaWFzOiB7XG4gICAgICAgICAgICAgICAgY2lyY2xlOiB7XG4gICAgICAgICAgICAgICAgICAgIGNlbnRlcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGF0aXR1ZGU6IGxvY2F0aW9uLmxhdGl0dWRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9uZ2l0dWRlOiBsb2NhdGlvbi5sb25naXR1ZGVcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiAyMDAwMC4wIC8vIDIwa20gcmFkaXVzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1heFJlc3VsdENvdW50OiBtYXhSZXN1bHRzXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAnWC1Hb29nLUFwaS1LZXknOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19HT09HTEVfTUFQU19BUElfS0VZLFxuICAgICAgICAgICAgJ1gtR29vZy1GaWVsZE1hc2snOiAncGxhY2VzLmlkLHBsYWNlcy5kaXNwbGF5TmFtZSxwbGFjZXMuZm9ybWF0dGVkQWRkcmVzcyxwbGFjZXMubG9jYXRpb24scGxhY2VzLnByaW1hcnlUeXBlLHBsYWNlcy5wcmltYXJ5VHlwZURpc3BsYXlOYW1lLHBsYWNlcy5waG90b3MubmFtZSdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnaHR0cHM6Ly9wbGFjZXMuZ29vZ2xlYXBpcy5jb20vdjEvcGxhY2VzOnNlYXJjaFRleHQnLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0Qm9keSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHNlYXJjaCBwbGFjZXM6Jywge1xuICAgICAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yRGF0YVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFkYXRhLnBsYWNlcyB8fCAhQXJyYXkuaXNBcnJheShkYXRhLnBsYWNlcykgfHwgZGF0YS5wbGFjZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnTm8gcGxhY2VzIGZvdW5kIGZvciB0ZXh0IHNlYXJjaDonLCBzZWFyY2hUZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRhLnBsYWNlcy5tYXAoKHBsYWNlOiBhbnkpID0+ICh7XG4gICAgICAgICAgICBpZDogcGxhY2UuaWQsXG4gICAgICAgICAgICBkaXNwbGF5TmFtZTogcGxhY2UuZGlzcGxheU5hbWU/LnRleHQgPyB7XG4gICAgICAgICAgICAgICAgdGV4dDogcGxhY2UuZGlzcGxheU5hbWUudGV4dCxcbiAgICAgICAgICAgICAgICBsYW5ndWFnZUNvZGU6IHBsYWNlLmRpc3BsYXlOYW1lLmxhbmd1YWdlQ29kZVxuICAgICAgICAgICAgfSA6IHBsYWNlLmRpc3BsYXlOYW1lLFxuICAgICAgICAgICAgcHJpbWFyeVR5cGU6IHBsYWNlLnByaW1hcnlUeXBlIHx8ICdwbGFjZScsXG4gICAgICAgICAgICBwaG90b3M6IHBsYWNlLnBob3Rvcz8ubWFwKChwaG90bzogYW55KSA9PiAoeyBcbiAgICAgICAgICAgICAgICBuYW1lOiBwaG90by5uYW1lXG4gICAgICAgICAgICB9KSkgfHwgW10sXG4gICAgICAgICAgICBmb3JtYXR0ZWRBZGRyZXNzOiBwbGFjZS5mb3JtYXR0ZWRBZGRyZXNzLFxuICAgICAgICAgICAgbG9jYXRpb246IHBsYWNlLmxvY2F0aW9uLFxuICAgICAgICAgICAgcHJpbWFyeVR5cGVEaXNwbGF5TmFtZTogcGxhY2UucHJpbWFyeVR5cGVEaXNwbGF5TmFtZSA/IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBwbGFjZS5wcmltYXJ5VHlwZURpc3BsYXlOYW1lLnRleHQsXG4gICAgICAgICAgICAgICAgbGFuZ3VhZ2VDb2RlOiBwbGFjZS5wcmltYXJ5VHlwZURpc3BsYXlOYW1lLmxhbmd1YWdlQ29kZVxuICAgICAgICAgICAgfSA6IHVuZGVmaW5lZFxuICAgICAgICB9KSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igc2VhcmNoaW5nIGZvciBwbGFjZXM6JywgZXJyb3IpO1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxufTtcblxuLy8gRmV0Y2ggcGxhY2VzIGZyb20gR29vZ2xlIFBsYWNlcyBBUElcbmV4cG9ydCBjb25zdCBmZXRjaFBsYWNlcyA9IGFzeW5jIChcbiAgICBsYXRpdHVkZTogbnVtYmVyLFxuICAgIGxvbmdpdHVkZTogbnVtYmVyLFxuICAgIHByZWZlcmVuY2VzPzogVHJhdmVsUHJlZmVyZW5jZVtdLFxuICAgIG1heFJlc3VsdHM6IG51bWJlciA9IDUsXG4gICAgcGxhY2VUeXBlcz86IHN0cmluZ1tdXG4pOiBQcm9taXNlPFBsYWNlW10+ID0+IHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoIXByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0dPT0dMRV9NQVBTX0FQSV9LRVkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0dvb2dsZSBNYXBzIEFQSSBrZXkgaXMgbWlzc2luZycpO1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZnJvbVByZWZlcmVuY2VzID0gISFwcmVmZXJlbmNlcyAmJiBwcmVmZXJlbmNlcy5sZW5ndGggPiAwO1xuICAgICAgICBjb25zdCBmcm9tUGxhY2VUeXBlcyA9ICEhcGxhY2VUeXBlcyAmJiBwbGFjZVR5cGVzLmxlbmd0aCA+IDA7XG4gICAgICAgIFxuICAgICAgICBpZiAoIWZyb21QcmVmZXJlbmNlcyAmJiAhZnJvbVBsYWNlVHlwZXMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ05vIHByZWZlcmVuY2VzIG9yIHBsYWNlIHR5cGVzIHByb3ZpZGVkJyk7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVc2UgcHJlZmVyZW5jZXMgaWYgcHJvdmlkZWQsIG90aGVyd2lzZSB1c2UgcGxhY2VUeXBlcywgb3RoZXJ3aXNlIHVzZSBkZWZhdWx0c1xuICAgICAgICBsZXQgaW5jbHVkZWRUeXBlczogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgaWYgKGZyb21QcmVmZXJlbmNlcykge1xuICAgICAgICAgICAgaW5jbHVkZWRUeXBlcyA9IGdldFBsYWNlVHlwZXNGcm9tUHJlZmVyZW5jZXMocHJlZmVyZW5jZXMhKTtcbiAgICAgICAgfSBlbHNlIGlmIChmcm9tUGxhY2VUeXBlcykge1xuICAgICAgICAgICAgaW5jbHVkZWRUeXBlcyA9IHBsYWNlVHlwZXMhO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2coJ0V4ZWN1dGluZyBmZXRjaHBsYWNlcyB3aXRoIHBhcmFtczonLCB7XG4gICAgICAgICAgICBsYXRpdHVkZSxcbiAgICAgICAgICAgIGxvbmdpdHVkZSxcbiAgICAgICAgICAgIGluY2x1ZGVkVHlwZXMsXG4gICAgICAgICAgICBtYXhSZXN1bHRzLFxuICAgICAgICAgICAgZnJvbVByZWZlcmVuY2VzOiAhIXByZWZlcmVuY2VzPy5sZW5ndGgsXG4gICAgICAgICAgICBmcm9tUGxhY2VUeXBlczogISFwbGFjZVR5cGVzPy5sZW5ndGhcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gRmlyc3QgdHJ5IG5lYXJieSBzZWFyY2hcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RCb2R5ID0ge1xuICAgICAgICAgICAgICAgIGluY2x1ZGVkVHlwZXMsXG4gICAgICAgICAgICAgICAgbWF4UmVzdWx0Q291bnQ6IG1heFJlc3VsdHMsXG4gICAgICAgICAgICAgICAgbG9jYXRpb25SZXN0cmljdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICBjaXJjbGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRlcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhdGl0dWRlOiBsYXRpdHVkZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb25naXR1ZGU6IGxvbmdpdHVkZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhZGl1czogMjAwMDAuMCAvLyAyMGttIHJhZGl1c1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgICdYLUdvb2ctQXBpLUtleSc6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0dPT0dMRV9NQVBTX0FQSV9LRVksXG4gICAgICAgICAgICAgICAgJ1gtR29vZy1GaWVsZE1hc2snOiAncGxhY2VzLmlkLHBsYWNlcy5kaXNwbGF5TmFtZSxwbGFjZXMuZm9ybWF0dGVkQWRkcmVzcyxwbGFjZXMubG9jYXRpb24scGxhY2VzLnByaW1hcnlUeXBlLHBsYWNlcy5wcmltYXJ5VHlwZURpc3BsYXlOYW1lLHBsYWNlcy5waG90b3MubmFtZSdcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCdodHRwczovL3BsYWNlcy5nb29nbGVhcGlzLmNvbS92MS9wbGFjZXM6c2VhcmNoTmVhcmJ5Jywge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocmVxdWVzdEJvZHkpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5wbGFjZXMgJiYgQXJyYXkuaXNBcnJheShkYXRhLnBsYWNlcykgJiYgZGF0YS5wbGFjZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5wbGFjZXMubWFwKChwbGFjZTogYW55KSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHBsYWNlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheU5hbWU6IHBsYWNlLmRpc3BsYXlOYW1lPy50ZXh0ID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHBsYWNlLmRpc3BsYXlOYW1lLnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFuZ3VhZ2VDb2RlOiBwbGFjZS5kaXNwbGF5TmFtZS5sYW5ndWFnZUNvZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gOiBwbGFjZS5kaXNwbGF5TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnlUeXBlOiBwbGFjZS5wcmltYXJ5VHlwZSB8fCAncGxhY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGhvdG9zOiBwbGFjZS5waG90b3M/Lm1hcCgocGhvdG86IGFueSkgPT4gKHsgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogcGhvdG8ubmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpIHx8IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkQWRkcmVzczogcGxhY2UuZm9ybWF0dGVkQWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBwbGFjZS5sb2NhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnlUeXBlRGlzcGxheU5hbWU6IHBsYWNlLnByaW1hcnlUeXBlRGlzcGxheU5hbWUgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogcGxhY2UucHJpbWFyeVR5cGVEaXNwbGF5TmFtZS50ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlQ29kZTogcGxhY2UucHJpbWFyeVR5cGVEaXNwbGF5TmFtZS5sYW5ndWFnZUNvZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGZldGNoIHBsYWNlczonLCB7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JEYXRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIG5lYXJieSBzZWFyY2g6JywgZXJyb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgbmVhcmJ5IHNlYXJjaCBmYWlscywgdHJ5IHRleHQgc2VhcmNoIGFzIGZhbGxiYWNrXG4gICAgICAgIGNvbnNvbGUubG9nKCdGYWxsaW5nIGJhY2sgdG8gdGV4dCBzZWFyY2guLi4nKTtcbiAgICAgICAgY29uc3Qgc2VhcmNoUXVlcnkgPSBmcm9tUGxhY2VUeXBlcyA/IHBsYWNlVHlwZXMhWzBdIDogcHJlZmVyZW5jZXMhWzBdO1xuICAgICAgICByZXR1cm4gYXdhaXQgc2VhcmNoTXVsdGlwbGVQbGFjZXNCeVRleHQoc2VhcmNoUXVlcnksIHsgbGF0aXR1ZGUsIGxvbmdpdHVkZSB9LCBtYXhSZXN1bHRzKTtcblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHBsYWNlczonLCBlcnJvcik7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59OyJdLCJuYW1lcyI6WyJUcmF2ZWxQcmVmZXJlbmNlIiwicHJlZmVyZW5jZVRvUGxhY2VUeXBlcyIsIkN1bHR1cmUiLCJOYXR1cmUiLCJGb29kIiwiUmVsYXhhdGlvbiIsIkFkdmVudHVyZSIsIlNob3BwaW5nIiwiZ2V0UGxhY2VUeXBlc0Zyb21QcmVmZXJlbmNlcyIsInByZWZlcmVuY2VzIiwidXNlZFR5cGVzIiwiU2V0IiwicmVzdWx0VHlwZXMiLCJmb3JFYWNoIiwicHJlZiIsImF2YWlsYWJsZVR5cGVzIiwiZmlsdGVyIiwidHlwZSIsImhhcyIsIm51bVR5cGVzIiwiTWF0aCIsIm1pbiIsImZsb29yIiwicmFuZG9tIiwibGVuZ3RoIiwic2VsZWN0ZWRUeXBlcyIsInNvcnQiLCJzbGljZSIsInB1c2giLCJhZGQiLCJlcnJvciIsImNvbnNvbGUiLCJmb3JtYXRQcmltYXJ5VHlwZSIsInNwbGl0IiwibWFwIiwid29yZCIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwiam9pbiIsImdldFBsYWNlVHlwZURpc3BsYXlOYW1lIiwicGxhY2UiLCJwcmltYXJ5VHlwZURpc3BsYXlOYW1lIiwidGV4dCIsInByaW1hcnlUeXBlIiwicmV0dXJuZWRQbGFjZUlkcyIsInJlc2V0UmV0dXJuZWRQbGFjZXMiLCJjbGVhciIsImZpbHRlclVuaXF1ZVBsYWNlcyIsInBsYWNlcyIsIkFycmF5IiwiaXNBcnJheSIsInVuaXF1ZVBsYWNlcyIsImlkIiwic2VhcmNoUGxhY2VCeVRleHQiLCJzZWFyY2hUZXh0IiwibG9jYXRpb24iLCJkZXN0aW5hdGlvbiIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19HT09HTEVfTUFQU19BUElfS0VZIiwiY2l0eU5hbWUiLCJ0cmltIiwic2VhcmNoUXVlcnkiLCJsb2ciLCJyZXF1ZXN0Qm9keSIsInRleHRRdWVyeSIsImxvY2F0aW9uQmlhcyIsImNpcmNsZSIsImNlbnRlciIsImxhdGl0dWRlIiwibG9uZ2l0dWRlIiwicmFkaXVzIiwiaGVhZGVycyIsIkhlYWRlcnMiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJvayIsImVycm9yRGF0YSIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJkYXRhIiwianNvbiIsIm5hbWUiLCJkaXNwbGF5TmFtZSIsImxhbmd1YWdlQ29kZSIsInBob3RvcyIsInBob3RvIiwid2lkdGhQeCIsImhlaWdodFB4IiwiYXV0aG9yQXR0cmlidXRpb25zIiwiZm9ybWF0dGVkQWRkcmVzcyIsInVuZGVmaW5lZCIsInNlYXJjaE11bHRpcGxlUGxhY2VzQnlUZXh0IiwibWF4UmVzdWx0cyIsIm1heFJlc3VsdENvdW50IiwiZmV0Y2hQbGFjZXMiLCJwbGFjZVR5cGVzIiwiZnJvbVByZWZlcmVuY2VzIiwiZnJvbVBsYWNlVHlwZXMiLCJpbmNsdWRlZFR5cGVzIiwibG9jYXRpb25SZXN0cmljdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./utils/places-utils.ts\n"));

/***/ })

});