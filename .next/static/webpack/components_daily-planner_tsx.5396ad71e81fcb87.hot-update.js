"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("components_daily-planner_tsx",{

/***/ "./utils/travel-info-utils.ts":
/*!************************************!*\
  !*** ./utils/travel-info-utils.ts ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   travelInfoManager: function() { return /* binding */ travelInfoManager; }\n/* harmony export */ });\nconst CACHE_KEY = \"travel_info_cache\";\nconst CACHE_DURATION = 24 * 60 * 60 * 1000 // 24 hours\n;\nclass TravelInfoManager {\n    getCacheKey(place1, place2) {\n        return \"\".concat(place1.id, \"-\").concat(place2.id);\n    }\n    isCacheValid(info) {\n        return !info.error && Date.now() - info.timestamp < CACHE_DURATION;\n    }\n    async getTravelInfo(place1, place2) {\n        if (!place1.location || !place2.location) {\n            return {\n                duration: \"--\",\n                distance: \"--\",\n                timestamp: Date.now(),\n                error: true\n            };\n        }\n        const key = this.getCacheKey(place1, place2);\n        const cached = this.cache[key];\n        if (cached && this.isCacheValid(cached)) {\n            return cached;\n        }\n        try {\n            const response = await fetch(\"/api/routes\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    origin: {\n                        latitude: place1.location.latitude,\n                        longitude: place1.location.longitude\n                    },\n                    destination: {\n                        latitude: place2.location.latitude,\n                        longitude: place2.location.longitude\n                    }\n                })\n            });\n            if (!response.ok) throw new Error(\"Failed to fetch route\");\n            const data = await response.json();\n            if (data.error) throw new Error(data.error);\n            const info = {\n                duration: \"\".concat(Math.round(parseInt(data.duration) / 60), \" mins\"),\n                distance: \"\".concat((data.distanceMeters / 1000).toFixed(1), \" km\"),\n                timestamp: Date.now()\n            };\n            this.cache[key] = info;\n            this.persist();\n            return info;\n        } catch (error) {\n            console.error(\"[TravelInfoManager] Error:\", error);\n            const errorInfo = {\n                duration: \"--\",\n                distance: \"--\",\n                timestamp: Date.now(),\n                error: true\n            };\n            this.cache[key] = errorInfo;\n            return errorInfo;\n        }\n    }\n    persist() {\n        if (true) {\n            try {\n                localStorage.setItem(CACHE_KEY, JSON.stringify(this.cache));\n            } catch (error) {\n                console.error(\"[TravelInfoManager] Cache save error:\", error);\n            }\n        }\n    }\n    clearCache() {\n        this.cache = {};\n        this.persist();\n    }\n    constructor(){\n        this.cache = {};\n        if (true) {\n            try {\n                const stored = localStorage.getItem(CACHE_KEY);\n                if (stored) {\n                    this.cache = JSON.parse(stored);\n                }\n            } catch (error) {\n                console.error(\"[TravelInfoManager] Cache load error:\", error);\n                this.cache = {};\n            }\n        }\n    }\n}\nconst travelInfoManager = new TravelInfoManager();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi91dGlscy90cmF2ZWwtaW5mby11dGlscy50cyIsIm1hcHBpbmdzIjoiOzs7O0FBYUEsTUFBTUEsWUFBWTtBQUNsQixNQUFNQyxpQkFBaUIsS0FBSyxLQUFLLEtBQUssS0FBSyxXQUFXOztBQUV0RCxNQUFNQztJQWlCSUMsWUFBWUMsTUFBYSxFQUFFQyxNQUFhLEVBQVU7UUFDeEQsT0FBTyxHQUFnQkEsT0FBYkQsT0FBT0UsRUFBRSxFQUFDLEtBQWEsT0FBVkQsT0FBT0MsRUFBRTtJQUNsQztJQUVRQyxhQUFhQyxJQUFnQixFQUFXO1FBQzlDLE9BQU8sQ0FBQ0EsS0FBS0MsS0FBSyxJQUFJQyxLQUFLQyxHQUFHLEtBQUtILEtBQUtJLFNBQVMsR0FBR1g7SUFDdEQ7SUFFQSxNQUFNWSxjQUFjVCxNQUFhLEVBQUVDLE1BQWEsRUFBdUI7UUFDckUsSUFBSSxDQUFDRCxPQUFPVSxRQUFRLElBQUksQ0FBQ1QsT0FBT1MsUUFBUSxFQUFFO1lBQ3hDLE9BQU87Z0JBQUVDLFVBQVU7Z0JBQU1DLFVBQVU7Z0JBQU1KLFdBQVdGLEtBQUtDLEdBQUc7Z0JBQUlGLE9BQU87WUFBSztRQUM5RTtRQUVBLE1BQU1RLE1BQU0sSUFBSSxDQUFDZCxXQUFXLENBQUNDLFFBQVFDO1FBQ3JDLE1BQU1hLFNBQVMsSUFBSSxDQUFDQyxLQUFLLENBQUNGLElBQUk7UUFFOUIsSUFBSUMsVUFBVSxJQUFJLENBQUNYLFlBQVksQ0FBQ1csU0FBUztZQUN2QyxPQUFPQTtRQUNUO1FBRUEsSUFBSTtZQUNGLE1BQU1FLFdBQVcsTUFBTUMsTUFBTSxlQUFlO2dCQUMxQ0MsUUFBUTtnQkFDUkMsU0FBUztvQkFBRSxnQkFBZ0I7Z0JBQW1CO2dCQUM5Q0MsTUFBTUMsS0FBS0MsU0FBUyxDQUFDO29CQUNuQkMsUUFBUTt3QkFDTkMsVUFBVXhCLE9BQU9VLFFBQVEsQ0FBQ2MsUUFBUTt3QkFDbENDLFdBQVd6QixPQUFPVSxRQUFRLENBQUNlLFNBQVM7b0JBQ3RDO29CQUNBQyxhQUFhO3dCQUNYRixVQUFVdkIsT0FBT1MsUUFBUSxDQUFDYyxRQUFRO3dCQUNsQ0MsV0FBV3hCLE9BQU9TLFFBQVEsQ0FBQ2UsU0FBUztvQkFDdEM7Z0JBQ0Y7WUFDRjtZQUVBLElBQUksQ0FBQ1QsU0FBU1csRUFBRSxFQUFFLE1BQU0sSUFBSUMsTUFBTTtZQUVsQyxNQUFNQyxPQUFPLE1BQU1iLFNBQVNjLElBQUk7WUFDaEMsSUFBSUQsS0FBS3hCLEtBQUssRUFBRSxNQUFNLElBQUl1QixNQUFNQyxLQUFLeEIsS0FBSztZQUUxQyxNQUFNRCxPQUFtQjtnQkFDdkJPLFVBQVUsR0FBNEMsT0FBekNvQixLQUFLQyxLQUFLLENBQUNDLFNBQVNKLEtBQUtsQixRQUFRLElBQUksS0FBSTtnQkFDdERDLFVBQVUsR0FBMkMsT0FBeEMsQ0FBQ2lCLEtBQUtLLGNBQWMsR0FBRyxJQUFHLEVBQUdDLE9BQU8sQ0FBQyxJQUFHO2dCQUNyRDNCLFdBQVdGLEtBQUtDLEdBQUc7WUFDckI7WUFFQSxJQUFJLENBQUNRLEtBQUssQ0FBQ0YsSUFBSSxHQUFHVDtZQUNsQixJQUFJLENBQUNnQyxPQUFPO1lBQ1osT0FBT2hDO1FBQ1QsRUFBRSxPQUFPQyxPQUFPO1lBQ2RnQyxRQUFRaEMsS0FBSyxDQUFDLDhCQUE4QkE7WUFDNUMsTUFBTWlDLFlBQVk7Z0JBQUUzQixVQUFVO2dCQUFNQyxVQUFVO2dCQUFNSixXQUFXRixLQUFLQyxHQUFHO2dCQUFJRixPQUFPO1lBQUs7WUFDdkYsSUFBSSxDQUFDVSxLQUFLLENBQUNGLElBQUksR0FBR3lCO1lBQ2xCLE9BQU9BO1FBQ1Q7SUFDRjtJQUVRRixVQUFnQjtRQUN0QixJQUFJLElBQWtCLEVBQWE7WUFDakMsSUFBSTtnQkFDRkcsYUFBYUMsT0FBTyxDQUFDNUMsV0FBV3lCLEtBQUtDLFNBQVMsQ0FBQyxJQUFJLENBQUNQLEtBQUs7WUFDM0QsRUFBRSxPQUFPVixPQUFPO2dCQUNkZ0MsUUFBUWhDLEtBQUssQ0FBQyx5Q0FBeUNBO1lBQ3pEO1FBQ0Y7SUFDRjtJQUVBb0MsYUFBbUI7UUFDakIsSUFBSSxDQUFDMUIsS0FBSyxHQUFHLENBQUM7UUFDZCxJQUFJLENBQUNxQixPQUFPO0lBQ2Q7SUFyRkFNLGFBQWM7YUFGTjNCLFFBQXlCLENBQUM7UUFHaEMsSUFBSSxJQUFrQixFQUFhO1lBQ2pDLElBQUk7Z0JBQ0YsTUFBTTRCLFNBQVNKLGFBQWFLLE9BQU8sQ0FBQ2hEO2dCQUNwQyxJQUFJK0MsUUFBUTtvQkFDVixJQUFJLENBQUM1QixLQUFLLEdBQUdNLEtBQUt3QixLQUFLLENBQUNGO2dCQUMxQjtZQUNGLEVBQUUsT0FBT3RDLE9BQU87Z0JBQ2RnQyxRQUFRaEMsS0FBSyxDQUFDLHlDQUF5Q0E7Z0JBQ3ZELElBQUksQ0FBQ1UsS0FBSyxHQUFHLENBQUM7WUFDaEI7UUFDRjtJQUNGO0FBMEVGO0FBRU8sTUFBTStCLG9CQUFvQixJQUFJaEQsb0JBQW1CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3V0aWxzL3RyYXZlbC1pbmZvLXV0aWxzLnRzP2EyMmMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGxhY2UgfSBmcm9tICcuL3BsYWNlcy11dGlscydcblxuaW50ZXJmYWNlIFRyYXZlbEluZm8ge1xuICBkdXJhdGlvbjogc3RyaW5nXG4gIGRpc3RhbmNlOiBzdHJpbmdcbiAgdGltZXN0YW1wOiBudW1iZXJcbiAgZXJyb3I/OiBib29sZWFuXG59XG5cbmludGVyZmFjZSBUcmF2ZWxJbmZvQ2FjaGUge1xuICBba2V5OiBzdHJpbmddOiBUcmF2ZWxJbmZvXG59XG5cbmNvbnN0IENBQ0hFX0tFWSA9ICd0cmF2ZWxfaW5mb19jYWNoZSdcbmNvbnN0IENBQ0hFX0RVUkFUSU9OID0gMjQgKiA2MCAqIDYwICogMTAwMCAvLyAyNCBob3Vyc1xuXG5jbGFzcyBUcmF2ZWxJbmZvTWFuYWdlciB7XG4gIHByaXZhdGUgY2FjaGU6IFRyYXZlbEluZm9DYWNoZSA9IHt9XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBzdG9yZWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShDQUNIRV9LRVkpXG4gICAgICAgIGlmIChzdG9yZWQpIHtcbiAgICAgICAgICB0aGlzLmNhY2hlID0gSlNPTi5wYXJzZShzdG9yZWQpXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tUcmF2ZWxJbmZvTWFuYWdlcl0gQ2FjaGUgbG9hZCBlcnJvcjonLCBlcnJvcilcbiAgICAgICAgdGhpcy5jYWNoZSA9IHt9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXRDYWNoZUtleShwbGFjZTE6IFBsYWNlLCBwbGFjZTI6IFBsYWNlKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYCR7cGxhY2UxLmlkfS0ke3BsYWNlMi5pZH1gXG4gIH1cblxuICBwcml2YXRlIGlzQ2FjaGVWYWxpZChpbmZvOiBUcmF2ZWxJbmZvKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICFpbmZvLmVycm9yICYmIERhdGUubm93KCkgLSBpbmZvLnRpbWVzdGFtcCA8IENBQ0hFX0RVUkFUSU9OXG4gIH1cblxuICBhc3luYyBnZXRUcmF2ZWxJbmZvKHBsYWNlMTogUGxhY2UsIHBsYWNlMjogUGxhY2UpOiBQcm9taXNlPFRyYXZlbEluZm8+IHtcbiAgICBpZiAoIXBsYWNlMS5sb2NhdGlvbiB8fCAhcGxhY2UyLmxvY2F0aW9uKSB7XG4gICAgICByZXR1cm4geyBkdXJhdGlvbjogJy0tJywgZGlzdGFuY2U6ICctLScsIHRpbWVzdGFtcDogRGF0ZS5ub3coKSwgZXJyb3I6IHRydWUgfVxuICAgIH1cblxuICAgIGNvbnN0IGtleSA9IHRoaXMuZ2V0Q2FjaGVLZXkocGxhY2UxLCBwbGFjZTIpXG4gICAgY29uc3QgY2FjaGVkID0gdGhpcy5jYWNoZVtrZXldXG5cbiAgICBpZiAoY2FjaGVkICYmIHRoaXMuaXNDYWNoZVZhbGlkKGNhY2hlZCkpIHtcbiAgICAgIHJldHVybiBjYWNoZWRcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9yb3V0ZXMnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIG9yaWdpbjoge1xuICAgICAgICAgICAgbGF0aXR1ZGU6IHBsYWNlMS5sb2NhdGlvbi5sYXRpdHVkZSxcbiAgICAgICAgICAgIGxvbmdpdHVkZTogcGxhY2UxLmxvY2F0aW9uLmxvbmdpdHVkZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVzdGluYXRpb246IHtcbiAgICAgICAgICAgIGxhdGl0dWRlOiBwbGFjZTIubG9jYXRpb24ubGF0aXR1ZGUsXG4gICAgICAgICAgICBsb25naXR1ZGU6IHBsYWNlMi5sb2NhdGlvbi5sb25naXR1ZGVcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCByb3V0ZScpXG4gICAgICBcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICAgIGlmIChkYXRhLmVycm9yKSB0aHJvdyBuZXcgRXJyb3IoZGF0YS5lcnJvcilcblxuICAgICAgY29uc3QgaW5mbzogVHJhdmVsSW5mbyA9IHtcbiAgICAgICAgZHVyYXRpb246IGAke01hdGgucm91bmQocGFyc2VJbnQoZGF0YS5kdXJhdGlvbikgLyA2MCl9IG1pbnNgLFxuICAgICAgICBkaXN0YW5jZTogYCR7KGRhdGEuZGlzdGFuY2VNZXRlcnMgLyAxMDAwKS50b0ZpeGVkKDEpfSBrbWAsXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuICAgICAgfVxuXG4gICAgICB0aGlzLmNhY2hlW2tleV0gPSBpbmZvXG4gICAgICB0aGlzLnBlcnNpc3QoKVxuICAgICAgcmV0dXJuIGluZm9cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignW1RyYXZlbEluZm9NYW5hZ2VyXSBFcnJvcjonLCBlcnJvcilcbiAgICAgIGNvbnN0IGVycm9ySW5mbyA9IHsgZHVyYXRpb246ICctLScsIGRpc3RhbmNlOiAnLS0nLCB0aW1lc3RhbXA6IERhdGUubm93KCksIGVycm9yOiB0cnVlIH1cbiAgICAgIHRoaXMuY2FjaGVba2V5XSA9IGVycm9ySW5mb1xuICAgICAgcmV0dXJuIGVycm9ySW5mb1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcGVyc2lzdCgpOiB2b2lkIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKENBQ0hFX0tFWSwgSlNPTi5zdHJpbmdpZnkodGhpcy5jYWNoZSkpXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdbVHJhdmVsSW5mb01hbmFnZXJdIENhY2hlIHNhdmUgZXJyb3I6JywgZXJyb3IpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY2xlYXJDYWNoZSgpOiB2b2lkIHtcbiAgICB0aGlzLmNhY2hlID0ge31cbiAgICB0aGlzLnBlcnNpc3QoKVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCB0cmF2ZWxJbmZvTWFuYWdlciA9IG5ldyBUcmF2ZWxJbmZvTWFuYWdlcigpXG4iXSwibmFtZXMiOlsiQ0FDSEVfS0VZIiwiQ0FDSEVfRFVSQVRJT04iLCJUcmF2ZWxJbmZvTWFuYWdlciIsImdldENhY2hlS2V5IiwicGxhY2UxIiwicGxhY2UyIiwiaWQiLCJpc0NhY2hlVmFsaWQiLCJpbmZvIiwiZXJyb3IiLCJEYXRlIiwibm93IiwidGltZXN0YW1wIiwiZ2V0VHJhdmVsSW5mbyIsImxvY2F0aW9uIiwiZHVyYXRpb24iLCJkaXN0YW5jZSIsImtleSIsImNhY2hlZCIsImNhY2hlIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsIm9yaWdpbiIsImxhdGl0dWRlIiwibG9uZ2l0dWRlIiwiZGVzdGluYXRpb24iLCJvayIsIkVycm9yIiwiZGF0YSIsImpzb24iLCJNYXRoIiwicm91bmQiLCJwYXJzZUludCIsImRpc3RhbmNlTWV0ZXJzIiwidG9GaXhlZCIsInBlcnNpc3QiLCJjb25zb2xlIiwiZXJyb3JJbmZvIiwibG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsImNsZWFyQ2FjaGUiLCJjb25zdHJ1Y3RvciIsInN0b3JlZCIsImdldEl0ZW0iLCJwYXJzZSIsInRyYXZlbEluZm9NYW5hZ2VyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./utils/travel-info-utils.ts\n"));

/***/ })

});