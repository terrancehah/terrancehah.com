"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("components_travel-chat_tsx",{

/***/ "./utils/places-utils.ts":
/*!*******************************!*\
  !*** ./utils/places-utils.ts ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchPlaces: function() { return /* binding */ fetchPlaces; },\n/* harmony export */   filterUniquePlaces: function() { return /* binding */ filterUniquePlaces; },\n/* harmony export */   formatPrimaryType: function() { return /* binding */ formatPrimaryType; },\n/* harmony export */   getDisplayName: function() { return /* binding */ getDisplayName; },\n/* harmony export */   getPlaceTypesFromPreferences: function() { return /* binding */ getPlaceTypesFromPreferences; },\n/* harmony export */   preferenceToPlaceTypes: function() { return /* binding */ preferenceToPlaceTypes; },\n/* harmony export */   savedPlacesManager: function() { return /* binding */ savedPlacesManager; },\n/* harmony export */   searchMultiplePlacesByText: function() { return /* binding */ searchMultiplePlacesByText; },\n/* harmony export */   searchPlaceByText: function() { return /* binding */ searchPlaceByText; },\n/* harmony export */   searchWithStrategy: function() { return /* binding */ searchWithStrategy; }\n/* harmony export */ });\n/* harmony import */ var _managers_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../managers/types */ \"./managers/types.ts\");\n// Place related interfaces\n\n// Updated preference to place types mapping based on travel-rizz.html\nconst preferenceToPlaceTypes = {\n    [_managers_types__WEBPACK_IMPORTED_MODULE_0__.TravelPreference.Culture]: [\n        \"museum\",\n        \"cultural_center\",\n        \"cultural_landmark\",\n        \"historical_landmark\",\n        \"monument\",\n        \"art_gallery\",\n        \"historical_place\"\n    ],\n    [_managers_types__WEBPACK_IMPORTED_MODULE_0__.TravelPreference.Nature]: [\n        \"national_park\",\n        \"state_park\",\n        \"botanical_garden\",\n        \"wildlife_park\",\n        \"garden\",\n        \"hiking_area\",\n        \"wildlife_refuge\"\n    ],\n    [_managers_types__WEBPACK_IMPORTED_MODULE_0__.TravelPreference.Food]: [\n        \"restaurant\",\n        \"fine_dining_restaurant\",\n        \"cafe\",\n        \"food_court\",\n        \"bakery\",\n        \"dessert_shop\",\n        \"bar_and_grill\"\n    ],\n    [_managers_types__WEBPACK_IMPORTED_MODULE_0__.TravelPreference.Relaxation]: [\n        \"spa\",\n        \"wellness_center\",\n        \"shopping_mall\",\n        \"beach\",\n        \"garden\",\n        \"plaza\",\n        \"yoga_studio\"\n    ],\n    [_managers_types__WEBPACK_IMPORTED_MODULE_0__.TravelPreference.Adventure]: [\n        \"adventure_sports_center\",\n        \"amusement_park\",\n        \"hiking_area\",\n        \"sports_complex\",\n        \"water_park\",\n        \"off_roading_area\",\n        \"sports_activity_location\"\n    ],\n    [_managers_types__WEBPACK_IMPORTED_MODULE_0__.TravelPreference.Shopping]: [\n        \"art_gallery\",\n        \"art_studio\",\n        \"performing_arts_theater\",\n        \"auditorium\",\n        \"concert_hall\",\n        \"museum\",\n        \"opera_house\"\n    ]\n};\n// Helper function to get place types based on preferences\nfunction getPlaceTypesFromPreferences(preferences) {\n    try {\n        // Track used types to avoid repeats\n        const usedTypes = new Set();\n        const resultTypes = [];\n        // Process each preference\n        preferences.forEach((pref)=>{\n            var _preferenceToPlaceTypes_pref;\n            const availableTypes = ((_preferenceToPlaceTypes_pref = preferenceToPlaceTypes[pref]) === null || _preferenceToPlaceTypes_pref === void 0 ? void 0 : _preferenceToPlaceTypes_pref.filter((type)=>!usedTypes.has(type))) || [];\n            // Take 2-3 random types from each preference\n            const numTypes = Math.min(Math.floor(Math.random() * 2) + 2, availableTypes.length);\n            const selectedTypes = availableTypes.sort(()=>Math.random() - 0.5).slice(0, numTypes);\n            // Add to results and mark as used\n            selectedTypes.forEach((type)=>{\n                resultTypes.push(type);\n                usedTypes.add(type);\n            });\n        });\n        return resultTypes;\n    } catch (error) {\n        console.error(\"Error getting place types from preferences:\", error);\n        return [\n            \"tourist_attraction\"\n        ]; // Default fallback\n    }\n}\n// Helper function to format primary type\nconst formatPrimaryType = (type)=>{\n    return type.split(\"_\").map((word)=>word.charAt(0).toUpperCase() + word.slice(1)).join(\" \");\n};\n// Helper function to get display name for place type\nconst getDisplayName = (place)=>{\n    var _place_displayName;\n    if (typeof place.displayName === \"string\") {\n        return place.displayName;\n    }\n    return ((_place_displayName = place.displayName) === null || _place_displayName === void 0 ? void 0 : _place_displayName.text) || place.name || \"\";\n};\n// Function to filter out duplicate places\nfunction filterUniquePlaces(places) {\n    if (!places || !Array.isArray(places)) return [];\n    // Get saved places from global state if available\n    const savedPlaces = savedPlacesManager.getPlaces();\n    const savedPlaceIds = new Set(savedPlaces.map((place)=>place.id));\n    const savedPlaceNames = new Set(savedPlaces.map((place)=>typeof place.displayName === \"string\" ? place.displayName.toLowerCase() : place.displayName.text.toLowerCase()));\n    // Filter out places that:\n    // 1. Have same ID as saved place\n    // 2. Have same name as saved place\n    return places.filter((place)=>{\n        if (!place.id) return false;\n        if (savedPlaceIds.has(place.id)) return false;\n        const placeName = typeof place.displayName === \"string\" ? place.displayName.toLowerCase() : place.displayName.text.toLowerCase();\n        if (savedPlaceNames.has(placeName)) return false;\n        return true;\n    });\n}\nconst STORAGE_KEY = \"saved_places\";\n// Initialize from localStorage if available\nfunction initializePlaces() {\n    if (false) {}\n    try {\n        const savedPlaces = localStorage.getItem(STORAGE_KEY);\n        console.log(\"[SavedPlacesManager] Loading from storage:\", savedPlaces);\n        if (savedPlaces) {\n            const parsedPlaces = JSON.parse(savedPlaces);\n            console.log(\"[SavedPlacesManager] Parsed places:\", parsedPlaces);\n            // Handle array format\n            const places = new Map();\n            if (Array.isArray(parsedPlaces)) {\n                parsedPlaces.forEach((place)=>{\n                    if (place === null || place === void 0 ? void 0 : place.id) {\n                        places.set(place.id, place);\n                    }\n                });\n            }\n            console.log(\"[SavedPlacesManager] Initialized with places:\", Array.from(places.values()));\n            return places;\n        }\n    } catch (error) {\n        console.error(\"[SavedPlacesManager] Error loading from storage:\", error);\n    }\n    console.log(\"[SavedPlacesManager] No saved places found, returning empty map\");\n    return new Map();\n}\n// Create the singleton manager\nconst savedPlacesManager = {\n    places: initializePlaces(),\n    addPlace (place) {\n        if (!this.hasPlace(place.id)) {\n            console.log(\"[SavedPlacesManager] Adding place:\", place.id);\n            this.places.set(place.id, place);\n            this._persist();\n            this._notifyChange();\n        }\n    },\n    removePlace (id) {\n        if (this.hasPlace(id)) {\n            console.log(\"[SavedPlacesManager] Removing place:\", id);\n            this.places.delete(id);\n            this._persist();\n            this._notifyChange();\n        }\n    },\n    getPlaces () {\n        return Array.from(this.places.values());\n    },\n    hasPlace (id) {\n        return this.places.has(id);\n    },\n    _persist () {\n        try {\n            const placesArray = Array.from(this.places.values());\n            localStorage.setItem(STORAGE_KEY, JSON.stringify(placesArray));\n            // Update metrics in localStorage\n            const metrics = JSON.parse(localStorage.getItem(\"travel_interaction_metrics\") || \"{}\");\n            metrics.savedPlacesCount = placesArray.length;\n            localStorage.setItem(\"travel_interaction_metrics\", JSON.stringify(metrics));\n            console.log(\"[SavedPlacesManager] Persisted places and metrics:\", {\n                placesCount: placesArray.length,\n                metrics\n            });\n        } catch (error) {\n            console.error(\"[SavedPlacesManager] Error persisting places:\", error);\n        }\n    },\n    _notifyChange () {\n        if (true) {\n            const places = this.getPlaces();\n            window.dispatchEvent(new CustomEvent(\"savedPlacesChanged\", {\n                detail: {\n                    places,\n                    count: places.length\n                }\n            }));\n        }\n    }\n};\n// Initialize window interface for backward compatibility\nif (true) {\n    try {\n        const places = savedPlacesManager.getPlaces();\n        console.log(\"[SavedPlacesManager] Initializing window interface:\", places);\n        window.savedPlaces = places;\n        window.getSavedPlaces = ()=>savedPlacesManager.getPlaces();\n    } catch (error) {\n        console.error(\"[SavedPlacesManager] Error initializing window interface:\", error);\n    }\n}\n// Helper function to handle different search strategies\nasync function searchWithStrategy(searchText, location, cityName) {\n    const headers = {\n        \"Content-Type\": \"application/json\",\n        \"X-Goog-Api-Key\": \"AIzaSyDvcgBgSprgTRQO_6BWh5EAOPu1vdS6KD4\" || 0,\n        \"X-Goog-FieldMask\": \"*\"\n    };\n    // Extract place type from search text (e.g., \"park\", \"museum\", etc.)\n    const typeMatch = searchText.match(/(\\w+)\\s*$/i);\n    const placeType = typeMatch ? typeMatch[1].toLowerCase() : searchText.toLowerCase();\n    // Build search queries based on place type\n    const buildQueries = (type)=>{\n        const baseQueries = [\n            \"\".concat(type, \" in \").concat(cityName),\n            \"\".concat(type, \" near \").concat(cityName),\n            \"popular \".concat(type, \" in \").concat(cityName),\n            \"best \".concat(type, \" in \").concat(cityName),\n            \"top \".concat(type, \" in \").concat(cityName)\n        ];\n    };\n    // Get queries for this place type\n    const queries = buildQueries(placeType);\n    // Try each query in sequence\n    for (const query of queries){\n        console.log(\"[searchWithStrategy] Trying query:\", query);\n        const place = await trySearch(query, headers, location);\n        if (place) {\n            console.log(\"[searchWithStrategy] Found place with query:\", query);\n            return place;\n        }\n    }\n    console.log(\"[searchWithStrategy] No places found with any query strategy\");\n    return null;\n}\n// Helper function to try a single search query\nasync function trySearch(query, headers, location) {\n    try {\n        var _data_places;\n        const response = await fetch(\"https://places.googleapis.com/v1/places:searchText\", {\n            method: \"POST\",\n            headers,\n            body: JSON.stringify({\n                textQuery: query,\n                locationBias: {\n                    circle: {\n                        center: {\n                            latitude: location.latitude,\n                            longitude: location.longitude\n                        },\n                        radius: 20000.0\n                    }\n                }\n            })\n        });\n        if (!response.ok) {\n            console.error(\"[trySearch] Search failed:\", {\n                status: response.status,\n                statusText: response.statusText,\n                query\n            });\n            return null;\n        }\n        const data = await response.json();\n        if (!((_data_places = data.places) === null || _data_places === void 0 ? void 0 : _data_places.length)) {\n            console.log(\"[trySearch] No places found for query:\", query);\n            return null;\n        }\n        // Try each place until we find one that isn't saved\n        for (const place of data.places){\n            var _place_displayName;\n            if (!savedPlacesManager.hasPlace(place.id)) {\n                var _place_displayName1;\n                console.log(\"[trySearch] Found new place:\", {\n                    id: place.id,\n                    name: ((_place_displayName1 = place.displayName) === null || _place_displayName1 === void 0 ? void 0 : _place_displayName1.text) || place.name,\n                    query\n                });\n                return place;\n            }\n            console.log(\"[trySearch] Place already saved, skipping:\", ((_place_displayName = place.displayName) === null || _place_displayName === void 0 ? void 0 : _place_displayName.text) || place.name);\n        }\n        return null;\n    } catch (error) {\n        console.error(\"[trySearch] Error in search:\", error);\n        return null;\n    }\n}\nasync function searchPlaceByText(searchText, location, destination) {\n    let excludeIds = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];\n    console.log(\"[searchPlaceByText] Starting search with:\", {\n        searchText,\n        location,\n        destination,\n        excludeIds,\n        currentSavedPlaces: Array.from(savedPlacesManager.places.values())\n    });\n    try {\n        // Try multiple search strategies\n        const strategies = [\n            \"\".concat(searchText, \" in \").concat(destination),\n            \"\".concat(searchText, \" near \").concat(destination),\n            searchText\n        ];\n        // Keep track of tried places to avoid duplicates\n        const triedPlaces = new Set([\n            ...excludeIds,\n            ...Array.from(savedPlacesManager.places.keys())\n        ]);\n        for (const strategy of strategies){\n            console.log(\"[searchPlaceByText] Trying strategy:\", strategy);\n            const place = await searchWithStrategy(strategy, location, destination);\n            if (!(place === null || place === void 0 ? void 0 : place.id)) {\n                console.log(\"[searchPlaceByText] No place found for strategy:\", strategy);\n                continue;\n            }\n            // Skip if we've already tried this place\n            if (triedPlaces.has(place.id)) {\n                console.log(\"[searchPlaceByText] Place already tried:\", place.id);\n                continue;\n            }\n            // Add to tried places to prevent duplicates\n            triedPlaces.add(place.id);\n            // Transform the response\n            const transformedPlace = transformPlaceResponse(place);\n            if (!transformedPlace) {\n                console.log(\"[searchPlaceByText] Failed to transform place\");\n                continue;\n            }\n            console.log(\"[searchPlaceByText] Found unique place:\", {\n                id: transformedPlace.id,\n                name: transformedPlace.displayName,\n                strategy\n            });\n            return transformedPlace;\n        }\n        console.log(\"[searchPlaceByText] No unique place found after trying all strategies\");\n        return null;\n    } catch (error) {\n        console.error(\"[searchPlaceByText] Error:\", error);\n        return null;\n    }\n}\n// Helper function to transform Google Places API response to our Place type\nfunction transformPlaceResponse(place) {\n    var _place_displayName, _place_photos;\n    if (!place) return null;\n    const displayName = ((_place_displayName = place.displayName) === null || _place_displayName === void 0 ? void 0 : _place_displayName.text) ? {\n        text: place.displayName.text,\n        languageCode: place.displayName.languageCode || \"en\"\n    } : place.name || \"\";\n    return {\n        id: place.id,\n        name: place.name,\n        displayName,\n        primaryType: place.primaryType || \"place\",\n        photos: ((_place_photos = place.photos) === null || _place_photos === void 0 ? void 0 : _place_photos.map((photo)=>({\n                name: photo.name,\n                widthPx: photo.widthPx,\n                heightPx: photo.heightPx,\n                authorAttributions: photo.authorAttributions\n            }))) || [],\n        formattedAddress: place.formattedAddress,\n        location: place.location,\n        primaryTypeDisplayName: place.primaryTypeDisplayName ? {\n            text: place.primaryTypeDisplayName.text,\n            languageCode: place.primaryTypeDisplayName.languageCode || \"en\"\n        } : undefined\n    };\n}\nconst searchMultiplePlacesByText = async function(searchText, location) {\n    let maxResults = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 5;\n    try {\n        if (false) {}\n        console.log(\"Executing searchMultiplePlacesByText with params:\", {\n            searchText,\n            location,\n            maxResults\n        });\n        const requestBody = {\n            textQuery: searchText,\n            locationBias: {\n                circle: {\n                    center: {\n                        latitude: location.latitude,\n                        longitude: location.longitude\n                    },\n                    radius: 20000.0 // 20km radius\n                }\n            },\n            maxResultCount: maxResults\n        };\n        const headers = {\n            \"Content-Type\": \"application/json\",\n            \"X-Goog-Api-Key\": \"AIzaSyDvcgBgSprgTRQO_6BWh5EAOPu1vdS6KD4\",\n            \"X-Goog-FieldMask\": \"places.id,places.displayName,places.formattedAddress,places.location,places.primaryType,places.primaryTypeDisplayName,places.photos.name\"\n        };\n        const response = await fetch(\"https://places.googleapis.com/v1/places:searchText\", {\n            method: \"POST\",\n            headers,\n            body: JSON.stringify(requestBody)\n        });\n        if (!response.ok) {\n            const errorData = await response.text();\n            console.error(\"Failed to search places:\", {\n                status: response.status,\n                statusText: response.statusText,\n                error: errorData\n            });\n            return [];\n        }\n        const data = await response.json();\n        if (!data.places || !Array.isArray(data.places) || data.places.length === 0) {\n            console.log(\"No places found for text search:\", searchText);\n            return [];\n        }\n        return data.places.map((place)=>{\n            var _place_displayName, _place_photos;\n            return {\n                id: place.id,\n                displayName: ((_place_displayName = place.displayName) === null || _place_displayName === void 0 ? void 0 : _place_displayName.text) ? {\n                    text: place.displayName.text,\n                    languageCode: place.displayName.languageCode || \"en\"\n                } : place.displayName,\n                primaryType: place.primaryType || \"place\",\n                photos: ((_place_photos = place.photos) === null || _place_photos === void 0 ? void 0 : _place_photos.map((photo)=>({\n                        name: photo.name\n                    }))) || [],\n                formattedAddress: place.formattedAddress,\n                location: place.location,\n                primaryTypeDisplayName: place.primaryTypeDisplayName ? {\n                    text: place.primaryTypeDisplayName.text,\n                    languageCode: place.primaryTypeDisplayName.languageCode || \"en\"\n                } : undefined\n            };\n        });\n    } catch (error) {\n        console.error(\"Error searching for places:\", error);\n        return [];\n    }\n};\n// Fetch places from Google Places API\nconst fetchPlaces = async function(latitude, longitude, preferences) {\n    let maxResults = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 5, placeTypes = arguments.length > 4 ? arguments[4] : void 0;\n    try {\n        if (false) {}\n        const fromPreferences = !!preferences && preferences.length > 0;\n        const fromPlaceTypes = !!placeTypes && placeTypes.length > 0;\n        if (!fromPreferences && !fromPlaceTypes) {\n            console.error(\"No preferences or place types provided\");\n            return [];\n        }\n        // Use preferences if provided, otherwise use placeTypes, otherwise use defaults\n        let includedTypes = [];\n        if (fromPreferences) {\n            includedTypes = getPlaceTypesFromPreferences(preferences);\n        } else if (fromPlaceTypes) {\n            includedTypes = placeTypes;\n        }\n        console.log(\"Executing fetchplaces with params:\", {\n            latitude,\n            longitude,\n            includedTypes,\n            maxResults,\n            fromPreferences: !!(preferences === null || preferences === void 0 ? void 0 : preferences.length),\n            fromPlaceTypes: !!(placeTypes === null || placeTypes === void 0 ? void 0 : placeTypes.length)\n        });\n        // First try nearby search\n        try {\n            const requestBody = {\n                includedTypes,\n                maxResultCount: maxResults,\n                locationRestriction: {\n                    circle: {\n                        center: {\n                            latitude: latitude,\n                            longitude: longitude\n                        },\n                        radius: 20000.0 // 20km radius\n                    }\n                }\n            };\n            const headers = {\n                \"Content-Type\": \"application/json\",\n                \"X-Goog-Api-Key\": \"AIzaSyDvcgBgSprgTRQO_6BWh5EAOPu1vdS6KD4\",\n                \"X-Goog-FieldMask\": \"places.id,places.displayName,places.formattedAddress,places.location,places.primaryType,places.primaryTypeDisplayName,places.photos.name\"\n            };\n            const response = await fetch(\"https://places.googleapis.com/v1/places:searchNearby\", {\n                method: \"POST\",\n                headers,\n                body: JSON.stringify(requestBody)\n            });\n            if (response.ok) {\n                const data = await response.json();\n                if (data.places && Array.isArray(data.places) && data.places.length > 0) {\n                    return data.places.map((place)=>{\n                        var _place_displayName, _place_photos;\n                        return {\n                            id: place.id,\n                            displayName: ((_place_displayName = place.displayName) === null || _place_displayName === void 0 ? void 0 : _place_displayName.text) ? {\n                                text: place.displayName.text,\n                                languageCode: place.displayName.languageCode || \"en\"\n                            } : place.displayName,\n                            primaryType: place.primaryType || \"place\",\n                            photos: ((_place_photos = place.photos) === null || _place_photos === void 0 ? void 0 : _place_photos.map((photo)=>({\n                                    name: photo.name\n                                }))) || [],\n                            formattedAddress: place.formattedAddress,\n                            location: place.location,\n                            primaryTypeDisplayName: place.primaryTypeDisplayName ? {\n                                text: place.primaryTypeDisplayName.text,\n                                languageCode: place.primaryTypeDisplayName.languageCode || \"en\"\n                            } : undefined\n                        };\n                    });\n                }\n            }\n            const errorData = await response.text();\n            console.error(\"Failed to fetch places:\", {\n                status: response.status,\n                statusText: response.statusText,\n                error: errorData\n            });\n        } catch (error) {\n            console.error(\"Error in nearby search:\", error);\n        }\n        // If nearby search fails, try text search as fallback\n        console.log(\"Falling back to text search...\");\n        const searchQuery = fromPlaceTypes ? placeTypes[0] : preferences[0];\n        return await searchMultiplePlacesByText(searchQuery, {\n            latitude,\n            longitude\n        }, maxResults);\n    } catch (error) {\n        console.error(\"Error fetching places:\", error);\n        return [];\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QywyQkFBMkJBO1FBQzdDO1FBRUEsc0RBQXNEO1FBQ3REQyxRQUFRMkIsR0FBRyxDQUFDO1FBQ1osTUFBTTJGLGNBQWNILGlCQUFpQkYsVUFBVyxDQUFDLEVBQUUsR0FBR3ZJLFdBQVksQ0FBQyxFQUFFO1FBQ3JFLE9BQU8sTUFBTWlJLDJCQUEyQlcsYUFBYTtZQUFFdEM7WUFBVUM7UUFBVSxHQUFHMkI7SUFFbEYsRUFBRSxPQUFPN0csT0FBTztRQUNaQyxRQUFRRCxLQUFLLENBQUMsMEJBQTBCQTtRQUN4QyxPQUFPLEVBQUU7SUFDYjtBQUNKLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vdXRpbHMvcGxhY2VzLXV0aWxzLnRzPzU1NWMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gUGxhY2UgcmVsYXRlZCBpbnRlcmZhY2VzXG5leHBvcnQgaW50ZXJmYWNlIFBsYWNlIHtcbiAgICBuYW1lOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgaWQ6IHN0cmluZztcbiAgICBkaXNwbGF5TmFtZToge1xuICAgICAgICB0ZXh0OiBzdHJpbmc7XG4gICAgICAgIGxhbmd1YWdlQ29kZTogc3RyaW5nO1xuICAgIH0gfCBzdHJpbmc7XG4gICAgZm9ybWF0dGVkQWRkcmVzcz86IHN0cmluZztcbiAgICBsb2NhdGlvbj86IHtcbiAgICAgICAgbGF0aXR1ZGU6IG51bWJlcjtcbiAgICAgICAgbG9uZ2l0dWRlOiBudW1iZXI7XG4gICAgfTtcbiAgICBwcmltYXJ5VHlwZTogc3RyaW5nO1xuICAgIHByaW1hcnlUeXBlRGlzcGxheU5hbWU/OiB7XG4gICAgICAgIHRleHQ6IHN0cmluZztcbiAgICAgICAgbGFuZ3VhZ2VDb2RlOiBzdHJpbmc7XG4gICAgfTtcbiAgICBwaG90b3M/OiB7IFxuICAgICAgICBuYW1lOiBzdHJpbmc7XG4gICAgICAgIHdpZHRoUHg/OiBudW1iZXI7XG4gICAgICAgIGhlaWdodFB4PzogbnVtYmVyO1xuICAgICAgICBhdXRob3JBdHRyaWJ1dGlvbnM/OiBBcnJheTx7XG4gICAgICAgICAgICBkaXNwbGF5TmFtZT86IHN0cmluZztcbiAgICAgICAgICAgIHVyaT86IHN0cmluZztcbiAgICAgICAgICAgIHBob3RvVXJpPzogc3RyaW5nO1xuICAgICAgICB9PjtcbiAgICB9W107XG59XG5cbmludGVyZmFjZSBHb29nbGVQbGFjZVJlc3BvbnNlIHtcbiAgICBpZDogc3RyaW5nO1xuICAgIG5hbWU/OiBzdHJpbmc7XG4gICAgZGlzcGxheU5hbWU/OiB7XG4gICAgICAgIHRleHQ6IHN0cmluZztcbiAgICAgICAgbGFuZ3VhZ2VDb2RlOiBzdHJpbmc7XG4gICAgfTtcbiAgICBmb3JtYXR0ZWRBZGRyZXNzPzogc3RyaW5nO1xuICAgIGxvY2F0aW9uPzoge1xuICAgICAgICBsYXRpdHVkZTogbnVtYmVyO1xuICAgICAgICBsb25naXR1ZGU6IG51bWJlcjtcbiAgICB9O1xuICAgIHByaW1hcnlUeXBlPzogc3RyaW5nO1xuICAgIHByaW1hcnlUeXBlRGlzcGxheU5hbWU/OiB7XG4gICAgICAgIHRleHQ6IHN0cmluZztcbiAgICAgICAgbGFuZ3VhZ2VDb2RlOiBzdHJpbmc7XG4gICAgfTtcbiAgICBwaG90b3M/OiBBcnJheTx7XG4gICAgICAgIG5hbWU6IHN0cmluZztcbiAgICAgICAgd2lkdGhQeD86IG51bWJlcjtcbiAgICAgICAgaGVpZ2h0UHg/OiBudW1iZXI7XG4gICAgICAgIGF1dGhvckF0dHJpYnV0aW9ucz86IEFycmF5PHtcbiAgICAgICAgICAgIGRpc3BsYXlOYW1lPzogc3RyaW5nO1xuICAgICAgICAgICAgdXJpPzogc3RyaW5nO1xuICAgICAgICAgICAgcGhvdG9Vcmk/OiBzdHJpbmc7XG4gICAgICAgIH0+O1xuICAgIH0+O1xufVxuXG5pbXBvcnQgeyBUcmF2ZWxQcmVmZXJlbmNlIH0gZnJvbSAnLi4vbWFuYWdlcnMvdHlwZXMnO1xuXG4vLyBVcGRhdGVkIHByZWZlcmVuY2UgdG8gcGxhY2UgdHlwZXMgbWFwcGluZyBiYXNlZCBvbiB0cmF2ZWwtcml6ei5odG1sXG5leHBvcnQgY29uc3QgcHJlZmVyZW5jZVRvUGxhY2VUeXBlczogUmVjb3JkPFRyYXZlbFByZWZlcmVuY2UsIHN0cmluZ1tdPiA9IHtcbiAgICBbVHJhdmVsUHJlZmVyZW5jZS5DdWx0dXJlXTogW1xuICAgICAgICAnbXVzZXVtJyxcbiAgICAgICAgJ2N1bHR1cmFsX2NlbnRlcicsXG4gICAgICAgICdjdWx0dXJhbF9sYW5kbWFyaycsXG4gICAgICAgICdoaXN0b3JpY2FsX2xhbmRtYXJrJyxcbiAgICAgICAgJ21vbnVtZW50JyxcbiAgICAgICAgJ2FydF9nYWxsZXJ5JyxcbiAgICAgICAgJ2hpc3RvcmljYWxfcGxhY2UnXG4gICAgXSxcbiAgICBbVHJhdmVsUHJlZmVyZW5jZS5OYXR1cmVdOiBbXG4gICAgICAgICduYXRpb25hbF9wYXJrJyxcbiAgICAgICAgJ3N0YXRlX3BhcmsnLFxuICAgICAgICAnYm90YW5pY2FsX2dhcmRlbicsXG4gICAgICAgICd3aWxkbGlmZV9wYXJrJyxcbiAgICAgICAgJ2dhcmRlbicsXG4gICAgICAgICdoaWtpbmdfYXJlYScsXG4gICAgICAgICd3aWxkbGlmZV9yZWZ1Z2UnXG4gICAgXSxcbiAgICBbVHJhdmVsUHJlZmVyZW5jZS5Gb29kXTogW1xuICAgICAgICAncmVzdGF1cmFudCcsXG4gICAgICAgICdmaW5lX2RpbmluZ19yZXN0YXVyYW50JyxcbiAgICAgICAgJ2NhZmUnLFxuICAgICAgICAnZm9vZF9jb3VydCcsXG4gICAgICAgICdiYWtlcnknLFxuICAgICAgICAnZGVzc2VydF9zaG9wJyxcbiAgICAgICAgJ2Jhcl9hbmRfZ3JpbGwnXG4gICAgXSxcbiAgICBbVHJhdmVsUHJlZmVyZW5jZS5SZWxheGF0aW9uXTogW1xuICAgICAgICAnc3BhJyxcbiAgICAgICAgJ3dlbGxuZXNzX2NlbnRlcicsXG4gICAgICAgICdzaG9wcGluZ19tYWxsJyxcbiAgICAgICAgJ2JlYWNoJyxcbiAgICAgICAgJ2dhcmRlbicsXG4gICAgICAgICdwbGF6YScsXG4gICAgICAgICd5b2dhX3N0dWRpbydcbiAgICBdLFxuICAgIFtUcmF2ZWxQcmVmZXJlbmNlLkFkdmVudHVyZV06IFtcbiAgICAgICAgJ2FkdmVudHVyZV9zcG9ydHNfY2VudGVyJyxcbiAgICAgICAgJ2FtdXNlbWVudF9wYXJrJyxcbiAgICAgICAgJ2hpa2luZ19hcmVhJyxcbiAgICAgICAgJ3Nwb3J0c19jb21wbGV4JyxcbiAgICAgICAgJ3dhdGVyX3BhcmsnLFxuICAgICAgICAnb2ZmX3JvYWRpbmdfYXJlYScsXG4gICAgICAgICdzcG9ydHNfYWN0aXZpdHlfbG9jYXRpb24nXG4gICAgXSxcbiAgICBbVHJhdmVsUHJlZmVyZW5jZS5TaG9wcGluZ106IFsgLy8gQXJ0cyAmIE11c2V1bVxuICAgICAgICAnYXJ0X2dhbGxlcnknLFxuICAgICAgICAnYXJ0X3N0dWRpbycsXG4gICAgICAgICdwZXJmb3JtaW5nX2FydHNfdGhlYXRlcicsXG4gICAgICAgICdhdWRpdG9yaXVtJyxcbiAgICAgICAgJ2NvbmNlcnRfaGFsbCcsXG4gICAgICAgICdtdXNldW0nLFxuICAgICAgICAnb3BlcmFfaG91c2UnXG4gICAgXVxufTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGdldCBwbGFjZSB0eXBlcyBiYXNlZCBvbiBwcmVmZXJlbmNlc1xuZXhwb3J0IGZ1bmN0aW9uIGdldFBsYWNlVHlwZXNGcm9tUHJlZmVyZW5jZXMocHJlZmVyZW5jZXM6IFRyYXZlbFByZWZlcmVuY2VbXSk6IHN0cmluZ1tdIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBUcmFjayB1c2VkIHR5cGVzIHRvIGF2b2lkIHJlcGVhdHNcbiAgICAgICAgY29uc3QgdXNlZFR5cGVzID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdFR5cGVzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICBcbiAgICAgICAgLy8gUHJvY2VzcyBlYWNoIHByZWZlcmVuY2VcbiAgICAgICAgcHJlZmVyZW5jZXMuZm9yRWFjaChwcmVmID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGF2YWlsYWJsZVR5cGVzID0gcHJlZmVyZW5jZVRvUGxhY2VUeXBlc1twcmVmXT8uZmlsdGVyKFxuICAgICAgICAgICAgICAgIHR5cGUgPT4gIXVzZWRUeXBlcy5oYXModHlwZSlcbiAgICAgICAgICAgICkgfHwgW107XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFRha2UgMi0zIHJhbmRvbSB0eXBlcyBmcm9tIGVhY2ggcHJlZmVyZW5jZVxuICAgICAgICAgICAgY29uc3QgbnVtVHlwZXMgPSBNYXRoLm1pbihNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyKSArIDIsIGF2YWlsYWJsZVR5cGVzLmxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZFR5cGVzID0gYXZhaWxhYmxlVHlwZXNcbiAgICAgICAgICAgICAgICAuc29ydCgoKSA9PiBNYXRoLnJhbmRvbSgpIC0gMC41KVxuICAgICAgICAgICAgICAgIC5zbGljZSgwLCBudW1UeXBlcyk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBBZGQgdG8gcmVzdWx0cyBhbmQgbWFyayBhcyB1c2VkXG4gICAgICAgICAgICBzZWxlY3RlZFR5cGVzLmZvckVhY2godHlwZSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzdWx0VHlwZXMucHVzaCh0eXBlKTtcbiAgICAgICAgICAgICAgICB1c2VkVHlwZXMuYWRkKHR5cGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHRUeXBlcztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHBsYWNlIHR5cGVzIGZyb20gcHJlZmVyZW5jZXM6JywgZXJyb3IpO1xuICAgICAgICByZXR1cm4gWyd0b3VyaXN0X2F0dHJhY3Rpb24nXTsgLy8gRGVmYXVsdCBmYWxsYmFja1xuICAgIH1cbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGZvcm1hdCBwcmltYXJ5IHR5cGVcbmV4cG9ydCBjb25zdCBmb3JtYXRQcmltYXJ5VHlwZSA9ICh0eXBlOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICAgIHJldHVybiB0eXBlLnNwbGl0KCdfJylcbiAgICAgICAgLm1hcCh3b3JkID0+IHdvcmQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB3b3JkLnNsaWNlKDEpKVxuICAgICAgICAuam9pbignICcpO1xufTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGdldCBkaXNwbGF5IG5hbWUgZm9yIHBsYWNlIHR5cGVcbmV4cG9ydCBjb25zdCBnZXREaXNwbGF5TmFtZSA9IChwbGFjZTogUGxhY2UpOiBzdHJpbmcgPT4ge1xuICAgIGlmICh0eXBlb2YgcGxhY2UuZGlzcGxheU5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBwbGFjZS5kaXNwbGF5TmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIHBsYWNlLmRpc3BsYXlOYW1lPy50ZXh0IHx8IHBsYWNlLm5hbWUgfHwgJyc7XG59O1xuXG4vLyBGdW5jdGlvbiB0byBmaWx0ZXIgb3V0IGR1cGxpY2F0ZSBwbGFjZXNcbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXJVbmlxdWVQbGFjZXMocGxhY2VzOiBQbGFjZVtdKTogUGxhY2VbXSB7XG4gICAgaWYgKCFwbGFjZXMgfHwgIUFycmF5LmlzQXJyYXkocGxhY2VzKSkgcmV0dXJuIFtdO1xuXG4gICAgLy8gR2V0IHNhdmVkIHBsYWNlcyBmcm9tIGdsb2JhbCBzdGF0ZSBpZiBhdmFpbGFibGVcbiAgICBjb25zdCBzYXZlZFBsYWNlcyA9IHNhdmVkUGxhY2VzTWFuYWdlci5nZXRQbGFjZXMoKTtcblxuICAgIGNvbnN0IHNhdmVkUGxhY2VJZHMgPSBuZXcgU2V0KHNhdmVkUGxhY2VzLm1hcChwbGFjZSA9PiBwbGFjZS5pZCkpO1xuICAgIGNvbnN0IHNhdmVkUGxhY2VOYW1lcyA9IG5ldyBTZXQoc2F2ZWRQbGFjZXMubWFwKHBsYWNlID0+IFxuICAgICAgICB0eXBlb2YgcGxhY2UuZGlzcGxheU5hbWUgPT09ICdzdHJpbmcnIFxuICAgICAgICAgICAgPyBwbGFjZS5kaXNwbGF5TmFtZS50b0xvd2VyQ2FzZSgpIFxuICAgICAgICAgICAgOiBwbGFjZS5kaXNwbGF5TmFtZS50ZXh0LnRvTG93ZXJDYXNlKClcbiAgICApKTtcblxuICAgICAvLyBGaWx0ZXIgb3V0IHBsYWNlcyB0aGF0OlxuICAgIC8vIDEuIEhhdmUgc2FtZSBJRCBhcyBzYXZlZCBwbGFjZVxuICAgIC8vIDIuIEhhdmUgc2FtZSBuYW1lIGFzIHNhdmVkIHBsYWNlXG4gICAgcmV0dXJuIHBsYWNlcy5maWx0ZXIocGxhY2UgPT4ge1xuICAgICAgICBpZiAoIXBsYWNlLmlkKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChzYXZlZFBsYWNlSWRzLmhhcyhwbGFjZS5pZCkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHBsYWNlTmFtZSA9IHR5cGVvZiBwbGFjZS5kaXNwbGF5TmFtZSA9PT0gJ3N0cmluZycgXG4gICAgICAgICAgICA/IHBsYWNlLmRpc3BsYXlOYW1lLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgIDogcGxhY2UuZGlzcGxheU5hbWUudGV4dC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgXG4gICAgICAgIGlmIChzYXZlZFBsYWNlTmFtZXMuaGFzKHBsYWNlTmFtZSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xufVxuXG4vLyBBZGQgU2F2ZWRQbGFjZXNNYW5hZ2VyIGludGVyZmFjZVxuZXhwb3J0IGludGVyZmFjZSBTYXZlZFBsYWNlc01hbmFnZXIge1xuICAgIHBsYWNlczogTWFwPHN0cmluZywgUGxhY2U+O1xuICAgIGFkZFBsYWNlOiAocGxhY2U6IFBsYWNlKSA9PiB2b2lkO1xuICAgIHJlbW92ZVBsYWNlOiAoaWQ6IHN0cmluZykgPT4gdm9pZDtcbiAgICBnZXRQbGFjZXM6ICgpID0+IFBsYWNlW107XG4gICAgaGFzUGxhY2U6IChpZDogc3RyaW5nKSA9PiBib29sZWFuO1xuICAgIF9wZXJzaXN0OiAoKSA9PiB2b2lkO1xuICAgIF9ub3RpZnlDaGFuZ2U6ICgpID0+IHZvaWQ7XG59XG5cbmNvbnN0IFNUT1JBR0VfS0VZID0gJ3NhdmVkX3BsYWNlcyc7XG5cbi8vIEluaXRpYWxpemUgZnJvbSBsb2NhbFN0b3JhZ2UgaWYgYXZhaWxhYmxlXG5mdW5jdGlvbiBpbml0aWFsaXplUGxhY2VzKCk6IE1hcDxzdHJpbmcsIFBsYWNlPiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdbU2F2ZWRQbGFjZXNNYW5hZ2VyXSBTZXJ2ZXItc2lkZSwgcmV0dXJuaW5nIGVtcHR5IG1hcCcpO1xuICAgICAgICByZXR1cm4gbmV3IE1hcDxzdHJpbmcsIFBsYWNlPigpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHNhdmVkUGxhY2VzID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oU1RPUkFHRV9LRVkpO1xuICAgICAgICBjb25zb2xlLmxvZygnW1NhdmVkUGxhY2VzTWFuYWdlcl0gTG9hZGluZyBmcm9tIHN0b3JhZ2U6Jywgc2F2ZWRQbGFjZXMpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHNhdmVkUGxhY2VzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRQbGFjZXMgPSBKU09OLnBhcnNlKHNhdmVkUGxhY2VzKSBhcyBQbGFjZVtdO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1tTYXZlZFBsYWNlc01hbmFnZXJdIFBhcnNlZCBwbGFjZXM6JywgcGFyc2VkUGxhY2VzKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gSGFuZGxlIGFycmF5IGZvcm1hdFxuICAgICAgICAgICAgY29uc3QgcGxhY2VzID0gbmV3IE1hcDxzdHJpbmcsIFBsYWNlPigpO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyc2VkUGxhY2VzKSkge1xuICAgICAgICAgICAgICAgIHBhcnNlZFBsYWNlcy5mb3JFYWNoKHBsYWNlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBsYWNlPy5pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VzLnNldChwbGFjZS5pZCwgcGxhY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbU2F2ZWRQbGFjZXNNYW5hZ2VyXSBJbml0aWFsaXplZCB3aXRoIHBsYWNlczonLCBBcnJheS5mcm9tKHBsYWNlcy52YWx1ZXMoKSkpO1xuICAgICAgICAgICAgcmV0dXJuIHBsYWNlcztcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tTYXZlZFBsYWNlc01hbmFnZXJdIEVycm9yIGxvYWRpbmcgZnJvbSBzdG9yYWdlOicsIGVycm9yKTtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygnW1NhdmVkUGxhY2VzTWFuYWdlcl0gTm8gc2F2ZWQgcGxhY2VzIGZvdW5kLCByZXR1cm5pbmcgZW1wdHkgbWFwJyk7XG4gICAgcmV0dXJuIG5ldyBNYXA8c3RyaW5nLCBQbGFjZT4oKTtcbn1cblxuLy8gRGVjbGFyZSB3aW5kb3cgaW50ZXJmYWNlIGZvciBzYXZlZCBwbGFjZXNcbmRlY2xhcmUgZ2xvYmFsIHtcbiAgICBpbnRlcmZhY2UgV2luZG93IHtcbiAgICAgICAgc2F2ZWRQbGFjZXM6IFBsYWNlW107XG4gICAgICAgIGFkZFBsYWNlVG9NYXA/OiAocGxhY2U6IHtcbiAgICAgICAgICAgIGxhdGl0dWRlOiBudW1iZXI7XG4gICAgICAgICAgICBsb25naXR1ZGU6IG51bWJlcjtcbiAgICAgICAgICAgIHRpdGxlPzogc3RyaW5nO1xuICAgICAgICAgICAgcGxhY2U/OiBQbGFjZTtcbiAgICAgICAgfSkgPT4gdm9pZDtcbiAgICAgICAgZ2V0U2F2ZWRQbGFjZXM/OiAoKSA9PiBQbGFjZVtdO1xuICAgIH1cbn1cblxuLy8gQ3JlYXRlIHRoZSBzaW5nbGV0b24gbWFuYWdlclxuZXhwb3J0IGNvbnN0IHNhdmVkUGxhY2VzTWFuYWdlciA9IHtcbiAgICBwbGFjZXM6IGluaXRpYWxpemVQbGFjZXMoKSxcblxuICAgIGFkZFBsYWNlKHBsYWNlOiBQbGFjZSkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzUGxhY2UocGxhY2UuaWQpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW1NhdmVkUGxhY2VzTWFuYWdlcl0gQWRkaW5nIHBsYWNlOicsIHBsYWNlLmlkKTtcbiAgICAgICAgICAgIHRoaXMucGxhY2VzLnNldChwbGFjZS5pZCwgcGxhY2UpO1xuICAgICAgICAgICAgdGhpcy5fcGVyc2lzdCgpO1xuICAgICAgICAgICAgdGhpcy5fbm90aWZ5Q2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVtb3ZlUGxhY2UoaWQ6IHN0cmluZykge1xuICAgICAgICBpZiAodGhpcy5oYXNQbGFjZShpZCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbU2F2ZWRQbGFjZXNNYW5hZ2VyXSBSZW1vdmluZyBwbGFjZTonLCBpZCk7XG4gICAgICAgICAgICB0aGlzLnBsYWNlcy5kZWxldGUoaWQpO1xuICAgICAgICAgICAgdGhpcy5fcGVyc2lzdCgpO1xuICAgICAgICAgICAgdGhpcy5fbm90aWZ5Q2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0UGxhY2VzKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnBsYWNlcy52YWx1ZXMoKSk7XG4gICAgfSxcblxuICAgIGhhc1BsYWNlKGlkOiBzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGxhY2VzLmhhcyhpZCk7XG4gICAgfSxcblxuICAgIF9wZXJzaXN0KCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGxhY2VzQXJyYXkgPSBBcnJheS5mcm9tKHRoaXMucGxhY2VzLnZhbHVlcygpKTtcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFNUT1JBR0VfS0VZLCBKU09OLnN0cmluZ2lmeShwbGFjZXNBcnJheSkpO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgbWV0cmljcyBpbiBsb2NhbFN0b3JhZ2VcbiAgICAgICAgICAgIGNvbnN0IG1ldHJpY3MgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd0cmF2ZWxfaW50ZXJhY3Rpb25fbWV0cmljcycpIHx8ICd7fScpO1xuICAgICAgICAgICAgbWV0cmljcy5zYXZlZFBsYWNlc0NvdW50ID0gcGxhY2VzQXJyYXkubGVuZ3RoO1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3RyYXZlbF9pbnRlcmFjdGlvbl9tZXRyaWNzJywgSlNPTi5zdHJpbmdpZnkobWV0cmljcykpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW1NhdmVkUGxhY2VzTWFuYWdlcl0gUGVyc2lzdGVkIHBsYWNlcyBhbmQgbWV0cmljczonLCB7IFxuICAgICAgICAgICAgICAgIHBsYWNlc0NvdW50OiBwbGFjZXNBcnJheS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgbWV0cmljcyBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignW1NhdmVkUGxhY2VzTWFuYWdlcl0gRXJyb3IgcGVyc2lzdGluZyBwbGFjZXM6JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9ub3RpZnlDaGFuZ2UoKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY29uc3QgcGxhY2VzID0gdGhpcy5nZXRQbGFjZXMoKTtcbiAgICAgICAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnc2F2ZWRQbGFjZXNDaGFuZ2VkJywgeyBcbiAgICAgICAgICAgICAgICBkZXRhaWw6IHsgXG4gICAgICAgICAgICAgICAgICAgIHBsYWNlcyxcbiAgICAgICAgICAgICAgICAgICAgY291bnQ6IHBsYWNlcy5sZW5ndGhcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9XG59IGFzIGNvbnN0O1xuXG4vLyBJbml0aWFsaXplIHdpbmRvdyBpbnRlcmZhY2UgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHBsYWNlcyA9IHNhdmVkUGxhY2VzTWFuYWdlci5nZXRQbGFjZXMoKTtcbiAgICAgICAgY29uc29sZS5sb2coJ1tTYXZlZFBsYWNlc01hbmFnZXJdIEluaXRpYWxpemluZyB3aW5kb3cgaW50ZXJmYWNlOicsIHBsYWNlcyk7XG4gICAgICAgIHdpbmRvdy5zYXZlZFBsYWNlcyA9IHBsYWNlcztcbiAgICAgICAgd2luZG93LmdldFNhdmVkUGxhY2VzID0gKCkgPT4gc2F2ZWRQbGFjZXNNYW5hZ2VyLmdldFBsYWNlcygpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tTYXZlZFBsYWNlc01hbmFnZXJdIEVycm9yIGluaXRpYWxpemluZyB3aW5kb3cgaW50ZXJmYWNlOicsIGVycm9yKTtcbiAgICB9XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBoYW5kbGUgZGlmZmVyZW50IHNlYXJjaCBzdHJhdGVnaWVzXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2VhcmNoV2l0aFN0cmF0ZWd5KFxuICAgIHNlYXJjaFRleHQ6IHN0cmluZyxcbiAgICBsb2NhdGlvbjogeyBsYXRpdHVkZTogbnVtYmVyOyBsb25naXR1ZGU6IG51bWJlciB9LFxuICAgIGNpdHlOYW1lOiBzdHJpbmdcbik6IFByb21pc2U8YW55PiB7XG4gICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgJ1gtR29vZy1BcGktS2V5JzogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfR09PR0xFX01BUFNfQVBJX0tFWSB8fCAnJyxcbiAgICAgICAgJ1gtR29vZy1GaWVsZE1hc2snOiAnKidcbiAgICB9O1xuXG4gICAgLy8gRXh0cmFjdCBwbGFjZSB0eXBlIGZyb20gc2VhcmNoIHRleHQgKGUuZy4sIFwicGFya1wiLCBcIm11c2V1bVwiLCBldGMuKVxuICAgIGNvbnN0IHR5cGVNYXRjaCA9IHNlYXJjaFRleHQubWF0Y2goLyhcXHcrKVxccyokL2kpO1xuICAgIGNvbnN0IHBsYWNlVHlwZSA9IHR5cGVNYXRjaCA/IHR5cGVNYXRjaFsxXS50b0xvd2VyQ2FzZSgpIDogc2VhcmNoVGV4dC50b0xvd2VyQ2FzZSgpO1xuXG4gICAgLy8gQnVpbGQgc2VhcmNoIHF1ZXJpZXMgYmFzZWQgb24gcGxhY2UgdHlwZVxuICAgIGNvbnN0IGJ1aWxkUXVlcmllcyA9ICh0eXBlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgY29uc3QgYmFzZVF1ZXJpZXMgPSBbXG4gICAgICAgICAgICBgJHt0eXBlfSBpbiAke2NpdHlOYW1lfWAsXG4gICAgICAgICAgICBgJHt0eXBlfSBuZWFyICR7Y2l0eU5hbWV9YCxcbiAgICAgICAgICAgIGBwb3B1bGFyICR7dHlwZX0gaW4gJHtjaXR5TmFtZX1gLFxuICAgICAgICAgICAgYGJlc3QgJHt0eXBlfSBpbiAke2NpdHlOYW1lfWAsXG4gICAgICAgICAgICBgdG9wICR7dHlwZX0gaW4gJHtjaXR5TmFtZX1gXG4gICAgICAgIF1cbiAgICB9O1xuXG4gICAgLy8gR2V0IHF1ZXJpZXMgZm9yIHRoaXMgcGxhY2UgdHlwZVxuICAgIGNvbnN0IHF1ZXJpZXMgPSBidWlsZFF1ZXJpZXMocGxhY2VUeXBlKTtcbiAgICBcbiAgICAvLyBUcnkgZWFjaCBxdWVyeSBpbiBzZXF1ZW5jZVxuICAgIGZvciAoY29uc3QgcXVlcnkgb2YgcXVlcmllcykge1xuICAgICAgICBjb25zb2xlLmxvZygnW3NlYXJjaFdpdGhTdHJhdGVneV0gVHJ5aW5nIHF1ZXJ5OicsIHF1ZXJ5KTtcbiAgICAgICAgY29uc3QgcGxhY2UgPSBhd2FpdCB0cnlTZWFyY2gocXVlcnksIGhlYWRlcnMsIGxvY2F0aW9uKTtcbiAgICAgICAgaWYgKHBsYWNlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW3NlYXJjaFdpdGhTdHJhdGVneV0gRm91bmQgcGxhY2Ugd2l0aCBxdWVyeTonLCBxdWVyeSk7XG4gICAgICAgICAgICByZXR1cm4gcGxhY2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygnW3NlYXJjaFdpdGhTdHJhdGVneV0gTm8gcGxhY2VzIGZvdW5kIHdpdGggYW55IHF1ZXJ5IHN0cmF0ZWd5Jyk7XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byB0cnkgYSBzaW5nbGUgc2VhcmNoIHF1ZXJ5XG5hc3luYyBmdW5jdGlvbiB0cnlTZWFyY2goXG4gICAgcXVlcnk6IHN0cmluZyxcbiAgICBoZWFkZXJzOiBhbnksXG4gICAgbG9jYXRpb246IHsgbGF0aXR1ZGU6IG51bWJlcjsgbG9uZ2l0dWRlOiBudW1iZXIgfVxuKTogUHJvbWlzZTxhbnk+IHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCdodHRwczovL3BsYWNlcy5nb29nbGVhcGlzLmNvbS92MS9wbGFjZXM6c2VhcmNoVGV4dCcsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICB0ZXh0UXVlcnk6IHF1ZXJ5LFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uQmlhczoge1xuICAgICAgICAgICAgICAgICAgICBjaXJjbGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRlcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhdGl0dWRlOiBsb2NhdGlvbi5sYXRpdHVkZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb25naXR1ZGU6IGxvY2F0aW9uLmxvbmdpdHVkZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhZGl1czogMjAwMDAuMFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignW3RyeVNlYXJjaF0gU2VhcmNoIGZhaWxlZDonLCB7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgICBxdWVyeVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGlmICghZGF0YS5wbGFjZXM/Lmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1t0cnlTZWFyY2hdIE5vIHBsYWNlcyBmb3VuZCBmb3IgcXVlcnk6JywgcXVlcnkpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcnkgZWFjaCBwbGFjZSB1bnRpbCB3ZSBmaW5kIG9uZSB0aGF0IGlzbid0IHNhdmVkXG4gICAgICAgIGZvciAoY29uc3QgcGxhY2Ugb2YgZGF0YS5wbGFjZXMpIHtcbiAgICAgICAgICAgIGlmICghc2F2ZWRQbGFjZXNNYW5hZ2VyLmhhc1BsYWNlKHBsYWNlLmlkKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbdHJ5U2VhcmNoXSBGb3VuZCBuZXcgcGxhY2U6Jywge1xuICAgICAgICAgICAgICAgICAgICBpZDogcGxhY2UuaWQsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHBsYWNlLmRpc3BsYXlOYW1lPy50ZXh0IHx8IHBsYWNlLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBsYWNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1t0cnlTZWFyY2hdIFBsYWNlIGFscmVhZHkgc2F2ZWQsIHNraXBwaW5nOicsIHBsYWNlLmRpc3BsYXlOYW1lPy50ZXh0IHx8IHBsYWNlLm5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignW3RyeVNlYXJjaF0gRXJyb3IgaW4gc2VhcmNoOicsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2VhcmNoUGxhY2VCeVRleHQoXG4gICAgc2VhcmNoVGV4dDogc3RyaW5nLFxuICAgIGxvY2F0aW9uOiB7IGxhdGl0dWRlOiBudW1iZXI7IGxvbmdpdHVkZTogbnVtYmVyIH0sXG4gICAgZGVzdGluYXRpb246IHN0cmluZyxcbiAgICBleGNsdWRlSWRzOiBzdHJpbmdbXSA9IFtdXG4pOiBQcm9taXNlPFBsYWNlIHwgbnVsbD4ge1xuICAgIGNvbnNvbGUubG9nKCdbc2VhcmNoUGxhY2VCeVRleHRdIFN0YXJ0aW5nIHNlYXJjaCB3aXRoOicsIHtcbiAgICAgICAgc2VhcmNoVGV4dCxcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICBleGNsdWRlSWRzLFxuICAgICAgICBjdXJyZW50U2F2ZWRQbGFjZXM6IEFycmF5LmZyb20oc2F2ZWRQbGFjZXNNYW5hZ2VyLnBsYWNlcy52YWx1ZXMoKSlcbiAgICB9KTtcblxuICAgIHRyeSB7XG4gICAgICAgIC8vIFRyeSBtdWx0aXBsZSBzZWFyY2ggc3RyYXRlZ2llc1xuICAgICAgICBjb25zdCBzdHJhdGVnaWVzID0gW1xuICAgICAgICAgICAgYCR7c2VhcmNoVGV4dH0gaW4gJHtkZXN0aW5hdGlvbn1gLFxuICAgICAgICAgICAgYCR7c2VhcmNoVGV4dH0gbmVhciAke2Rlc3RpbmF0aW9ufWAsXG4gICAgICAgICAgICBzZWFyY2hUZXh0XG4gICAgICAgIF07XG5cbiAgICAgICAgLy8gS2VlcCB0cmFjayBvZiB0cmllZCBwbGFjZXMgdG8gYXZvaWQgZHVwbGljYXRlc1xuICAgICAgICBjb25zdCB0cmllZFBsYWNlcyA9IG5ldyBTZXQoWy4uLmV4Y2x1ZGVJZHMsIC4uLkFycmF5LmZyb20oc2F2ZWRQbGFjZXNNYW5hZ2VyLnBsYWNlcy5rZXlzKCkpXSk7XG5cbiAgICAgICAgZm9yIChjb25zdCBzdHJhdGVneSBvZiBzdHJhdGVnaWVzKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW3NlYXJjaFBsYWNlQnlUZXh0XSBUcnlpbmcgc3RyYXRlZ3k6Jywgc3RyYXRlZ3kpO1xuICAgICAgICAgICAgY29uc3QgcGxhY2UgPSBhd2FpdCBzZWFyY2hXaXRoU3RyYXRlZ3koc3RyYXRlZ3ksIGxvY2F0aW9uLCBkZXN0aW5hdGlvbik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICghcGxhY2U/LmlkKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1tzZWFyY2hQbGFjZUJ5VGV4dF0gTm8gcGxhY2UgZm91bmQgZm9yIHN0cmF0ZWd5OicsIHN0cmF0ZWd5KTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2tpcCBpZiB3ZSd2ZSBhbHJlYWR5IHRyaWVkIHRoaXMgcGxhY2VcbiAgICAgICAgICAgIGlmICh0cmllZFBsYWNlcy5oYXMocGxhY2UuaWQpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1tzZWFyY2hQbGFjZUJ5VGV4dF0gUGxhY2UgYWxyZWFkeSB0cmllZDonLCBwbGFjZS5pZCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFkZCB0byB0cmllZCBwbGFjZXMgdG8gcHJldmVudCBkdXBsaWNhdGVzXG4gICAgICAgICAgICB0cmllZFBsYWNlcy5hZGQocGxhY2UuaWQpO1xuXG4gICAgICAgICAgICAvLyBUcmFuc2Zvcm0gdGhlIHJlc3BvbnNlXG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZFBsYWNlID0gdHJhbnNmb3JtUGxhY2VSZXNwb25zZShwbGFjZSk7XG4gICAgICAgICAgICBpZiAoIXRyYW5zZm9ybWVkUGxhY2UpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW3NlYXJjaFBsYWNlQnlUZXh0XSBGYWlsZWQgdG8gdHJhbnNmb3JtIHBsYWNlJyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbc2VhcmNoUGxhY2VCeVRleHRdIEZvdW5kIHVuaXF1ZSBwbGFjZTonLCB7XG4gICAgICAgICAgICAgICAgaWQ6IHRyYW5zZm9ybWVkUGxhY2UuaWQsXG4gICAgICAgICAgICAgICAgbmFtZTogdHJhbnNmb3JtZWRQbGFjZS5kaXNwbGF5TmFtZSxcbiAgICAgICAgICAgICAgICBzdHJhdGVneVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZFBsYWNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2coJ1tzZWFyY2hQbGFjZUJ5VGV4dF0gTm8gdW5pcXVlIHBsYWNlIGZvdW5kIGFmdGVyIHRyeWluZyBhbGwgc3RyYXRlZ2llcycpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdbc2VhcmNoUGxhY2VCeVRleHRdIEVycm9yOicsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gdHJhbnNmb3JtIEdvb2dsZSBQbGFjZXMgQVBJIHJlc3BvbnNlIHRvIG91ciBQbGFjZSB0eXBlXG5mdW5jdGlvbiB0cmFuc2Zvcm1QbGFjZVJlc3BvbnNlKHBsYWNlOiBHb29nbGVQbGFjZVJlc3BvbnNlKTogUGxhY2UgfCBudWxsIHtcbiAgICBpZiAoIXBsYWNlKSByZXR1cm4gbnVsbDtcblxuICAgIGNvbnN0IGRpc3BsYXlOYW1lID0gcGxhY2UuZGlzcGxheU5hbWU/LnRleHQgXG4gICAgICAgID8geyB0ZXh0OiBwbGFjZS5kaXNwbGF5TmFtZS50ZXh0LCBsYW5ndWFnZUNvZGU6IHBsYWNlLmRpc3BsYXlOYW1lLmxhbmd1YWdlQ29kZSB8fCAnZW4nIH1cbiAgICAgICAgOiBwbGFjZS5uYW1lIHx8ICcnO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IHBsYWNlLmlkLFxuICAgICAgICBuYW1lOiBwbGFjZS5uYW1lLFxuICAgICAgICBkaXNwbGF5TmFtZSxcbiAgICAgICAgcHJpbWFyeVR5cGU6IHBsYWNlLnByaW1hcnlUeXBlIHx8ICdwbGFjZScsXG4gICAgICAgIHBob3RvczogcGxhY2UucGhvdG9zPy5tYXAocGhvdG8gPT4gKHsgXG4gICAgICAgICAgICBuYW1lOiBwaG90by5uYW1lLFxuICAgICAgICAgICAgd2lkdGhQeDogcGhvdG8ud2lkdGhQeCxcbiAgICAgICAgICAgIGhlaWdodFB4OiBwaG90by5oZWlnaHRQeCxcbiAgICAgICAgICAgIGF1dGhvckF0dHJpYnV0aW9uczogcGhvdG8uYXV0aG9yQXR0cmlidXRpb25zXG4gICAgICAgIH0pKSB8fCBbXSxcbiAgICAgICAgZm9ybWF0dGVkQWRkcmVzczogcGxhY2UuZm9ybWF0dGVkQWRkcmVzcyxcbiAgICAgICAgbG9jYXRpb246IHBsYWNlLmxvY2F0aW9uLFxuICAgICAgICBwcmltYXJ5VHlwZURpc3BsYXlOYW1lOiBwbGFjZS5wcmltYXJ5VHlwZURpc3BsYXlOYW1lIFxuICAgICAgICAgICAgPyB7IHRleHQ6IHBsYWNlLnByaW1hcnlUeXBlRGlzcGxheU5hbWUudGV4dCwgbGFuZ3VhZ2VDb2RlOiBwbGFjZS5wcmltYXJ5VHlwZURpc3BsYXlOYW1lLmxhbmd1YWdlQ29kZSB8fCAnZW4nIH1cbiAgICAgICAgICAgIDogdW5kZWZpbmVkXG4gICAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IHNlYXJjaE11bHRpcGxlUGxhY2VzQnlUZXh0ID0gYXN5bmMgKFxuICAgIHNlYXJjaFRleHQ6IHN0cmluZyxcbiAgICBsb2NhdGlvbjogeyBsYXRpdHVkZTogbnVtYmVyOyBsb25naXR1ZGU6IG51bWJlciB9LFxuICAgIG1heFJlc3VsdHM6IG51bWJlciA9IDVcbik6IFByb21pc2U8UGxhY2VbXT4gPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICghcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfR09PR0xFX01BUFNfQVBJX0tFWSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignR29vZ2xlIE1hcHMgQVBJIGtleSBpcyBtaXNzaW5nJyk7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLmxvZygnRXhlY3V0aW5nIHNlYXJjaE11bHRpcGxlUGxhY2VzQnlUZXh0IHdpdGggcGFyYW1zOicsIHtcbiAgICAgICAgICAgIHNlYXJjaFRleHQsXG4gICAgICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgICAgIG1heFJlc3VsdHNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcmVxdWVzdEJvZHkgPSB7XG4gICAgICAgICAgICB0ZXh0UXVlcnk6IHNlYXJjaFRleHQsXG4gICAgICAgICAgICBsb2NhdGlvbkJpYXM6IHtcbiAgICAgICAgICAgICAgICBjaXJjbGU6IHtcbiAgICAgICAgICAgICAgICAgICAgY2VudGVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXRpdHVkZTogbG9jYXRpb24ubGF0aXR1ZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb25naXR1ZGU6IGxvY2F0aW9uLmxvbmdpdHVkZVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICByYWRpdXM6IDIwMDAwLjAgLy8gMjBrbSByYWRpdXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWF4UmVzdWx0Q291bnQ6IG1heFJlc3VsdHNcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICdYLUdvb2ctQXBpLUtleSc6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0dPT0dMRV9NQVBTX0FQSV9LRVksXG4gICAgICAgICAgICAnWC1Hb29nLUZpZWxkTWFzayc6ICdwbGFjZXMuaWQscGxhY2VzLmRpc3BsYXlOYW1lLHBsYWNlcy5mb3JtYXR0ZWRBZGRyZXNzLHBsYWNlcy5sb2NhdGlvbixwbGFjZXMucHJpbWFyeVR5cGUscGxhY2VzLnByaW1hcnlUeXBlRGlzcGxheU5hbWUscGxhY2VzLnBob3Rvcy5uYW1lJ1xuICAgICAgICB9IGFzIGNvbnN0O1xuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJ2h0dHBzOi8vcGxhY2VzLmdvb2dsZWFwaXMuY29tL3YxL3BsYWNlczpzZWFyY2hUZXh0Jywge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocmVxdWVzdEJvZHkpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBzZWFyY2ggcGxhY2VzOicsIHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvckRhdGFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgXG4gICAgICAgIGlmICghZGF0YS5wbGFjZXMgfHwgIUFycmF5LmlzQXJyYXkoZGF0YS5wbGFjZXMpIHx8IGRhdGEucGxhY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ05vIHBsYWNlcyBmb3VuZCBmb3IgdGV4dCBzZWFyY2g6Jywgc2VhcmNoVGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0YS5wbGFjZXMubWFwKChwbGFjZTogYW55KSA9PiAoe1xuICAgICAgICAgICAgaWQ6IHBsYWNlLmlkLFxuICAgICAgICAgICAgZGlzcGxheU5hbWU6IHBsYWNlLmRpc3BsYXlOYW1lPy50ZXh0ID8ge1xuICAgICAgICAgICAgICAgIHRleHQ6IHBsYWNlLmRpc3BsYXlOYW1lLnRleHQsXG4gICAgICAgICAgICAgICAgbGFuZ3VhZ2VDb2RlOiBwbGFjZS5kaXNwbGF5TmFtZS5sYW5ndWFnZUNvZGUgfHwgJ2VuJ1xuICAgICAgICAgICAgfSA6IHBsYWNlLmRpc3BsYXlOYW1lLFxuICAgICAgICAgICAgcHJpbWFyeVR5cGU6IHBsYWNlLnByaW1hcnlUeXBlIHx8ICdwbGFjZScsXG4gICAgICAgICAgICBwaG90b3M6IHBsYWNlLnBob3Rvcz8ubWFwKChwaG90bzogYW55KSA9PiAoeyBcbiAgICAgICAgICAgICAgICBuYW1lOiBwaG90by5uYW1lXG4gICAgICAgICAgICB9KSkgfHwgW10sXG4gICAgICAgICAgICBmb3JtYXR0ZWRBZGRyZXNzOiBwbGFjZS5mb3JtYXR0ZWRBZGRyZXNzLFxuICAgICAgICAgICAgbG9jYXRpb246IHBsYWNlLmxvY2F0aW9uLFxuICAgICAgICAgICAgcHJpbWFyeVR5cGVEaXNwbGF5TmFtZTogcGxhY2UucHJpbWFyeVR5cGVEaXNwbGF5TmFtZSA/IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBwbGFjZS5wcmltYXJ5VHlwZURpc3BsYXlOYW1lLnRleHQsXG4gICAgICAgICAgICAgICAgbGFuZ3VhZ2VDb2RlOiBwbGFjZS5wcmltYXJ5VHlwZURpc3BsYXlOYW1lLmxhbmd1YWdlQ29kZSB8fCAnZW4nXG4gICAgICAgICAgICB9IDogdW5kZWZpbmVkXG4gICAgICAgIH0pKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzZWFyY2hpbmcgZm9yIHBsYWNlczonLCBlcnJvcik7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59O1xuXG4vLyBGZXRjaCBwbGFjZXMgZnJvbSBHb29nbGUgUGxhY2VzIEFQSVxuZXhwb3J0IGNvbnN0IGZldGNoUGxhY2VzID0gYXN5bmMgKFxuICAgIGxhdGl0dWRlOiBudW1iZXIsXG4gICAgbG9uZ2l0dWRlOiBudW1iZXIsXG4gICAgcHJlZmVyZW5jZXM/OiBUcmF2ZWxQcmVmZXJlbmNlW10sXG4gICAgbWF4UmVzdWx0czogbnVtYmVyID0gNSxcbiAgICBwbGFjZVR5cGVzPzogc3RyaW5nW11cbik6IFByb21pc2U8UGxhY2VbXT4gPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICghcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfR09PR0xFX01BUFNfQVBJX0tFWSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignR29vZ2xlIE1hcHMgQVBJIGtleSBpcyBtaXNzaW5nJyk7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBmcm9tUHJlZmVyZW5jZXMgPSAhIXByZWZlcmVuY2VzICYmIHByZWZlcmVuY2VzLmxlbmd0aCA+IDA7XG4gICAgICAgIGNvbnN0IGZyb21QbGFjZVR5cGVzID0gISFwbGFjZVR5cGVzICYmIHBsYWNlVHlwZXMubGVuZ3RoID4gMDtcbiAgICAgICAgXG4gICAgICAgIGlmICghZnJvbVByZWZlcmVuY2VzICYmICFmcm9tUGxhY2VUeXBlcykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignTm8gcHJlZmVyZW5jZXMgb3IgcGxhY2UgdHlwZXMgcHJvdmlkZWQnKTtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVzZSBwcmVmZXJlbmNlcyBpZiBwcm92aWRlZCwgb3RoZXJ3aXNlIHVzZSBwbGFjZVR5cGVzLCBvdGhlcndpc2UgdXNlIGRlZmF1bHRzXG4gICAgICAgIGxldCBpbmNsdWRlZFR5cGVzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICBpZiAoZnJvbVByZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICBpbmNsdWRlZFR5cGVzID0gZ2V0UGxhY2VUeXBlc0Zyb21QcmVmZXJlbmNlcyhwcmVmZXJlbmNlcyEpO1xuICAgICAgICB9IGVsc2UgaWYgKGZyb21QbGFjZVR5cGVzKSB7XG4gICAgICAgICAgICBpbmNsdWRlZFR5cGVzID0gcGxhY2VUeXBlcyE7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLmxvZygnRXhlY3V0aW5nIGZldGNocGxhY2VzIHdpdGggcGFyYW1zOicsIHtcbiAgICAgICAgICAgIGxhdGl0dWRlLFxuICAgICAgICAgICAgbG9uZ2l0dWRlLFxuICAgICAgICAgICAgaW5jbHVkZWRUeXBlcyxcbiAgICAgICAgICAgIG1heFJlc3VsdHMsXG4gICAgICAgICAgICBmcm9tUHJlZmVyZW5jZXM6ICEhcHJlZmVyZW5jZXM/Lmxlbmd0aCxcbiAgICAgICAgICAgIGZyb21QbGFjZVR5cGVzOiAhIXBsYWNlVHlwZXM/Lmxlbmd0aFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBGaXJzdCB0cnkgbmVhcmJ5IHNlYXJjaFxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdEJvZHkgPSB7XG4gICAgICAgICAgICAgICAgaW5jbHVkZWRUeXBlcyxcbiAgICAgICAgICAgICAgICBtYXhSZXN1bHRDb3VudDogbWF4UmVzdWx0cyxcbiAgICAgICAgICAgICAgICBsb2NhdGlvblJlc3RyaWN0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIGNpcmNsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VudGVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF0aXR1ZGU6IGxhdGl0dWRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvbmdpdHVkZTogbG9uZ2l0dWRlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiAyMDAwMC4wIC8vIDIwa20gcmFkaXVzXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgJ1gtR29vZy1BcGktS2V5JzogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfR09PR0xFX01BUFNfQVBJX0tFWSxcbiAgICAgICAgICAgICAgICAnWC1Hb29nLUZpZWxkTWFzayc6ICdwbGFjZXMuaWQscGxhY2VzLmRpc3BsYXlOYW1lLHBsYWNlcy5mb3JtYXR0ZWRBZGRyZXNzLHBsYWNlcy5sb2NhdGlvbixwbGFjZXMucHJpbWFyeVR5cGUscGxhY2VzLnByaW1hcnlUeXBlRGlzcGxheU5hbWUscGxhY2VzLnBob3Rvcy5uYW1lJ1xuICAgICAgICAgICAgfSBhcyBjb25zdDtcblxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnaHR0cHM6Ly9wbGFjZXMuZ29vZ2xlYXBpcy5jb20vdjEvcGxhY2VzOnNlYXJjaE5lYXJieScsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcXVlc3RCb2R5KVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEucGxhY2VzICYmIEFycmF5LmlzQXJyYXkoZGF0YS5wbGFjZXMpICYmIGRhdGEucGxhY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEucGxhY2VzLm1hcCgocGxhY2U6IGFueSkgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBwbGFjZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlOYW1lOiBwbGFjZS5kaXNwbGF5TmFtZT8udGV4dCA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBwbGFjZS5kaXNwbGF5TmFtZS50ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlQ29kZTogcGxhY2UuZGlzcGxheU5hbWUubGFuZ3VhZ2VDb2RlIHx8ICdlbidcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gOiBwbGFjZS5kaXNwbGF5TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnlUeXBlOiBwbGFjZS5wcmltYXJ5VHlwZSB8fCAncGxhY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGhvdG9zOiBwbGFjZS5waG90b3M/Lm1hcCgocGhvdG86IGFueSkgPT4gKHsgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogcGhvdG8ubmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpIHx8IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkQWRkcmVzczogcGxhY2UuZm9ybWF0dGVkQWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBwbGFjZS5sb2NhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnlUeXBlRGlzcGxheU5hbWU6IHBsYWNlLnByaW1hcnlUeXBlRGlzcGxheU5hbWUgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogcGxhY2UucHJpbWFyeVR5cGVEaXNwbGF5TmFtZS50ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlQ29kZTogcGxhY2UucHJpbWFyeVR5cGVEaXNwbGF5TmFtZS5sYW5ndWFnZUNvZGUgfHwgJ2VuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggcGxhY2VzOicsIHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvckRhdGFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gbmVhcmJ5IHNlYXJjaDonLCBlcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBuZWFyYnkgc2VhcmNoIGZhaWxzLCB0cnkgdGV4dCBzZWFyY2ggYXMgZmFsbGJhY2tcbiAgICAgICAgY29uc29sZS5sb2coJ0ZhbGxpbmcgYmFjayB0byB0ZXh0IHNlYXJjaC4uLicpO1xuICAgICAgICBjb25zdCBzZWFyY2hRdWVyeSA9IGZyb21QbGFjZVR5cGVzID8gcGxhY2VUeXBlcyFbMF0gOiBwcmVmZXJlbmNlcyFbMF07XG4gICAgICAgIHJldHVybiBhd2FpdCBzZWFyY2hNdWx0aXBsZVBsYWNlc0J5VGV4dChzZWFyY2hRdWVyeSwgeyBsYXRpdHVkZSwgbG9uZ2l0dWRlIH0sIG1heFJlc3VsdHMpO1xuXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcGxhY2VzOicsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbn07Il0sIm5hbWVzIjpbIlRyYXZlbFByZWZlcmVuY2UiLCJwcmVmZXJlbmNlVG9QbGFjZVR5cGVzIiwiQ3VsdHVyZSIsIk5hdHVyZSIsIkZvb2QiLCJSZWxheGF0aW9uIiwiQWR2ZW50dXJlIiwiU2hvcHBpbmciLCJnZXRQbGFjZVR5cGVzRnJvbVByZWZlcmVuY2VzIiwicHJlZmVyZW5jZXMiLCJ1c2VkVHlwZXMiLCJTZXQiLCJyZXN1bHRUeXBlcyIsImZvckVhY2giLCJwcmVmIiwiYXZhaWxhYmxlVHlwZXMiLCJmaWx0ZXIiLCJ0eXBlIiwiaGFzIiwibnVtVHlwZXMiLCJNYXRoIiwibWluIiwiZmxvb3IiLCJyYW5kb20iLCJsZW5ndGgiLCJzZWxlY3RlZFR5cGVzIiwic29ydCIsInNsaWNlIiwicHVzaCIsImFkZCIsImVycm9yIiwiY29uc29sZSIsImZvcm1hdFByaW1hcnlUeXBlIiwic3BsaXQiLCJtYXAiLCJ3b3JkIiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJqb2luIiwiZ2V0RGlzcGxheU5hbWUiLCJwbGFjZSIsImRpc3BsYXlOYW1lIiwidGV4dCIsIm5hbWUiLCJmaWx0ZXJVbmlxdWVQbGFjZXMiLCJwbGFjZXMiLCJBcnJheSIsImlzQXJyYXkiLCJzYXZlZFBsYWNlcyIsInNhdmVkUGxhY2VzTWFuYWdlciIsImdldFBsYWNlcyIsInNhdmVkUGxhY2VJZHMiLCJpZCIsInNhdmVkUGxhY2VOYW1lcyIsInRvTG93ZXJDYXNlIiwicGxhY2VOYW1lIiwiU1RPUkFHRV9LRVkiLCJpbml0aWFsaXplUGxhY2VzIiwibG9nIiwiTWFwIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsInBhcnNlZFBsYWNlcyIsIkpTT04iLCJwYXJzZSIsInNldCIsImZyb20iLCJ2YWx1ZXMiLCJhZGRQbGFjZSIsImhhc1BsYWNlIiwiX3BlcnNpc3QiLCJfbm90aWZ5Q2hhbmdlIiwicmVtb3ZlUGxhY2UiLCJkZWxldGUiLCJwbGFjZXNBcnJheSIsInNldEl0ZW0iLCJzdHJpbmdpZnkiLCJtZXRyaWNzIiwic2F2ZWRQbGFjZXNDb3VudCIsInBsYWNlc0NvdW50Iiwid2luZG93IiwiZGlzcGF0Y2hFdmVudCIsIkN1c3RvbUV2ZW50IiwiZGV0YWlsIiwiY291bnQiLCJnZXRTYXZlZFBsYWNlcyIsInNlYXJjaFdpdGhTdHJhdGVneSIsInNlYXJjaFRleHQiLCJsb2NhdGlvbiIsImNpdHlOYW1lIiwiaGVhZGVycyIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19HT09HTEVfTUFQU19BUElfS0VZIiwidHlwZU1hdGNoIiwibWF0Y2giLCJwbGFjZVR5cGUiLCJidWlsZFF1ZXJpZXMiLCJiYXNlUXVlcmllcyIsInF1ZXJpZXMiLCJxdWVyeSIsInRyeVNlYXJjaCIsImRhdGEiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiYm9keSIsInRleHRRdWVyeSIsImxvY2F0aW9uQmlhcyIsImNpcmNsZSIsImNlbnRlciIsImxhdGl0dWRlIiwibG9uZ2l0dWRlIiwicmFkaXVzIiwib2siLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwianNvbiIsInNlYXJjaFBsYWNlQnlUZXh0IiwiZGVzdGluYXRpb24iLCJleGNsdWRlSWRzIiwiY3VycmVudFNhdmVkUGxhY2VzIiwic3RyYXRlZ2llcyIsInRyaWVkUGxhY2VzIiwia2V5cyIsInN0cmF0ZWd5IiwidHJhbnNmb3JtZWRQbGFjZSIsInRyYW5zZm9ybVBsYWNlUmVzcG9uc2UiLCJsYW5ndWFnZUNvZGUiLCJwcmltYXJ5VHlwZSIsInBob3RvcyIsInBob3RvIiwid2lkdGhQeCIsImhlaWdodFB4IiwiYXV0aG9yQXR0cmlidXRpb25zIiwiZm9ybWF0dGVkQWRkcmVzcyIsInByaW1hcnlUeXBlRGlzcGxheU5hbWUiLCJ1bmRlZmluZWQiLCJzZWFyY2hNdWx0aXBsZVBsYWNlc0J5VGV4dCIsIm1heFJlc3VsdHMiLCJyZXF1ZXN0Qm9keSIsIm1heFJlc3VsdENvdW50IiwiZXJyb3JEYXRhIiwiZmV0Y2hQbGFjZXMiLCJwbGFjZVR5cGVzIiwiZnJvbVByZWZlcmVuY2VzIiwiZnJvbVBsYWNlVHlwZXMiLCJpbmNsdWRlZFR5cGVzIiwibG9jYXRpb25SZXN0cmljdGlvbiIsInNlYXJjaFF1ZXJ5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./utils/places-utils.ts\n"));

/***/ })

});