"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("components_travel-chat_tsx",{

/***/ "./managers/ai-chat-manager.ts":
/*!*************************************!*\
  !*** ./managers/ai-chat-manager.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AIChatManager: function() { return /* binding */ AIChatManager; }\n/* harmony export */ });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"./node_modules/next/dist/compiled/events/events.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ \"./managers/types.ts\");\n\n\nclass AIChatManager extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    initializeChatHistory() {\n        return {\n            messages: [],\n            metadata: {\n                lastInteractionTime: new Date(),\n                currentState: \"initial\",\n                validParameters: []\n            }\n        };\n    }\n    async handleMessage(message) {\n        try {\n            // Add user message to history\n            this.addMessage({\n                id: Date.now().toString(),\n                role: \"user\",\n                content: message\n            });\n            // Process message and update parameters\n            const response = await this.processMessage(message);\n            // Add AI response to history\n            this.addMessage({\n                id: (Date.now() + 1).toString(),\n                role: \"assistant\",\n                content: response.message,\n                data: {\n                    currentDetails: response.parameters\n                }\n            });\n            return response;\n        } catch (error) {\n            console.error(\"Error handling message:\", error);\n            return {\n                message: \"I encountered an error processing your message. Let's continue from where we left off.\",\n                error: error instanceof Error ? error.message : \"Unknown error\"\n            };\n        }\n    }\n    async processMessage(message) {\n        const currentState = this.chatHistory.metadata.currentState;\n        if (currentState === \"interrupted\") {\n            return this.recoverConversation();\n        }\n        // Update state based on message content and current parameters\n        const updatedParameters = await this.extractParameters(message);\n        const validationResult = this.validateParameters(updatedParameters);\n        if (validationResult.isValid) {\n            this.updateState(\"planning\");\n            return {\n                message: \"Great! I have all the information needed. Let me plan your trip.\",\n                parameters: updatedParameters\n            };\n        }\n        return {\n            message: \"Could you please provide your \".concat(validationResult.missingParams.join(\", \"), \"?\"),\n            parameters: updatedParameters,\n            suggestedAction: \"gather_info\"\n        };\n    }\n    validateParameters(parameters) {\n        var _parameters_preferences;\n        const missingParams = Array.from(this.requiredParameters).filter((param)=>!parameters[param]);\n        const invalidParams = [];\n        // Validate budget format\n        if (parameters.budget && ![\n            \"$\",\n            \"$$\",\n            \"$$$\",\n            \"$$$$\"\n        ].includes(parameters.budget)) {\n            invalidParams.push(\"budget\");\n        }\n        // Validate language\n        if (parameters.language && !Object.keys(_types__WEBPACK_IMPORTED_MODULE_1__.SupportedLanguage).includes(parameters.language)) {\n            invalidParams.push(\"language\");\n        }\n        // Validate preferences\n        if ((_parameters_preferences = parameters.preferences) === null || _parameters_preferences === void 0 ? void 0 : _parameters_preferences.some((pref)=>![\n                \"Culture and Heritage\",\n                \"Nature\",\n                \"Foodie\",\n                \"Leisure\",\n                \"Adventure\",\n                \"Arts and Museums\"\n            ].includes(pref))) {\n            invalidParams.push(\"preferences\");\n        }\n        return {\n            isValid: missingParams.length === 0 && invalidParams.length === 0,\n            missingParams,\n            invalidParams\n        };\n    }\n    async extractParameters(message) {\n        // Implement NLP or pattern matching logic to extract parameters\n        // For now, return current parameters\n        const currentDetails = this.getCurrentParameters();\n        return {\n            ...currentDetails\n        };\n    }\n    addMessage(message) {\n        this.chatHistory.messages.push(message);\n        this.chatHistory.metadata.lastInteractionTime = new Date();\n        // Trim history if it exceeds maxHistoryLength\n        if (this.chatHistory.messages.length > this.maxHistoryLength) {\n            this.chatHistory.messages = this.chatHistory.messages.slice(-this.maxHistoryLength);\n        }\n        this.emit(\"messageAdded\", message);\n    }\n    getContextHistory() {\n        return this.chatHistory;\n    }\n    getCurrentParameters() {\n        var _lastMessage_data;\n        const lastMessage = this.chatHistory.messages.reverse().find((msg)=>{\n            var _msg_data;\n            return (_msg_data = msg.data) === null || _msg_data === void 0 ? void 0 : _msg_data.currentDetails;\n        });\n        return (lastMessage === null || lastMessage === void 0 ? void 0 : (_lastMessage_data = lastMessage.data) === null || _lastMessage_data === void 0 ? void 0 : _lastMessage_data.currentDetails) || {};\n    }\n    updateState(newState) {\n        this.chatHistory.metadata.currentState = newState;\n        this.emit(\"stateChanged\", newState);\n    }\n    async recoverConversation() {\n        const currentParams = this.getCurrentParameters();\n        const validationResult = this.validateParameters(currentParams);\n        this.updateState(\"gathering_info\");\n        return {\n            message: \"Let me help you get back on track. \" + (validationResult.missingParams.length > 0 ? \"I still need your \".concat(validationResult.missingParams.join(\", \"), \".\") : \"We were about to start planning your trip.\"),\n            parameters: currentParams\n        };\n    }\n    clearHistory() {\n        this.chatHistory = this.initializeChatHistory();\n        this.emit(\"historyCleared\");\n    }\n    formatMessageContent(content) {\n        if (!content) return \"\";\n        // Remove excessive newlines\n        const trimmedContent = content.replace(/\\n{3,}/g, \"\\n\\n\");\n        // Ensure proper spacing around special characters\n        return trimmedContent.replace(/([.!?])\\s*(?=\\S)/g, \"$1 \") // Add space after punctuation if missing\n        .trim();\n    }\n    updateSystemContext(details) {\n        const systemMessage = this.chatHistory.messages.find((m)=>m.role === \"system\");\n        if (systemMessage) {\n            var _details_preferences;\n            systemMessage.content = \"You are a knowledgeable travel assistant. Your role is to help users plan their trips by:\\n1. Understanding and remembering their travel preferences, dates, and budget\\n2. Providing detailed information about their chosen destination\\n3. Making suggestions based on their interests and constraints\\n\\nCurrent Travel Details:\\n- Destination: \".concat(details.destination || \"Not specified\", \"\\n- Dates: \").concat(details.startDate ? \"\".concat(details.startDate, \" to \").concat(details.endDate) : \"Not specified\", \"\\n- Budget Level: \").concat(details.budget || \"Not specified\", \"\\n- Language: \").concat(details.language || \"Not specified\", \"\\n- Preferences: \").concat(((_details_preferences = details.preferences) === null || _details_preferences === void 0 ? void 0 : _details_preferences.join(\", \")) || \"Not specified\", \"\\n\\nKeep this context in mind throughout the conversation. If any detail changes, update your knowledge accordingly.\\nWhen providing information about destinations, include key attractions, local culture, best times to visit, and relevant travel tips.\");\n        }\n        this.emit(\"contextUpdated\", this.chatHistory);\n    }\n    handleFunctionCall(functionName, args) {\n        switch(functionName){\n            case \"getDetails\":\n                this.emit(\"getDetails\");\n                break;\n            case \"updatePreferences\":\n                this.emit(\"updatePreferences\", args.prefs);\n                break;\n            case \"updateDates\":\n                this.emit(\"updateDates\", args.start, args.end);\n                break;\n            case \"updateBudget\":\n                this.emit(\"updateBudget\", args.level);\n                break;\n            case \"updateLanguage\":\n                this.emit(\"updateLanguage\", args.lang);\n                break;\n            default:\n                console.warn(\"Unknown function call: \".concat(functionName));\n        }\n    }\n    processAIResponse(response) {\n        // Check for function calls in the response\n        const functionCallRegex = /\\b(getDetails|updatePreferences|updateDates|updateBudget|updateLanguage)\\((.*?)\\)/g;\n        let match;\n        while((match = functionCallRegex.exec(response)) !== null){\n            const [_, functionName, argsStr] = match;\n            try {\n                const args = argsStr ? JSON.parse(\"{\".concat(argsStr, \"}\")) : {};\n                this.handleFunctionCall(functionName, args);\n            } catch (error) {\n                console.error(\"Error processing function call: \".concat(error));\n            }\n        }\n    }\n    async sendMessage(message) {\n        var _response_body;\n        const response = await fetch(\"/api/chat-update\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                messages: this.chatHistory.messages,\n                currentDetails: this.currentDetails,\n                componentUpdate: null\n            })\n        });\n        if (!response.ok) {\n            const errorData = await response.json();\n            throw new Error(errorData.error || \"Failed to get response\");\n        }\n        const reader = (_response_body = response.body) === null || _response_body === void 0 ? void 0 : _response_body.getReader();\n        if (!reader) {\n            throw new Error(\"No response body\");\n        }\n        return reader;\n    }\n    updateDetails(details) {\n        this.currentDetails = {\n            ...this.currentDetails,\n            ...details\n        };\n        this.emit(\"detailsUpdated\", this.currentDetails);\n    }\n    getCurrentDetails() {\n        return this.currentDetails;\n    }\n    async handleToolUpdate(toolName, value) {\n        try {\n            var _response_body;\n            // Log the start of the operation\n            console.log(\"[handleToolUpdate] Starting update...\", {\n                toolName,\n                value\n            });\n            // Update details based on tool type\n            const updatedDetails = {\n                ...this.currentDetails,\n                ...toolName === \"budgetSelector\" ? {\n                    budget: value\n                } : {},\n                ...toolName === \"preferenceSelector\" ? {\n                    preferences: value\n                } : {},\n                ...toolName === \"languageSelector\" ? {\n                    language: value\n                } : {},\n                ...toolName === \"datePicker\" ? {\n                    startDate: value.startDate,\n                    endDate: value.endDate\n                } : {}\n            };\n            // Log the request preparation\n            console.log(\"[handleToolUpdate] Preparing request with:\", {\n                type: toolName,\n                value,\n                details: updatedDetails\n            });\n            // Use the formatted message for the request\n            const formattedMessage = this.formatUpdateMessage(toolName, value);\n            // Simplified request body\n            const requestBody = {\n                messages: [\n                    {\n                        role: \"user\",\n                        content: formattedMessage\n                    }\n                ],\n                currentDetails: updatedDetails,\n                componentUpdate: {\n                    type: toolName,\n                    value\n                }\n            };\n            // Make the request\n            console.log(\"[handleToolUpdate] Making API request...\");\n            const response = await fetch(\"/api/chat-update\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify(requestBody)\n            });\n            console.log(\"[handleToolUpdate] Response received:\", response.status);\n            if (!response.ok) {\n                throw new Error(\"API returned \".concat(response.status));\n            }\n            const reader = (_response_body = response.body) === null || _response_body === void 0 ? void 0 : _response_body.getReader();\n            if (!reader) {\n                throw new Error(\"No response body available\");\n            }\n            console.log(\"[handleToolUpdate] Got reader successfully\");\n            this.currentDetails = updatedDetails;\n            this.emit(\"detailsUpdated\", updatedDetails);\n            return {\n                updatedDetails,\n                reader\n            };\n        } catch (error) {\n            console.error(\"[handleToolUpdate] Error:\", error);\n            throw error;\n        }\n    }\n    formatUpdateMessage(toolName, value) {\n        switch(toolName){\n            case \"datePicker\":\n                return \"I've selected these travel dates: \".concat(value.startDate, \" to \").concat(value.endDate);\n            case \"preferenceSelector\":\n                return \"I've updated my travel preferences to: \".concat(Array.isArray(value) ? value.join(\", \") : value);\n            case \"budgetSelector\":\n                return \"I've set my travel budget to: \".concat(value);\n            case \"languageSelector\":\n                return \"I'd like the PDF export in this language: \".concat(value);\n            default:\n                return \"I've updated my \".concat(toolName.replace(/([A-Z])/g, \" $1\").toLowerCase(), \" to: \").concat(Array.isArray(value) ? value.join(\", \") : value);\n        }\n    }\n    async processStreamingResponse(reader, onChunk) {\n        console.log(\"[processStreamingResponse] Starting to process stream\");\n        const decoder = new TextDecoder();\n        let accumulatedContent = \"\";\n        let currentMessage = this.chatHistory.messages[this.chatHistory.messages.length - 1];\n        try {\n            while(true){\n                const { done, value } = await reader.read();\n                if (done) {\n                    console.log(\"[processStreamingResponse] Stream complete\");\n                    break;\n                }\n                const text = decoder.decode(value, {\n                    stream: true\n                });\n                console.log(\"[processStreamingResponse] Text chunk received:\", text);\n                onChunk(text); // Send the chunk\n            }\n            if (currentMessage) {\n                console.log(\"[processStreamingResponse] Final message:\", currentMessage.content);\n                this.processAIResponse(currentMessage.content);\n            }\n            this.emit(\"messageUpdated\", currentMessage);\n        } catch (error) {\n            console.error(\"[processStreamingResponse] Stream processing error:\", error);\n            throw error;\n        } finally{\n            console.log(\"[processStreamingResponse] Cleaning up stream\");\n            reader.releaseLock();\n        }\n    }\n    constructor(initialDetails){\n        super();\n        this.chatHistory = this.initializeChatHistory();\n        this.currentDetails = initialDetails;\n        this.requiredParameters = new Set([\n            \"destination\",\n            \"startDate\",\n            \"endDate\",\n            \"budget\",\n            \"language\"\n        ]);\n        this.maxHistoryLength = 50;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9tYW5hZ2Vycy9haS1jaGF0LW1hbmFnZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFzQztBQWFyQjtBQUVWLE1BQU1FLHNCQUFzQkYsZ0RBQVlBO0lBb0JuQ0csd0JBQXFDO1FBQ3pDLE9BQU87WUFDSEMsVUFBVSxFQUFFO1lBQ1pDLFVBQVU7Z0JBQ05DLHFCQUFxQixJQUFJQztnQkFDekJDLGNBQWM7Z0JBQ2RDLGlCQUFpQixFQUFFO1lBQ3ZCO1FBQ0o7SUFDSjtJQUVBLE1BQU1DLGNBQWNDLE9BQWUsRUFBdUI7UUFDdEQsSUFBSTtZQUNBLDhCQUE4QjtZQUM5QixJQUFJLENBQUNDLFVBQVUsQ0FBQztnQkFDWkMsSUFBSU4sS0FBS08sR0FBRyxHQUFHQyxRQUFRO2dCQUN2QkMsTUFBTTtnQkFDTkMsU0FBU047WUFDYjtZQUVBLHdDQUF3QztZQUN4QyxNQUFNTyxXQUFXLE1BQU0sSUFBSSxDQUFDQyxjQUFjLENBQUNSO1lBRTNDLDZCQUE2QjtZQUM3QixJQUFJLENBQUNDLFVBQVUsQ0FBQztnQkFDWkMsSUFBSSxDQUFDTixLQUFLTyxHQUFHLEtBQUssR0FBR0MsUUFBUTtnQkFDN0JDLE1BQU07Z0JBQ05DLFNBQVNDLFNBQVNQLE9BQU87Z0JBQ3pCUyxNQUFNO29CQUNGQyxnQkFBZ0JILFNBQVNJLFVBQVU7Z0JBQ3ZDO1lBQ0o7WUFFQSxPQUFPSjtRQUNYLEVBQUUsT0FBT0ssT0FBTztZQUNaQyxRQUFRRCxLQUFLLENBQUMsMkJBQTJCQTtZQUN6QyxPQUFPO2dCQUNIWixTQUFTO2dCQUNUWSxPQUFPQSxpQkFBaUJFLFFBQVFGLE1BQU1aLE9BQU8sR0FBRztZQUNwRDtRQUNKO0lBQ0o7SUFFQSxNQUFjUSxlQUFlUixPQUFlLEVBQXVCO1FBQy9ELE1BQU1ILGVBQWUsSUFBSSxDQUFDa0IsV0FBVyxDQUFDckIsUUFBUSxDQUFDRyxZQUFZO1FBRTNELElBQUlBLGlCQUFpQixlQUFlO1lBQ2hDLE9BQU8sSUFBSSxDQUFDbUIsbUJBQW1CO1FBQ25DO1FBRUEsK0RBQStEO1FBQy9ELE1BQU1DLG9CQUFvQixNQUFNLElBQUksQ0FBQ0MsaUJBQWlCLENBQUNsQjtRQUN2RCxNQUFNbUIsbUJBQW1CLElBQUksQ0FBQ0Msa0JBQWtCLENBQUNIO1FBRWpELElBQUlFLGlCQUFpQkUsT0FBTyxFQUFFO1lBQzFCLElBQUksQ0FBQ0MsV0FBVyxDQUFDO1lBQ2pCLE9BQU87Z0JBQ0h0QixTQUFTO2dCQUNUVyxZQUFZTTtZQUNoQjtRQUNKO1FBRUEsT0FBTztZQUNIakIsU0FBUyxpQ0FBMkUsT0FBMUNtQixpQkFBaUJJLGFBQWEsQ0FBQ0MsSUFBSSxDQUFDLE9BQU07WUFDcEZiLFlBQVlNO1lBQ1pRLGlCQUFpQjtRQUNyQjtJQUNKO0lBRVFMLG1CQUFtQlQsVUFBNEIsRUFJckQ7WUFpQk1BO1FBaEJKLE1BQU1ZLGdCQUFnQkcsTUFBTUMsSUFBSSxDQUFDLElBQUksQ0FBQ0Msa0JBQWtCLEVBQ25EQyxNQUFNLENBQUNDLENBQUFBLFFBQVMsQ0FBQ25CLFVBQVUsQ0FBQ21CLE1BQWdDO1FBRWpFLE1BQU1DLGdCQUEwQixFQUFFO1FBRWxDLHlCQUF5QjtRQUN6QixJQUFJcEIsV0FBV3FCLE1BQU0sSUFBSSxDQUFDO1lBQUM7WUFBSztZQUFNO1lBQU87U0FBTyxDQUFDQyxRQUFRLENBQUN0QixXQUFXcUIsTUFBTSxHQUFHO1lBQzlFRCxjQUFjRyxJQUFJLENBQUM7UUFDdkI7UUFFQSxvQkFBb0I7UUFDcEIsSUFBSXZCLFdBQVd3QixRQUFRLElBQUksQ0FBQ0MsT0FBT0MsSUFBSSxDQUFDL0MscURBQWlCQSxFQUFFMkMsUUFBUSxDQUFDdEIsV0FBV3dCLFFBQVEsR0FBRztZQUN0RkosY0FBY0csSUFBSSxDQUFDO1FBQ3ZCO1FBRUEsdUJBQXVCO1FBQ3ZCLEtBQUl2QiwwQkFBQUEsV0FBVzJCLFdBQVcsY0FBdEIzQiw4Q0FBQUEsd0JBQXdCNEIsSUFBSSxDQUFDQyxDQUFBQSxPQUM3QixDQUFDO2dCQUFDO2dCQUF3QjtnQkFBVTtnQkFBVTtnQkFBVztnQkFBYTthQUFtQixDQUN4RlAsUUFBUSxDQUFDTyxRQUFRO1lBQ2xCVCxjQUFjRyxJQUFJLENBQUM7UUFDdkI7UUFFQSxPQUFPO1lBQ0hiLFNBQVNFLGNBQWNrQixNQUFNLEtBQUssS0FBS1YsY0FBY1UsTUFBTSxLQUFLO1lBQ2hFbEI7WUFDQVE7UUFDSjtJQUNKO0lBRUEsTUFBY2Isa0JBQWtCbEIsT0FBZSxFQUE2QjtRQUN4RSxnRUFBZ0U7UUFDaEUscUNBQXFDO1FBQ3JDLE1BQU1VLGlCQUFpQixJQUFJLENBQUNnQyxvQkFBb0I7UUFDaEQsT0FBTztZQUNILEdBQUdoQyxjQUFjO1FBQ3JCO0lBQ0o7SUFFUVQsV0FBV0QsT0FBb0IsRUFBUTtRQUMzQyxJQUFJLENBQUNlLFdBQVcsQ0FBQ3RCLFFBQVEsQ0FBQ3lDLElBQUksQ0FBQ2xDO1FBQy9CLElBQUksQ0FBQ2UsV0FBVyxDQUFDckIsUUFBUSxDQUFDQyxtQkFBbUIsR0FBRyxJQUFJQztRQUVwRCw4Q0FBOEM7UUFDOUMsSUFBSSxJQUFJLENBQUNtQixXQUFXLENBQUN0QixRQUFRLENBQUNnRCxNQUFNLEdBQUcsSUFBSSxDQUFDRSxnQkFBZ0IsRUFBRTtZQUMxRCxJQUFJLENBQUM1QixXQUFXLENBQUN0QixRQUFRLEdBQUcsSUFBSSxDQUFDc0IsV0FBVyxDQUFDdEIsUUFBUSxDQUFDbUQsS0FBSyxDQUFDLENBQUMsSUFBSSxDQUFDRCxnQkFBZ0I7UUFDdEY7UUFFQSxJQUFJLENBQUNFLElBQUksQ0FBQyxnQkFBZ0I3QztJQUM5QjtJQUVBOEMsb0JBQWlDO1FBQzdCLE9BQU8sSUFBSSxDQUFDL0IsV0FBVztJQUMzQjtJQUVBMkIsdUJBQXlDO1lBSzlCSztRQUpQLE1BQU1BLGNBQWMsSUFBSSxDQUFDaEMsV0FBVyxDQUFDdEIsUUFBUSxDQUN4Q3VELE9BQU8sR0FDUEMsSUFBSSxDQUFDQyxDQUFBQTtnQkFBT0E7b0JBQUFBLFlBQUFBLElBQUl6QyxJQUFJLGNBQVJ5QyxnQ0FBQUEsVUFBVXhDLGNBQWM7O1FBRXpDLE9BQU9xQyxDQUFBQSx3QkFBQUEsbUNBQUFBLG9CQUFBQSxZQUFhdEMsSUFBSSxjQUFqQnNDLHdDQUFBQSxrQkFBbUJyQyxjQUFjLEtBQUksQ0FBQztJQUNqRDtJQUVRWSxZQUFZNkIsUUFBbUIsRUFBUTtRQUMzQyxJQUFJLENBQUNwQyxXQUFXLENBQUNyQixRQUFRLENBQUNHLFlBQVksR0FBR3NEO1FBQ3pDLElBQUksQ0FBQ04sSUFBSSxDQUFDLGdCQUFnQk07SUFDOUI7SUFFQSxNQUFNbkMsc0JBQTJDO1FBQzdDLE1BQU1vQyxnQkFBZ0IsSUFBSSxDQUFDVixvQkFBb0I7UUFDL0MsTUFBTXZCLG1CQUFtQixJQUFJLENBQUNDLGtCQUFrQixDQUFDZ0M7UUFFakQsSUFBSSxDQUFDOUIsV0FBVyxDQUFDO1FBRWpCLE9BQU87WUFDSHRCLFNBQVMsd0NBQ0FtQixDQUFBQSxpQkFBaUJJLGFBQWEsQ0FBQ2tCLE1BQU0sR0FBRyxJQUNuQyxxQkFBK0QsT0FBMUN0QixpQkFBaUJJLGFBQWEsQ0FBQ0MsSUFBSSxDQUFDLE9BQU0sT0FDL0QsNENBQTJDO1lBQ3pEYixZQUFZeUM7UUFDaEI7SUFDSjtJQUVBQyxlQUFxQjtRQUNqQixJQUFJLENBQUN0QyxXQUFXLEdBQUcsSUFBSSxDQUFDdkIscUJBQXFCO1FBQzdDLElBQUksQ0FBQ3FELElBQUksQ0FBQztJQUNkO0lBRU9TLHFCQUFxQmhELE9BQWUsRUFBVTtRQUNqRCxJQUFJLENBQUNBLFNBQVMsT0FBTztRQUVyQiw0QkFBNEI7UUFDNUIsTUFBTWlELGlCQUFpQmpELFFBQVFrRCxPQUFPLENBQUMsV0FBVztRQUVsRCxrREFBa0Q7UUFDbEQsT0FBT0QsZUFDRkMsT0FBTyxDQUFDLHFCQUFxQixPQUFRLHlDQUF5QztTQUM5RUMsSUFBSTtJQUNiO0lBRU9DLG9CQUFvQkMsT0FBeUIsRUFBUTtRQUN4RCxNQUFNQyxnQkFBZ0IsSUFBSSxDQUFDN0MsV0FBVyxDQUFDdEIsUUFBUSxDQUFDd0QsSUFBSSxDQUFDWSxDQUFBQSxJQUFLQSxFQUFFeEQsSUFBSSxLQUFLO1FBQ3JFLElBQUl1RCxlQUFlO2dCQVdWRDtZQVZMQyxjQUFjdEQsT0FBTyxHQUFHLHdWQU96QnFELE9BRE1BLFFBQVFHLFdBQVcsSUFBSSxpQkFBZ0IsZUFFdENILE9BRFBBLFFBQVFJLFNBQVMsR0FBRyxHQUEyQkosT0FBeEJBLFFBQVFJLFNBQVMsRUFBQyxRQUFzQixPQUFoQkosUUFBUUssT0FBTyxJQUFLLGlCQUFnQixzQkFFaEZMLE9BRElBLFFBQVEzQixNQUFNLElBQUksaUJBQWdCLGtCQUVuQzJCLE9BREhBLFFBQVF4QixRQUFRLElBQUksaUJBQWdCLHFCQUNrQixPQUFuRHdCLEVBQUFBLHVCQUFBQSxRQUFRckIsV0FBVyxjQUFuQnFCLDJDQUFBQSxxQkFBcUJuQyxJQUFJLENBQUMsVUFBUyxpQkFBZ0I7UUFJNUQ7UUFDQSxJQUFJLENBQUNxQixJQUFJLENBQUMsa0JBQWtCLElBQUksQ0FBQzlCLFdBQVc7SUFDaEQ7SUFFUWtELG1CQUFtQkMsWUFBb0IsRUFBRUMsSUFBUyxFQUFRO1FBQzlELE9BQVFEO1lBQ0osS0FBSztnQkFDRCxJQUFJLENBQUNyQixJQUFJLENBQUM7Z0JBQ1Y7WUFDSixLQUFLO2dCQUNELElBQUksQ0FBQ0EsSUFBSSxDQUFDLHFCQUFxQnNCLEtBQUtDLEtBQUs7Z0JBQ3pDO1lBQ0osS0FBSztnQkFDRCxJQUFJLENBQUN2QixJQUFJLENBQUMsZUFBZXNCLEtBQUtFLEtBQUssRUFBRUYsS0FBS0csR0FBRztnQkFDN0M7WUFDSixLQUFLO2dCQUNELElBQUksQ0FBQ3pCLElBQUksQ0FBQyxnQkFBZ0JzQixLQUFLSSxLQUFLO2dCQUNwQztZQUNKLEtBQUs7Z0JBQ0QsSUFBSSxDQUFDMUIsSUFBSSxDQUFDLGtCQUFrQnNCLEtBQUtLLElBQUk7Z0JBQ3JDO1lBQ0o7Z0JBQ0kzRCxRQUFRNEQsSUFBSSxDQUFDLDBCQUF1QyxPQUFiUDtRQUMvQztJQUNKO0lBRU9RLGtCQUFrQm5FLFFBQWdCLEVBQVE7UUFDN0MsMkNBQTJDO1FBQzNDLE1BQU1vRSxvQkFBb0I7UUFDMUIsSUFBSUM7UUFFSixNQUFPLENBQUNBLFFBQVFELGtCQUFrQkUsSUFBSSxDQUFDdEUsU0FBUSxNQUFPLEtBQU07WUFDeEQsTUFBTSxDQUFDdUUsR0FBR1osY0FBY2EsUUFBUSxHQUFHSDtZQUNuQyxJQUFJO2dCQUNBLE1BQU1ULE9BQU9ZLFVBQVVDLEtBQUtDLEtBQUssQ0FBQyxJQUFZLE9BQVJGLFNBQVEsUUFBTSxDQUFDO2dCQUNyRCxJQUFJLENBQUNkLGtCQUFrQixDQUFDQyxjQUFjQztZQUMxQyxFQUFFLE9BQU92RCxPQUFPO2dCQUNaQyxRQUFRRCxLQUFLLENBQUMsbUNBQXlDLE9BQU5BO1lBQ3JEO1FBQ0o7SUFDSjtJQUVBLE1BQWFzRSxZQUFZbEYsT0FBZSxFQUFvRDtZQWlCekVPO1FBZmYsTUFBTUEsV0FBVyxNQUFNNEUsTUFBTSxvQkFBb0I7WUFDN0NDLFFBQVE7WUFDUkMsU0FBUztnQkFBRSxnQkFBZ0I7WUFBbUI7WUFDOUNDLE1BQU1OLEtBQUtPLFNBQVMsQ0FBQztnQkFDakI5RixVQUFVLElBQUksQ0FBQ3NCLFdBQVcsQ0FBQ3RCLFFBQVE7Z0JBQ25DaUIsZ0JBQWdCLElBQUksQ0FBQ0EsY0FBYztnQkFDbkM4RSxpQkFBaUI7WUFDckI7UUFDSjtRQUVBLElBQUksQ0FBQ2pGLFNBQVNrRixFQUFFLEVBQUU7WUFDZCxNQUFNQyxZQUFZLE1BQU1uRixTQUFTb0YsSUFBSTtZQUNyQyxNQUFNLElBQUk3RSxNQUFNNEUsVUFBVTlFLEtBQUssSUFBSTtRQUN2QztRQUVBLE1BQU1nRixVQUFTckYsaUJBQUFBLFNBQVMrRSxJQUFJLGNBQWIvRSxxQ0FBQUEsZUFBZXNGLFNBQVM7UUFDdkMsSUFBSSxDQUFDRCxRQUFRO1lBQ1QsTUFBTSxJQUFJOUUsTUFBTTtRQUNwQjtRQUVBLE9BQU84RTtJQUNYO0lBRU9FLGNBQWNuQyxPQUErQixFQUFRO1FBQ3hELElBQUksQ0FBQ2pELGNBQWMsR0FBRztZQUFFLEdBQUcsSUFBSSxDQUFDQSxjQUFjO1lBQUUsR0FBR2lELE9BQU87UUFBQztRQUMzRCxJQUFJLENBQUNkLElBQUksQ0FBQyxrQkFBa0IsSUFBSSxDQUFDbkMsY0FBYztJQUNuRDtJQUVPcUYsb0JBQW1DO1FBQ3RDLE9BQU8sSUFBSSxDQUFDckYsY0FBYztJQUM5QjtJQUVBLE1BQWFzRixpQkFDVEMsUUFBdUIsRUFDdkJDLEtBQVUsRUFJWDtRQUNDLElBQUk7Z0JBc0RlM0Y7WUFyRGYsaUNBQWlDO1lBQ2pDTSxRQUFRc0YsR0FBRyxDQUFDLHlDQUF5QztnQkFBRUY7Z0JBQVVDO1lBQU07WUFFdkUsb0NBQW9DO1lBQ3BDLE1BQU1FLGlCQUFpQjtnQkFDbkIsR0FBRyxJQUFJLENBQUMxRixjQUFjO2dCQUN0QixHQUFJdUYsYUFBYSxtQkFBbUI7b0JBQUVqRSxRQUFRa0U7Z0JBQU0sSUFBSSxDQUFDLENBQUM7Z0JBQzFELEdBQUlELGFBQWEsdUJBQXVCO29CQUFFM0QsYUFBYTREO2dCQUFNLElBQUksQ0FBQyxDQUFDO2dCQUNuRSxHQUFJRCxhQUFhLHFCQUFxQjtvQkFBRTlELFVBQVUrRDtnQkFBTSxJQUFJLENBQUMsQ0FBQztnQkFDOUQsR0FBSUQsYUFBYSxlQUFlO29CQUM1QmxDLFdBQVdtQyxNQUFNbkMsU0FBUztvQkFDMUJDLFNBQVNrQyxNQUFNbEMsT0FBTztnQkFDMUIsSUFBSSxDQUFDLENBQUM7WUFDVjtZQUdBLDhCQUE4QjtZQUM5Qm5ELFFBQVFzRixHQUFHLENBQUMsOENBQThDO2dCQUN0REUsTUFBTUo7Z0JBQ05DO2dCQUNBdkMsU0FBU3lDO1lBQ2I7WUFFQSw0Q0FBNEM7WUFDNUMsTUFBTUUsbUJBQW1CLElBQUksQ0FBQ0MsbUJBQW1CLENBQUNOLFVBQVVDO1lBRTVELDBCQUEwQjtZQUMxQixNQUFNTSxjQUFjO2dCQUNoQi9HLFVBQVU7b0JBQUM7d0JBQ1BZLE1BQU07d0JBQ05DLFNBQVNnRztvQkFDYjtpQkFBRTtnQkFDRjVGLGdCQUFnQjBGO2dCQUNoQlosaUJBQWlCO29CQUNiYSxNQUFNSjtvQkFDTkM7Z0JBQ0o7WUFDSjtZQUVBLG1CQUFtQjtZQUNuQnJGLFFBQVFzRixHQUFHLENBQUM7WUFDWixNQUFNNUYsV0FBVyxNQUFNNEUsTUFBTSxvQkFBb0I7Z0JBQzdDQyxRQUFRO2dCQUNSQyxTQUFTO29CQUFFLGdCQUFnQjtnQkFBbUI7Z0JBQzlDQyxNQUFNTixLQUFLTyxTQUFTLENBQUNpQjtZQUN6QjtZQUVBM0YsUUFBUXNGLEdBQUcsQ0FBQyx5Q0FBeUM1RixTQUFTa0csTUFBTTtZQUVwRSxJQUFJLENBQUNsRyxTQUFTa0YsRUFBRSxFQUFFO2dCQUNkLE1BQU0sSUFBSTNFLE1BQU0sZ0JBQWdDLE9BQWhCUCxTQUFTa0csTUFBTTtZQUNuRDtZQUVBLE1BQU1iLFVBQVNyRixpQkFBQUEsU0FBUytFLElBQUksY0FBYi9FLHFDQUFBQSxlQUFlc0YsU0FBUztZQUN2QyxJQUFJLENBQUNELFFBQVE7Z0JBQ1QsTUFBTSxJQUFJOUUsTUFBTTtZQUNwQjtZQUVBRCxRQUFRc0YsR0FBRyxDQUFDO1lBQ1osSUFBSSxDQUFDekYsY0FBYyxHQUFHMEY7WUFDdEIsSUFBSSxDQUFDdkQsSUFBSSxDQUFDLGtCQUFrQnVEO1lBRTVCLE9BQU87Z0JBQUVBO2dCQUFnQlI7WUFBTztRQUNwQyxFQUFFLE9BQU9oRixPQUFPO1lBQ1pDLFFBQVFELEtBQUssQ0FBQyw2QkFBNkJBO1lBQzNDLE1BQU1BO1FBQ1Y7SUFDSjtJQUVPMkYsb0JBQW9CTixRQUF1QixFQUFFQyxLQUFVLEVBQVU7UUFDcEUsT0FBUUQ7WUFDSixLQUFLO2dCQUNELE9BQU8scUNBQTJEQyxPQUF0QkEsTUFBTW5DLFNBQVMsRUFBQyxRQUFvQixPQUFkbUMsTUFBTWxDLE9BQU87WUFDbkYsS0FBSztnQkFDRCxPQUFPLDBDQUEwRixPQUFoRHRDLE1BQU1nRixPQUFPLENBQUNSLFNBQVNBLE1BQU0xRSxJQUFJLENBQUMsUUFBUTBFO1lBQy9GLEtBQUs7Z0JBQ0QsT0FBTyxpQ0FBdUMsT0FBTkE7WUFDNUMsS0FBSztnQkFDRCxPQUFPLDZDQUFtRCxPQUFOQTtZQUN4RDtnQkFDSSxPQUFPLG1CQUE0RXhFLE9BQXpEdUUsU0FBU3pDLE9BQU8sQ0FBQyxZQUFZLE9BQU9tRCxXQUFXLElBQUcsU0FBdUQsT0FBaERqRixNQUFNZ0YsT0FBTyxDQUFDUixTQUFTQSxNQUFNMUUsSUFBSSxDQUFDLFFBQVEwRTtRQUNySTtJQUNKO0lBRUEsTUFBYVUseUJBQ1RoQixNQUErQyxFQUMvQ2lCLE9BQWtDLEVBQ3JCO1FBQ2JoRyxRQUFRc0YsR0FBRyxDQUFDO1FBQ1osTUFBTVcsVUFBVSxJQUFJQztRQUNwQixJQUFJQyxxQkFBcUI7UUFDekIsSUFBSUMsaUJBQWlCLElBQUksQ0FBQ2xHLFdBQVcsQ0FBQ3RCLFFBQVEsQ0FBQyxJQUFJLENBQUNzQixXQUFXLENBQUN0QixRQUFRLENBQUNnRCxNQUFNLEdBQUcsRUFBRTtRQUVwRixJQUFJO1lBQ0EsTUFBTyxLQUFNO2dCQUNULE1BQU0sRUFBRXlFLElBQUksRUFBRWhCLEtBQUssRUFBRSxHQUFHLE1BQU1OLE9BQU91QixJQUFJO2dCQUN6QyxJQUFJRCxNQUFNO29CQUNOckcsUUFBUXNGLEdBQUcsQ0FBQztvQkFDWjtnQkFDSjtnQkFFQSxNQUFNaUIsT0FBT04sUUFBUU8sTUFBTSxDQUFDbkIsT0FBTztvQkFBRW9CLFFBQVE7Z0JBQUs7Z0JBQ2xEekcsUUFBUXNGLEdBQUcsQ0FBQyxtREFBbURpQjtnQkFFL0RQLFFBQVFPLE9BQVEsaUJBQWlCO1lBQ3JDO1lBRUEsSUFBSUgsZ0JBQWdCO2dCQUNoQnBHLFFBQVFzRixHQUFHLENBQUMsNkNBQTZDYyxlQUFlM0csT0FBTztnQkFDL0UsSUFBSSxDQUFDb0UsaUJBQWlCLENBQUN1QyxlQUFlM0csT0FBTztZQUNqRDtZQUVBLElBQUksQ0FBQ3VDLElBQUksQ0FBQyxrQkFBa0JvRTtRQUNoQyxFQUFFLE9BQU9yRyxPQUFPO1lBQ1pDLFFBQVFELEtBQUssQ0FBQyx1REFBdURBO1lBQ3JFLE1BQU1BO1FBQ1YsU0FBVTtZQUNOQyxRQUFRc0YsR0FBRyxDQUFDO1lBQ1pQLE9BQU8yQixXQUFXO1FBQ3RCO0lBQ0o7SUF4WkFDLFlBQVlDLGNBQTZCLENBQUU7UUFDdkMsS0FBSztRQUNMLElBQUksQ0FBQzFHLFdBQVcsR0FBRyxJQUFJLENBQUN2QixxQkFBcUI7UUFDN0MsSUFBSSxDQUFDa0IsY0FBYyxHQUFHK0c7UUFDdEIsSUFBSSxDQUFDN0Ysa0JBQWtCLEdBQUcsSUFBSThGLElBQUk7WUFDOUI7WUFDQTtZQUNBO1lBQ0E7WUFDQTtTQUNIO1FBQ0QsSUFBSSxDQUFDL0UsZ0JBQWdCLEdBQUc7SUFDNUI7QUE2WUoiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbWFuYWdlcnMvYWktY2hhdC1tYW5hZ2VyLnRzP2M2MmEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJztcbmltcG9ydCB7IFxuICAgIENoYXRIaXN0b3J5LCBcbiAgICBDaGF0TWVzc2FnZSwgXG4gICAgQ2hhdFN0YXRlLCBcbiAgICBUcmF2ZWxQYXJhbWV0ZXJzLFxuICAgIEFJUmVzcG9uc2UsXG4gICAgTWVzc2FnZURhdGEsXG4gICAgQnVkZ2V0TGV2ZWwsXG4gICAgVHJhdmVsUHJlZmVyZW5jZSxcbiAgICBTdXBwb3J0ZWRMYW5ndWFnZSxcbiAgICBUcmF2ZWxEZXRhaWxzLFxuICAgIENvbXBvbmVudFR5cGVcbn0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBjbGFzcyBBSUNoYXRNYW5hZ2VyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgICBwcml2YXRlIGNoYXRIaXN0b3J5OiBDaGF0SGlzdG9yeTtcbiAgICBwcml2YXRlIHJlcXVpcmVkUGFyYW1ldGVyczogU2V0PHN0cmluZz47XG4gICAgcHJpdmF0ZSBtYXhIaXN0b3J5TGVuZ3RoOiBudW1iZXI7XG4gICAgcHJpdmF0ZSBjdXJyZW50RGV0YWlsczogVHJhdmVsRGV0YWlscztcblxuICAgIGNvbnN0cnVjdG9yKGluaXRpYWxEZXRhaWxzOiBUcmF2ZWxEZXRhaWxzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY2hhdEhpc3RvcnkgPSB0aGlzLmluaXRpYWxpemVDaGF0SGlzdG9yeSgpO1xuICAgICAgICB0aGlzLmN1cnJlbnREZXRhaWxzID0gaW5pdGlhbERldGFpbHM7XG4gICAgICAgIHRoaXMucmVxdWlyZWRQYXJhbWV0ZXJzID0gbmV3IFNldChbXG4gICAgICAgICAgICAnZGVzdGluYXRpb24nLFxuICAgICAgICAgICAgJ3N0YXJ0RGF0ZScsXG4gICAgICAgICAgICAnZW5kRGF0ZScsXG4gICAgICAgICAgICAnYnVkZ2V0JyxcbiAgICAgICAgICAgICdsYW5ndWFnZSdcbiAgICAgICAgXSk7XG4gICAgICAgIHRoaXMubWF4SGlzdG9yeUxlbmd0aCA9IDUwO1xuICAgIH1cblxuICAgIHByaXZhdGUgaW5pdGlhbGl6ZUNoYXRIaXN0b3J5KCk6IENoYXRIaXN0b3J5IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lc3NhZ2VzOiBbXSxcbiAgICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICAgICAgbGFzdEludGVyYWN0aW9uVGltZTogbmV3IERhdGUoKSxcbiAgICAgICAgICAgICAgICBjdXJyZW50U3RhdGU6ICdpbml0aWFsJyxcbiAgICAgICAgICAgICAgICB2YWxpZFBhcmFtZXRlcnM6IFtdXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgaGFuZGxlTWVzc2FnZShtZXNzYWdlOiBzdHJpbmcpOiBQcm9taXNlPEFJUmVzcG9uc2U+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEFkZCB1c2VyIG1lc3NhZ2UgdG8gaGlzdG9yeVxuICAgICAgICAgICAgdGhpcy5hZGRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICBpZDogRGF0ZS5ub3coKS50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIHJvbGU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICBjb250ZW50OiBtZXNzYWdlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gUHJvY2VzcyBtZXNzYWdlIGFuZCB1cGRhdGUgcGFyYW1ldGVyc1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByb2Nlc3NNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBBZGQgQUkgcmVzcG9uc2UgdG8gaGlzdG9yeVxuICAgICAgICAgICAgdGhpcy5hZGRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICBpZDogKERhdGUubm93KCkgKyAxKS50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIHJvbGU6ICdhc3Npc3RhbnQnLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHJlc3BvbnNlLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGV0YWlsczogcmVzcG9uc2UucGFyYW1ldGVyc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBoYW5kbGluZyBtZXNzYWdlOicsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ0kgZW5jb3VudGVyZWQgYW4gZXJyb3IgcHJvY2Vzc2luZyB5b3VyIG1lc3NhZ2UuIExldFxcJ3MgY29udGludWUgZnJvbSB3aGVyZSB3ZSBsZWZ0IG9mZi4nLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgcHJvY2Vzc01lc3NhZ2UobWVzc2FnZTogc3RyaW5nKTogUHJvbWlzZTxBSVJlc3BvbnNlPiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IHRoaXMuY2hhdEhpc3RvcnkubWV0YWRhdGEuY3VycmVudFN0YXRlO1xuICAgICAgICBcbiAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZSA9PT0gJ2ludGVycnVwdGVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVjb3ZlckNvbnZlcnNhdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIHN0YXRlIGJhc2VkIG9uIG1lc3NhZ2UgY29udGVudCBhbmQgY3VycmVudCBwYXJhbWV0ZXJzXG4gICAgICAgIGNvbnN0IHVwZGF0ZWRQYXJhbWV0ZXJzID0gYXdhaXQgdGhpcy5leHRyYWN0UGFyYW1ldGVycyhtZXNzYWdlKTtcbiAgICAgICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IHRoaXMudmFsaWRhdGVQYXJhbWV0ZXJzKHVwZGF0ZWRQYXJhbWV0ZXJzKTtcblxuICAgICAgICBpZiAodmFsaWRhdGlvblJlc3VsdC5pc1ZhbGlkKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKCdwbGFubmluZycpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnR3JlYXQhIEkgaGF2ZSBhbGwgdGhlIGluZm9ybWF0aW9uIG5lZWRlZC4gTGV0IG1lIHBsYW4geW91ciB0cmlwLicsXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVyczogdXBkYXRlZFBhcmFtZXRlcnNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWVzc2FnZTogYENvdWxkIHlvdSBwbGVhc2UgcHJvdmlkZSB5b3VyICR7dmFsaWRhdGlvblJlc3VsdC5taXNzaW5nUGFyYW1zLmpvaW4oJywgJyl9P2AsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiB1cGRhdGVkUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHN1Z2dlc3RlZEFjdGlvbjogJ2dhdGhlcl9pbmZvJ1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHByaXZhdGUgdmFsaWRhdGVQYXJhbWV0ZXJzKHBhcmFtZXRlcnM6IFRyYXZlbFBhcmFtZXRlcnMpOiB7IFxuICAgICAgICBpc1ZhbGlkOiBib29sZWFuOyBcbiAgICAgICAgbWlzc2luZ1BhcmFtczogc3RyaW5nW107XG4gICAgICAgIGludmFsaWRQYXJhbXM6IHN0cmluZ1tdO1xuICAgIH0ge1xuICAgICAgICBjb25zdCBtaXNzaW5nUGFyYW1zID0gQXJyYXkuZnJvbSh0aGlzLnJlcXVpcmVkUGFyYW1ldGVycylcbiAgICAgICAgICAgIC5maWx0ZXIocGFyYW0gPT4gIXBhcmFtZXRlcnNbcGFyYW0gYXMga2V5b2YgVHJhdmVsUGFyYW1ldGVyc10pO1xuXG4gICAgICAgIGNvbnN0IGludmFsaWRQYXJhbXM6IHN0cmluZ1tdID0gW107XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgYnVkZ2V0IGZvcm1hdFxuICAgICAgICBpZiAocGFyYW1ldGVycy5idWRnZXQgJiYgIVsnJCcsICckJCcsICckJCQnLCAnJCQkJCddLmluY2x1ZGVzKHBhcmFtZXRlcnMuYnVkZ2V0KSkge1xuICAgICAgICAgICAgaW52YWxpZFBhcmFtcy5wdXNoKCdidWRnZXQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZhbGlkYXRlIGxhbmd1YWdlXG4gICAgICAgIGlmIChwYXJhbWV0ZXJzLmxhbmd1YWdlICYmICFPYmplY3Qua2V5cyhTdXBwb3J0ZWRMYW5ndWFnZSkuaW5jbHVkZXMocGFyYW1ldGVycy5sYW5ndWFnZSkpIHtcbiAgICAgICAgICAgIGludmFsaWRQYXJhbXMucHVzaCgnbGFuZ3VhZ2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZhbGlkYXRlIHByZWZlcmVuY2VzXG4gICAgICAgIGlmIChwYXJhbWV0ZXJzLnByZWZlcmVuY2VzPy5zb21lKHByZWYgPT4gXG4gICAgICAgICAgICAhWydDdWx0dXJlIGFuZCBIZXJpdGFnZScsICdOYXR1cmUnLCAnRm9vZGllJywgJ0xlaXN1cmUnLCAnQWR2ZW50dXJlJywgJ0FydHMgYW5kIE11c2V1bXMnXVxuICAgICAgICAgICAgLmluY2x1ZGVzKHByZWYpKSkge1xuICAgICAgICAgICAgaW52YWxpZFBhcmFtcy5wdXNoKCdwcmVmZXJlbmNlcycpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzVmFsaWQ6IG1pc3NpbmdQYXJhbXMubGVuZ3RoID09PSAwICYmIGludmFsaWRQYXJhbXMubGVuZ3RoID09PSAwLFxuICAgICAgICAgICAgbWlzc2luZ1BhcmFtcyxcbiAgICAgICAgICAgIGludmFsaWRQYXJhbXNcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIGV4dHJhY3RQYXJhbWV0ZXJzKG1lc3NhZ2U6IHN0cmluZyk6IFByb21pc2U8VHJhdmVsUGFyYW1ldGVycz4ge1xuICAgICAgICAvLyBJbXBsZW1lbnQgTkxQIG9yIHBhdHRlcm4gbWF0Y2hpbmcgbG9naWMgdG8gZXh0cmFjdCBwYXJhbWV0ZXJzXG4gICAgICAgIC8vIEZvciBub3csIHJldHVybiBjdXJyZW50IHBhcmFtZXRlcnNcbiAgICAgICAgY29uc3QgY3VycmVudERldGFpbHMgPSB0aGlzLmdldEN1cnJlbnRQYXJhbWV0ZXJzKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5jdXJyZW50RGV0YWlsc1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHByaXZhdGUgYWRkTWVzc2FnZShtZXNzYWdlOiBDaGF0TWVzc2FnZSk6IHZvaWQge1xuICAgICAgICB0aGlzLmNoYXRIaXN0b3J5Lm1lc3NhZ2VzLnB1c2gobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuY2hhdEhpc3RvcnkubWV0YWRhdGEubGFzdEludGVyYWN0aW9uVGltZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIFxuICAgICAgICAvLyBUcmltIGhpc3RvcnkgaWYgaXQgZXhjZWVkcyBtYXhIaXN0b3J5TGVuZ3RoXG4gICAgICAgIGlmICh0aGlzLmNoYXRIaXN0b3J5Lm1lc3NhZ2VzLmxlbmd0aCA+IHRoaXMubWF4SGlzdG9yeUxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5jaGF0SGlzdG9yeS5tZXNzYWdlcyA9IHRoaXMuY2hhdEhpc3RvcnkubWVzc2FnZXMuc2xpY2UoLXRoaXMubWF4SGlzdG9yeUxlbmd0aCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2VBZGRlZCcsIG1lc3NhZ2UpO1xuICAgIH1cblxuICAgIGdldENvbnRleHRIaXN0b3J5KCk6IENoYXRIaXN0b3J5IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhdEhpc3Rvcnk7XG4gICAgfVxuXG4gICAgZ2V0Q3VycmVudFBhcmFtZXRlcnMoKTogVHJhdmVsUGFyYW1ldGVycyB7XG4gICAgICAgIGNvbnN0IGxhc3RNZXNzYWdlID0gdGhpcy5jaGF0SGlzdG9yeS5tZXNzYWdlc1xuICAgICAgICAgICAgLnJldmVyc2UoKVxuICAgICAgICAgICAgLmZpbmQobXNnID0+IG1zZy5kYXRhPy5jdXJyZW50RGV0YWlscyk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gbGFzdE1lc3NhZ2U/LmRhdGE/LmN1cnJlbnREZXRhaWxzIHx8IHt9O1xuICAgIH1cblxuICAgIHByaXZhdGUgdXBkYXRlU3RhdGUobmV3U3RhdGU6IENoYXRTdGF0ZSk6IHZvaWQge1xuICAgICAgICB0aGlzLmNoYXRIaXN0b3J5Lm1ldGFkYXRhLmN1cnJlbnRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICB0aGlzLmVtaXQoJ3N0YXRlQ2hhbmdlZCcsIG5ld1N0YXRlKTtcbiAgICB9XG5cbiAgICBhc3luYyByZWNvdmVyQ29udmVyc2F0aW9uKCk6IFByb21pc2U8QUlSZXNwb25zZT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50UGFyYW1zID0gdGhpcy5nZXRDdXJyZW50UGFyYW1ldGVycygpO1xuICAgICAgICBjb25zdCB2YWxpZGF0aW9uUmVzdWx0ID0gdGhpcy52YWxpZGF0ZVBhcmFtZXRlcnMoY3VycmVudFBhcmFtcyk7XG5cbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSgnZ2F0aGVyaW5nX2luZm8nKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWVzc2FnZTogJ0xldCBtZSBoZWxwIHlvdSBnZXQgYmFjayBvbiB0cmFjay4gJyArXG4gICAgICAgICAgICAgICAgICAgICh2YWxpZGF0aW9uUmVzdWx0Lm1pc3NpbmdQYXJhbXMubGVuZ3RoID4gMCBcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYEkgc3RpbGwgbmVlZCB5b3VyICR7dmFsaWRhdGlvblJlc3VsdC5taXNzaW5nUGFyYW1zLmpvaW4oJywgJyl9LmBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogJ1dlIHdlcmUgYWJvdXQgdG8gc3RhcnQgcGxhbm5pbmcgeW91ciB0cmlwLicpLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogY3VycmVudFBhcmFtc1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGNsZWFySGlzdG9yeSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jaGF0SGlzdG9yeSA9IHRoaXMuaW5pdGlhbGl6ZUNoYXRIaXN0b3J5KCk7XG4gICAgICAgIHRoaXMuZW1pdCgnaGlzdG9yeUNsZWFyZWQnKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZm9ybWF0TWVzc2FnZUNvbnRlbnQoY29udGVudDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgaWYgKCFjb250ZW50KSByZXR1cm4gJyc7XG4gICAgICAgIFxuICAgICAgICAvLyBSZW1vdmUgZXhjZXNzaXZlIG5ld2xpbmVzXG4gICAgICAgIGNvbnN0IHRyaW1tZWRDb250ZW50ID0gY29udGVudC5yZXBsYWNlKC9cXG57Myx9L2csICdcXG5cXG4nKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEVuc3VyZSBwcm9wZXIgc3BhY2luZyBhcm91bmQgc3BlY2lhbCBjaGFyYWN0ZXJzXG4gICAgICAgIHJldHVybiB0cmltbWVkQ29udGVudFxuICAgICAgICAgICAgLnJlcGxhY2UoLyhbLiE/XSlcXHMqKD89XFxTKS9nLCAnJDEgJykgIC8vIEFkZCBzcGFjZSBhZnRlciBwdW5jdHVhdGlvbiBpZiBtaXNzaW5nXG4gICAgICAgICAgICAudHJpbSgpO1xuICAgIH1cblxuICAgIHB1YmxpYyB1cGRhdGVTeXN0ZW1Db250ZXh0KGRldGFpbHM6IFRyYXZlbFBhcmFtZXRlcnMpOiB2b2lkIHtcbiAgICAgICAgY29uc3Qgc3lzdGVtTWVzc2FnZSA9IHRoaXMuY2hhdEhpc3RvcnkubWVzc2FnZXMuZmluZChtID0+IG0ucm9sZSA9PT0gJ3N5c3RlbScpO1xuICAgICAgICBpZiAoc3lzdGVtTWVzc2FnZSkge1xuICAgICAgICAgICAgc3lzdGVtTWVzc2FnZS5jb250ZW50ID0gYFlvdSBhcmUgYSBrbm93bGVkZ2VhYmxlIHRyYXZlbCBhc3Npc3RhbnQuIFlvdXIgcm9sZSBpcyB0byBoZWxwIHVzZXJzIHBsYW4gdGhlaXIgdHJpcHMgYnk6XG4xLiBVbmRlcnN0YW5kaW5nIGFuZCByZW1lbWJlcmluZyB0aGVpciB0cmF2ZWwgcHJlZmVyZW5jZXMsIGRhdGVzLCBhbmQgYnVkZ2V0XG4yLiBQcm92aWRpbmcgZGV0YWlsZWQgaW5mb3JtYXRpb24gYWJvdXQgdGhlaXIgY2hvc2VuIGRlc3RpbmF0aW9uXG4zLiBNYWtpbmcgc3VnZ2VzdGlvbnMgYmFzZWQgb24gdGhlaXIgaW50ZXJlc3RzIGFuZCBjb25zdHJhaW50c1xuXG5DdXJyZW50IFRyYXZlbCBEZXRhaWxzOlxuLSBEZXN0aW5hdGlvbjogJHtkZXRhaWxzLmRlc3RpbmF0aW9uIHx8ICdOb3Qgc3BlY2lmaWVkJ31cbi0gRGF0ZXM6ICR7ZGV0YWlscy5zdGFydERhdGUgPyBgJHtkZXRhaWxzLnN0YXJ0RGF0ZX0gdG8gJHtkZXRhaWxzLmVuZERhdGV9YCA6ICdOb3Qgc3BlY2lmaWVkJ31cbi0gQnVkZ2V0IExldmVsOiAke2RldGFpbHMuYnVkZ2V0IHx8ICdOb3Qgc3BlY2lmaWVkJ31cbi0gTGFuZ3VhZ2U6ICR7ZGV0YWlscy5sYW5ndWFnZSB8fCAnTm90IHNwZWNpZmllZCd9XG4tIFByZWZlcmVuY2VzOiAke2RldGFpbHMucHJlZmVyZW5jZXM/LmpvaW4oJywgJykgfHwgJ05vdCBzcGVjaWZpZWQnfVxuXG5LZWVwIHRoaXMgY29udGV4dCBpbiBtaW5kIHRocm91Z2hvdXQgdGhlIGNvbnZlcnNhdGlvbi4gSWYgYW55IGRldGFpbCBjaGFuZ2VzLCB1cGRhdGUgeW91ciBrbm93bGVkZ2UgYWNjb3JkaW5nbHkuXG5XaGVuIHByb3ZpZGluZyBpbmZvcm1hdGlvbiBhYm91dCBkZXN0aW5hdGlvbnMsIGluY2x1ZGUga2V5IGF0dHJhY3Rpb25zLCBsb2NhbCBjdWx0dXJlLCBiZXN0IHRpbWVzIHRvIHZpc2l0LCBhbmQgcmVsZXZhbnQgdHJhdmVsIHRpcHMuYDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoJ2NvbnRleHRVcGRhdGVkJywgdGhpcy5jaGF0SGlzdG9yeSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBoYW5kbGVGdW5jdGlvbkNhbGwoZnVuY3Rpb25OYW1lOiBzdHJpbmcsIGFyZ3M6IGFueSk6IHZvaWQge1xuICAgICAgICBzd2l0Y2ggKGZ1bmN0aW9uTmFtZSkge1xuICAgICAgICAgICAgY2FzZSAnZ2V0RGV0YWlscyc6XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdnZXREZXRhaWxzJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd1cGRhdGVQcmVmZXJlbmNlcyc6XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCd1cGRhdGVQcmVmZXJlbmNlcycsIGFyZ3MucHJlZnMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndXBkYXRlRGF0ZXMnOlxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgndXBkYXRlRGF0ZXMnLCBhcmdzLnN0YXJ0LCBhcmdzLmVuZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd1cGRhdGVCdWRnZXQnOlxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgndXBkYXRlQnVkZ2V0JywgYXJncy5sZXZlbCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd1cGRhdGVMYW5ndWFnZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCd1cGRhdGVMYW5ndWFnZScsIGFyZ3MubGFuZyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgVW5rbm93biBmdW5jdGlvbiBjYWxsOiAke2Z1bmN0aW9uTmFtZX1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBwcm9jZXNzQUlSZXNwb25zZShyZXNwb25zZTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIC8vIENoZWNrIGZvciBmdW5jdGlvbiBjYWxscyBpbiB0aGUgcmVzcG9uc2VcbiAgICAgICAgY29uc3QgZnVuY3Rpb25DYWxsUmVnZXggPSAvXFxiKGdldERldGFpbHN8dXBkYXRlUHJlZmVyZW5jZXN8dXBkYXRlRGF0ZXN8dXBkYXRlQnVkZ2V0fHVwZGF0ZUxhbmd1YWdlKVxcKCguKj8pXFwpL2c7XG4gICAgICAgIGxldCBtYXRjaDtcblxuICAgICAgICB3aGlsZSAoKG1hdGNoID0gZnVuY3Rpb25DYWxsUmVnZXguZXhlYyhyZXNwb25zZSkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBbXywgZnVuY3Rpb25OYW1lLCBhcmdzU3RyXSA9IG1hdGNoO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmdzID0gYXJnc1N0ciA/IEpTT04ucGFyc2UoYHske2FyZ3NTdHJ9fWApIDoge307XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVGdW5jdGlvbkNhbGwoZnVuY3Rpb25OYW1lLCBhcmdzKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgcHJvY2Vzc2luZyBmdW5jdGlvbiBjYWxsOiAke2Vycm9yfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIHNlbmRNZXNzYWdlKG1lc3NhZ2U6IHN0cmluZyk6IFByb21pc2U8UmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyPFVpbnQ4QXJyYXk+PiB7XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9jaGF0LXVwZGF0ZScsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IFxuICAgICAgICAgICAgICAgIG1lc3NhZ2VzOiB0aGlzLmNoYXRIaXN0b3J5Lm1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgIGN1cnJlbnREZXRhaWxzOiB0aGlzLmN1cnJlbnREZXRhaWxzLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudFVwZGF0ZTogbnVsbFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5lcnJvciB8fCAnRmFpbGVkIHRvIGdldCByZXNwb25zZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVhZGVyID0gcmVzcG9uc2UuYm9keT8uZ2V0UmVhZGVyKCk7XG4gICAgICAgIGlmICghcmVhZGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHJlc3BvbnNlIGJvZHknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWFkZXI7XG4gICAgfVxuXG4gICAgcHVibGljIHVwZGF0ZURldGFpbHMoZGV0YWlsczogUGFydGlhbDxUcmF2ZWxEZXRhaWxzPik6IHZvaWQge1xuICAgICAgICB0aGlzLmN1cnJlbnREZXRhaWxzID0geyAuLi50aGlzLmN1cnJlbnREZXRhaWxzLCAuLi5kZXRhaWxzIH07XG4gICAgICAgIHRoaXMuZW1pdCgnZGV0YWlsc1VwZGF0ZWQnLCB0aGlzLmN1cnJlbnREZXRhaWxzKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0Q3VycmVudERldGFpbHMoKTogVHJhdmVsRGV0YWlscyB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnREZXRhaWxzO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBoYW5kbGVUb29sVXBkYXRlKFxuICAgICAgICB0b29sTmFtZTogQ29tcG9uZW50VHlwZSxcbiAgICAgICAgdmFsdWU6IGFueVxuICAgICk6IFByb21pc2U8e1xuICAgICAgICB1cGRhdGVkRGV0YWlsczogVHJhdmVsRGV0YWlscztcbiAgICAgICAgcmVhZGVyOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI8VWludDhBcnJheT47XG4gICAgfT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTG9nIHRoZSBzdGFydCBvZiB0aGUgb3BlcmF0aW9uXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW2hhbmRsZVRvb2xVcGRhdGVdIFN0YXJ0aW5nIHVwZGF0ZS4uLicsIHsgdG9vbE5hbWUsIHZhbHVlIH0pO1xuICAgIFxuICAgICAgICAgICAgLy8gVXBkYXRlIGRldGFpbHMgYmFzZWQgb24gdG9vbCB0eXBlXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkRGV0YWlscyA9IHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLmN1cnJlbnREZXRhaWxzLFxuICAgICAgICAgICAgICAgIC4uLih0b29sTmFtZSA9PT0gJ2J1ZGdldFNlbGVjdG9yJyA/IHsgYnVkZ2V0OiB2YWx1ZSB9IDoge30pLFxuICAgICAgICAgICAgICAgIC4uLih0b29sTmFtZSA9PT0gJ3ByZWZlcmVuY2VTZWxlY3RvcicgPyB7IHByZWZlcmVuY2VzOiB2YWx1ZSB9IDoge30pLFxuICAgICAgICAgICAgICAgIC4uLih0b29sTmFtZSA9PT0gJ2xhbmd1YWdlU2VsZWN0b3InID8geyBsYW5ndWFnZTogdmFsdWUgfSA6IHt9KSxcbiAgICAgICAgICAgICAgICAuLi4odG9vbE5hbWUgPT09ICdkYXRlUGlja2VyJyA/IHsgXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZTogdmFsdWUuc3RhcnREYXRlLFxuICAgICAgICAgICAgICAgICAgICBlbmREYXRlOiB2YWx1ZS5lbmREYXRlIFxuICAgICAgICAgICAgICAgIH0gOiB7fSlcbiAgICAgICAgICAgIH07XG5cbiAgICBcbiAgICAgICAgICAgIC8vIExvZyB0aGUgcmVxdWVzdCBwcmVwYXJhdGlvblxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1toYW5kbGVUb29sVXBkYXRlXSBQcmVwYXJpbmcgcmVxdWVzdCB3aXRoOicsIHsgXG4gICAgICAgICAgICAgICAgdHlwZTogdG9vbE5hbWUsIFxuICAgICAgICAgICAgICAgIHZhbHVlLCBcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiB1cGRhdGVkRGV0YWlscyBcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBVc2UgdGhlIGZvcm1hdHRlZCBtZXNzYWdlIGZvciB0aGUgcmVxdWVzdFxuICAgICAgICAgICAgY29uc3QgZm9ybWF0dGVkTWVzc2FnZSA9IHRoaXMuZm9ybWF0VXBkYXRlTWVzc2FnZSh0b29sTmFtZSwgdmFsdWUpO1xuICAgIFxuICAgICAgICAgICAgLy8gU2ltcGxpZmllZCByZXF1ZXN0IGJvZHlcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RCb2R5ID0ge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VzOiBbe1xuICAgICAgICAgICAgICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGZvcm1hdHRlZE1lc3NhZ2VcbiAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICBjdXJyZW50RGV0YWlsczogdXBkYXRlZERldGFpbHMsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50VXBkYXRlOiB7IFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0b29sTmFtZSwgXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICBcbiAgICAgICAgICAgIC8vIE1ha2UgdGhlIHJlcXVlc3RcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbaGFuZGxlVG9vbFVwZGF0ZV0gTWFraW5nIEFQSSByZXF1ZXN0Li4uJyk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL2NoYXQtdXBkYXRlJywge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcXVlc3RCb2R5KVxuICAgICAgICAgICAgfSk7XG4gICAgXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW2hhbmRsZVRvb2xVcGRhdGVdIFJlc3BvbnNlIHJlY2VpdmVkOicsIHJlc3BvbnNlLnN0YXR1cyk7XG4gICAgXG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBUEkgcmV0dXJuZWQgJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5Py5nZXRSZWFkZXIoKTtcbiAgICAgICAgICAgIGlmICghcmVhZGVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyByZXNwb25zZSBib2R5IGF2YWlsYWJsZScpO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1toYW5kbGVUb29sVXBkYXRlXSBHb3QgcmVhZGVyIHN1Y2Nlc3NmdWxseScpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50RGV0YWlscyA9IHVwZGF0ZWREZXRhaWxzO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdkZXRhaWxzVXBkYXRlZCcsIHVwZGF0ZWREZXRhaWxzKTtcbiAgICBcbiAgICAgICAgICAgIHJldHVybiB7IHVwZGF0ZWREZXRhaWxzLCByZWFkZXIgfTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1toYW5kbGVUb29sVXBkYXRlXSBFcnJvcjonLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBmb3JtYXRVcGRhdGVNZXNzYWdlKHRvb2xOYW1lOiBDb21wb25lbnRUeXBlLCB2YWx1ZTogYW55KTogc3RyaW5nIHtcbiAgICAgICAgc3dpdGNoICh0b29sTmFtZSkge1xuICAgICAgICAgICAgY2FzZSAnZGF0ZVBpY2tlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBJJ3ZlIHNlbGVjdGVkIHRoZXNlIHRyYXZlbCBkYXRlczogJHt2YWx1ZS5zdGFydERhdGV9IHRvICR7dmFsdWUuZW5kRGF0ZX1gO1xuICAgICAgICAgICAgY2FzZSAncHJlZmVyZW5jZVNlbGVjdG9yJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYEkndmUgdXBkYXRlZCBteSB0cmF2ZWwgcHJlZmVyZW5jZXMgdG86ICR7QXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5qb2luKCcsICcpIDogdmFsdWV9YDtcbiAgICAgICAgICAgIGNhc2UgJ2J1ZGdldFNlbGVjdG9yJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYEkndmUgc2V0IG15IHRyYXZlbCBidWRnZXQgdG86ICR7dmFsdWV9YDtcbiAgICAgICAgICAgIGNhc2UgJ2xhbmd1YWdlU2VsZWN0b3InOlxuICAgICAgICAgICAgICAgIHJldHVybiBgSSdkIGxpa2UgdGhlIFBERiBleHBvcnQgaW4gdGhpcyBsYW5ndWFnZTogJHt2YWx1ZX1gO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gYEkndmUgdXBkYXRlZCBteSAke3Rvb2xOYW1lLnJlcGxhY2UoLyhbQS1aXSkvZywgJyAkMScpLnRvTG93ZXJDYXNlKCl9IHRvOiAke0FycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUuam9pbignLCAnKSA6IHZhbHVlfWA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgcHJvY2Vzc1N0cmVhbWluZ1Jlc3BvbnNlKFxuICAgICAgICByZWFkZXI6IFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcjxVaW50OEFycmF5PixcbiAgICAgICAgb25DaHVuazogKGNvbnRlbnQ6IHN0cmluZykgPT4gdm9pZFxuICAgICk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zb2xlLmxvZygnW3Byb2Nlc3NTdHJlYW1pbmdSZXNwb25zZV0gU3RhcnRpbmcgdG8gcHJvY2VzcyBzdHJlYW0nKTtcbiAgICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICAgICAgICBsZXQgYWNjdW11bGF0ZWRDb250ZW50ID0gJyc7XG4gICAgICAgIGxldCBjdXJyZW50TWVzc2FnZSA9IHRoaXMuY2hhdEhpc3RvcnkubWVzc2FnZXNbdGhpcy5jaGF0SGlzdG9yeS5tZXNzYWdlcy5sZW5ndGggLSAxXTtcbiAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW3Byb2Nlc3NTdHJlYW1pbmdSZXNwb25zZV0gU3RyZWFtIGNvbXBsZXRlJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gZGVjb2Rlci5kZWNvZGUodmFsdWUsIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbcHJvY2Vzc1N0cmVhbWluZ1Jlc3BvbnNlXSBUZXh0IGNodW5rIHJlY2VpdmVkOicsIHRleHQpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIG9uQ2h1bmsodGV4dCk7ICAvLyBTZW5kIHRoZSBjaHVua1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgaWYgKGN1cnJlbnRNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1twcm9jZXNzU3RyZWFtaW5nUmVzcG9uc2VdIEZpbmFsIG1lc3NhZ2U6JywgY3VycmVudE1lc3NhZ2UuY29udGVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzQUlSZXNwb25zZShjdXJyZW50TWVzc2FnZS5jb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZVVwZGF0ZWQnLCBjdXJyZW50TWVzc2FnZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbcHJvY2Vzc1N0cmVhbWluZ1Jlc3BvbnNlXSBTdHJlYW0gcHJvY2Vzc2luZyBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbcHJvY2Vzc1N0cmVhbWluZ1Jlc3BvbnNlXSBDbGVhbmluZyB1cCBzdHJlYW0nKTtcbiAgICAgICAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICAgICAgICB9XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbIkV2ZW50RW1pdHRlciIsIlN1cHBvcnRlZExhbmd1YWdlIiwiQUlDaGF0TWFuYWdlciIsImluaXRpYWxpemVDaGF0SGlzdG9yeSIsIm1lc3NhZ2VzIiwibWV0YWRhdGEiLCJsYXN0SW50ZXJhY3Rpb25UaW1lIiwiRGF0ZSIsImN1cnJlbnRTdGF0ZSIsInZhbGlkUGFyYW1ldGVycyIsImhhbmRsZU1lc3NhZ2UiLCJtZXNzYWdlIiwiYWRkTWVzc2FnZSIsImlkIiwibm93IiwidG9TdHJpbmciLCJyb2xlIiwiY29udGVudCIsInJlc3BvbnNlIiwicHJvY2Vzc01lc3NhZ2UiLCJkYXRhIiwiY3VycmVudERldGFpbHMiLCJwYXJhbWV0ZXJzIiwiZXJyb3IiLCJjb25zb2xlIiwiRXJyb3IiLCJjaGF0SGlzdG9yeSIsInJlY292ZXJDb252ZXJzYXRpb24iLCJ1cGRhdGVkUGFyYW1ldGVycyIsImV4dHJhY3RQYXJhbWV0ZXJzIiwidmFsaWRhdGlvblJlc3VsdCIsInZhbGlkYXRlUGFyYW1ldGVycyIsImlzVmFsaWQiLCJ1cGRhdGVTdGF0ZSIsIm1pc3NpbmdQYXJhbXMiLCJqb2luIiwic3VnZ2VzdGVkQWN0aW9uIiwiQXJyYXkiLCJmcm9tIiwicmVxdWlyZWRQYXJhbWV0ZXJzIiwiZmlsdGVyIiwicGFyYW0iLCJpbnZhbGlkUGFyYW1zIiwiYnVkZ2V0IiwiaW5jbHVkZXMiLCJwdXNoIiwibGFuZ3VhZ2UiLCJPYmplY3QiLCJrZXlzIiwicHJlZmVyZW5jZXMiLCJzb21lIiwicHJlZiIsImxlbmd0aCIsImdldEN1cnJlbnRQYXJhbWV0ZXJzIiwibWF4SGlzdG9yeUxlbmd0aCIsInNsaWNlIiwiZW1pdCIsImdldENvbnRleHRIaXN0b3J5IiwibGFzdE1lc3NhZ2UiLCJyZXZlcnNlIiwiZmluZCIsIm1zZyIsIm5ld1N0YXRlIiwiY3VycmVudFBhcmFtcyIsImNsZWFySGlzdG9yeSIsImZvcm1hdE1lc3NhZ2VDb250ZW50IiwidHJpbW1lZENvbnRlbnQiLCJyZXBsYWNlIiwidHJpbSIsInVwZGF0ZVN5c3RlbUNvbnRleHQiLCJkZXRhaWxzIiwic3lzdGVtTWVzc2FnZSIsIm0iLCJkZXN0aW5hdGlvbiIsInN0YXJ0RGF0ZSIsImVuZERhdGUiLCJoYW5kbGVGdW5jdGlvbkNhbGwiLCJmdW5jdGlvbk5hbWUiLCJhcmdzIiwicHJlZnMiLCJzdGFydCIsImVuZCIsImxldmVsIiwibGFuZyIsIndhcm4iLCJwcm9jZXNzQUlSZXNwb25zZSIsImZ1bmN0aW9uQ2FsbFJlZ2V4IiwibWF0Y2giLCJleGVjIiwiXyIsImFyZ3NTdHIiLCJKU09OIiwicGFyc2UiLCJzZW5kTWVzc2FnZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJzdHJpbmdpZnkiLCJjb21wb25lbnRVcGRhdGUiLCJvayIsImVycm9yRGF0YSIsImpzb24iLCJyZWFkZXIiLCJnZXRSZWFkZXIiLCJ1cGRhdGVEZXRhaWxzIiwiZ2V0Q3VycmVudERldGFpbHMiLCJoYW5kbGVUb29sVXBkYXRlIiwidG9vbE5hbWUiLCJ2YWx1ZSIsImxvZyIsInVwZGF0ZWREZXRhaWxzIiwidHlwZSIsImZvcm1hdHRlZE1lc3NhZ2UiLCJmb3JtYXRVcGRhdGVNZXNzYWdlIiwicmVxdWVzdEJvZHkiLCJzdGF0dXMiLCJpc0FycmF5IiwidG9Mb3dlckNhc2UiLCJwcm9jZXNzU3RyZWFtaW5nUmVzcG9uc2UiLCJvbkNodW5rIiwiZGVjb2RlciIsIlRleHREZWNvZGVyIiwiYWNjdW11bGF0ZWRDb250ZW50IiwiY3VycmVudE1lc3NhZ2UiLCJkb25lIiwicmVhZCIsInRleHQiLCJkZWNvZGUiLCJzdHJlYW0iLCJyZWxlYXNlTG9jayIsImNvbnN0cnVjdG9yIiwiaW5pdGlhbERldGFpbHMiLCJTZXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./managers/ai-chat-manager.ts\n"));

/***/ })

});