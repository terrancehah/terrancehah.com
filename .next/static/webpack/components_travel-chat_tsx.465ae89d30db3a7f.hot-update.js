"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("components_travel-chat_tsx",{

/***/ "./managers/ai-chat-manager.ts":
/*!*************************************!*\
  !*** ./managers/ai-chat-manager.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AIChatManager: function() { return /* binding */ AIChatManager; }\n/* harmony export */ });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"./node_modules/next/dist/compiled/events/events.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ \"./managers/types.ts\");\n\n\nclass AIChatManager extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    initializeChatHistory() {\n        return {\n            messages: [],\n            metadata: {\n                lastInteractionTime: new Date(),\n                currentState: \"initial\",\n                validParameters: []\n            }\n        };\n    }\n    async handleMessage(message) {\n        try {\n            // Add user message to history\n            this.addMessage({\n                id: Date.now().toString(),\n                role: \"user\",\n                content: message\n            });\n            // Process message and update parameters\n            const response = await this.processMessage(message);\n            // Add AI response to history\n            this.addMessage({\n                id: (Date.now() + 1).toString(),\n                role: \"assistant\",\n                content: response.message,\n                data: {\n                    currentDetails: response.parameters\n                }\n            });\n            return response;\n        } catch (error) {\n            console.error(\"Error handling message:\", error);\n            return {\n                message: \"I encountered an error processing your message. Let's continue from where we left off.\",\n                error: error instanceof Error ? error.message : \"Unknown error\"\n            };\n        }\n    }\n    async processMessage(message) {\n        const currentState = this.chatHistory.metadata.currentState;\n        if (currentState === \"interrupted\") {\n            return this.recoverConversation();\n        }\n        // Update state based on message content and current parameters\n        const updatedParameters = await this.extractParameters(message);\n        const validationResult = this.validateParameters(updatedParameters);\n        if (validationResult.isValid) {\n            this.updateState(\"planning\");\n            return {\n                message: \"Great! I have all the information needed. Let me plan your trip.\",\n                parameters: updatedParameters\n            };\n        }\n        return {\n            message: \"Could you please provide your \".concat(validationResult.missingParams.join(\", \"), \"?\"),\n            parameters: updatedParameters,\n            suggestedAction: \"gather_info\"\n        };\n    }\n    validateParameters(parameters) {\n        var _parameters_preferences;\n        const missingParams = Array.from(this.requiredParameters).filter((param)=>!parameters[param]);\n        const invalidParams = [];\n        // Validate budget format\n        if (parameters.budget && ![\n            \"$\",\n            \"$$\",\n            \"$$$\",\n            \"$$$$\"\n        ].includes(parameters.budget)) {\n            invalidParams.push(\"budget\");\n        }\n        // Validate language\n        if (parameters.language && !Object.keys(_types__WEBPACK_IMPORTED_MODULE_1__.SupportedLanguage).includes(parameters.language)) {\n            invalidParams.push(\"language\");\n        }\n        // Validate preferences\n        if ((_parameters_preferences = parameters.preferences) === null || _parameters_preferences === void 0 ? void 0 : _parameters_preferences.some((pref)=>![\n                \"Culture and Heritage\",\n                \"Nature\",\n                \"Foodie\",\n                \"Leisure\",\n                \"Adventure\",\n                \"Arts and Museums\"\n            ].includes(pref))) {\n            invalidParams.push(\"preferences\");\n        }\n        return {\n            isValid: missingParams.length === 0 && invalidParams.length === 0,\n            missingParams,\n            invalidParams\n        };\n    }\n    async extractParameters(message) {\n        // Implement NLP or pattern matching logic to extract parameters\n        // For now, return current parameters\n        const currentDetails = this.getCurrentParameters();\n        return {\n            ...currentDetails\n        };\n    }\n    addMessage(message) {\n        this.chatHistory.messages.push(message);\n        this.chatHistory.metadata.lastInteractionTime = new Date();\n        // Trim history if it exceeds maxHistoryLength\n        if (this.chatHistory.messages.length > this.maxHistoryLength) {\n            this.chatHistory.messages = this.chatHistory.messages.slice(-this.maxHistoryLength);\n        }\n        this.emit(\"messageAdded\", message);\n    }\n    getContextHistory() {\n        return this.chatHistory;\n    }\n    getCurrentParameters() {\n        var _lastMessage_data;\n        const lastMessage = this.chatHistory.messages.reverse().find((msg)=>{\n            var _msg_data;\n            return (_msg_data = msg.data) === null || _msg_data === void 0 ? void 0 : _msg_data.currentDetails;\n        });\n        return (lastMessage === null || lastMessage === void 0 ? void 0 : (_lastMessage_data = lastMessage.data) === null || _lastMessage_data === void 0 ? void 0 : _lastMessage_data.currentDetails) || {};\n    }\n    updateState(newState) {\n        this.chatHistory.metadata.currentState = newState;\n        this.emit(\"stateChanged\", newState);\n    }\n    async recoverConversation() {\n        const currentParams = this.getCurrentParameters();\n        const validationResult = this.validateParameters(currentParams);\n        this.updateState(\"gathering_info\");\n        return {\n            message: \"Let me help you get back on track. \" + (validationResult.missingParams.length > 0 ? \"I still need your \".concat(validationResult.missingParams.join(\", \"), \".\") : \"We were about to start planning your trip.\"),\n            parameters: currentParams\n        };\n    }\n    clearHistory() {\n        this.chatHistory = this.initializeChatHistory();\n        this.emit(\"historyCleared\");\n    }\n    formatMessageContent(content) {\n        if (!content) return \"\";\n        // Remove excessive newlines\n        const trimmedContent = content.replace(/\\n{3,}/g, \"\\n\\n\");\n        // Ensure proper spacing around special characters\n        return trimmedContent.replace(/([.!?])\\s*(?=\\S)/g, \"$1 \") // Add space after punctuation if missing\n        .trim();\n    }\n    updateSystemContext(details) {\n        const systemMessage = this.chatHistory.messages.find((m)=>m.role === \"system\");\n        if (systemMessage) {\n            var _details_preferences;\n            systemMessage.content = \"You are a knowledgeable travel assistant. Your role is to help users plan their trips by:\\n1. Understanding and remembering their travel preferences, dates, and budget\\n2. Providing detailed information about their chosen destination\\n3. Making suggestions based on their interests and constraints\\n\\nCurrent Travel Details:\\n- Destination: \".concat(details.destination || \"Not specified\", \"\\n- Dates: \").concat(details.startDate ? \"\".concat(details.startDate, \" to \").concat(details.endDate) : \"Not specified\", \"\\n- Budget Level: \").concat(details.budget || \"Not specified\", \"\\n- Language: \").concat(details.language || \"Not specified\", \"\\n- Preferences: \").concat(((_details_preferences = details.preferences) === null || _details_preferences === void 0 ? void 0 : _details_preferences.join(\", \")) || \"Not specified\", \"\\n\\nKeep this context in mind throughout the conversation. If any detail changes, update your knowledge accordingly.\\nWhen providing information about destinations, include key attractions, local culture, best times to visit, and relevant travel tips.\");\n        }\n        this.emit(\"contextUpdated\", this.chatHistory);\n    }\n    handleFunctionCall(functionName, args) {\n        switch(functionName){\n            case \"getDetails\":\n                this.emit(\"getDetails\");\n                break;\n            case \"updatePreferences\":\n                this.emit(\"updatePreferences\", args.prefs);\n                break;\n            case \"updateDates\":\n                this.emit(\"updateDates\", args.start, args.end);\n                break;\n            case \"updateBudget\":\n                this.emit(\"updateBudget\", args.level);\n                break;\n            case \"updateLanguage\":\n                this.emit(\"updateLanguage\", args.lang);\n                break;\n            default:\n                console.warn(\"Unknown function call: \".concat(functionName));\n        }\n    }\n    processAIResponse(response) {\n        // Check for function calls in the response\n        const functionCallRegex = /\\b(getDetails|updatePreferences|updateDates|updateBudget|updateLanguage)\\((.*?)\\)/g;\n        let match;\n        while((match = functionCallRegex.exec(response)) !== null){\n            const [_, functionName, argsStr] = match;\n            try {\n                const args = argsStr ? JSON.parse(\"{\".concat(argsStr, \"}\")) : {};\n                this.handleFunctionCall(functionName, args);\n            } catch (error) {\n                console.error(\"Error processing function call: \".concat(error));\n            }\n        }\n    }\n    async sendMessage(message) {\n        var _response_body;\n        const response = await fetch(\"/api/chat-update\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                messages: this.chatHistory.messages,\n                currentDetails: this.currentDetails,\n                componentUpdate: null\n            })\n        });\n        if (!response.ok) {\n            const errorData = await response.json();\n            throw new Error(errorData.error || \"Failed to get response\");\n        }\n        const reader = (_response_body = response.body) === null || _response_body === void 0 ? void 0 : _response_body.getReader();\n        if (!reader) {\n            throw new Error(\"No response body\");\n        }\n        return reader;\n    }\n    updateDetails(details) {\n        this.currentDetails = {\n            ...this.currentDetails,\n            ...details\n        };\n        this.emit(\"detailsUpdated\", this.currentDetails);\n    }\n    getCurrentDetails() {\n        return this.currentDetails;\n    }\n    async handleToolUpdate(toolName, value) {\n        try {\n            var _response_body;\n            // Log the start of the operation\n            console.log(\"[handleToolUpdate] Starting update...\", {\n                toolName,\n                value\n            });\n            // Update details based on tool type\n            const updatedDetails = {\n                ...this.currentDetails,\n                ...toolName === \"budgetSelector\" ? {\n                    budget: value\n                } : {},\n                ...toolName === \"preferenceSelector\" ? {\n                    preferences: value\n                } : {},\n                ...toolName === \"languageSelector\" ? {\n                    language: value\n                } : {},\n                ...toolName === \"datePicker\" ? {\n                    startDate: value.startDate,\n                    endDate: value.endDate\n                } : {}\n            };\n            // Log the request preparation\n            console.log(\"[handleToolUpdate] Preparing request with:\", {\n                type: toolName,\n                value,\n                details: updatedDetails\n            });\n            // Simplified request body\n            const requestBody = {\n                messages: [\n                    {\n                        role: \"user\",\n                        content: \"I've set my travel budget to: \".concat(value)\n                    }\n                ],\n                currentDetails: updatedDetails,\n                componentUpdate: {\n                    type: toolName,\n                    value\n                }\n            };\n            // Make the request\n            console.log(\"[handleToolUpdate] Making API request...\");\n            const response = await fetch(\"/api/chat-update\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify(requestBody)\n            });\n            console.log(\"[handleToolUpdate] Response received:\", response.status);\n            if (!response.ok) {\n                throw new Error(\"API returned \".concat(response.status));\n            }\n            const reader = (_response_body = response.body) === null || _response_body === void 0 ? void 0 : _response_body.getReader();\n            if (!reader) {\n                throw new Error(\"No response body available\");\n            }\n            console.log(\"[handleToolUpdate] Got reader successfully\");\n            this.currentDetails = updatedDetails;\n            this.emit(\"detailsUpdated\", updatedDetails);\n            return {\n                updatedDetails,\n                reader\n            };\n        } catch (error) {\n            console.error(\"[handleToolUpdate] Error:\", error);\n            throw error;\n        }\n    }\n    formatUpdateMessage(toolName, value) {\n        switch(toolName){\n            case \"datePicker\":\n                return \"I've selected these travel dates: \".concat(value.startDate, \" to \").concat(value.endDate);\n            case \"preferenceSelector\":\n                return \"I've updated my travel preferences to: \".concat(Array.isArray(value) ? value.join(\", \") : value);\n            case \"budgetSelector\":\n                return \"I've set my travel budget to: \".concat(value);\n            case \"languageSelector\":\n                return \"I'd like the PDF export in this language: \".concat(value);\n            default:\n                return \"I've updated my \".concat(toolName.replace(/([A-Z])/g, \" $1\").toLowerCase(), \" to: \").concat(Array.isArray(value) ? value.join(\", \") : value);\n        }\n    }\n    async processStreamingResponse(reader, onChunk) {\n        console.log(\"[processStreamingResponse] Starting to process stream\");\n        const decoder = new TextDecoder();\n        let currentMessage = this.chatHistory.messages[this.chatHistory.messages.length - 1];\n        try {\n            while(true){\n                console.log(\"[processStreamingResponse] Reading chunk...\");\n                const { done, value } = await reader.read();\n                if (done) {\n                    console.log(\"[processStreamingResponse] Stream complete\");\n                    break;\n                }\n                // Directly decode and use the chunk\n                const text = decoder.decode(value, {\n                    stream: true\n                });\n                console.log(\"[processStreamingResponse] Text chunk received:\", text);\n                // Update message content\n                if (currentMessage) {\n                    currentMessage.content += text;\n                }\n                // Call the chunk handler\n                onChunk(text);\n            }\n            // Process any function calls in the complete message\n            if (currentMessage) {\n                console.log(\"[processStreamingResponse] Final message:\", currentMessage.content);\n                this.processAIResponse(currentMessage.content);\n            }\n            this.emit(\"messageUpdated\", currentMessage);\n        } catch (error) {\n            console.error(\"[processStreamingResponse] Stream processing error:\", error);\n            throw error;\n        } finally{\n            console.log(\"[processStreamingResponse] Cleaning up stream\");\n            reader.releaseLock();\n        }\n    }\n    constructor(initialDetails){\n        super();\n        this.chatHistory = this.initializeChatHistory();\n        this.currentDetails = initialDetails;\n        this.requiredParameters = new Set([\n            \"destination\",\n            \"startDate\",\n            \"endDate\",\n            \"budget\",\n            \"language\"\n        ]);\n        this.maxHistoryLength = 50;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RyxXQUFXLEdBQUcsSUFBSSxDQUFDdkIscUJBQXFCO1FBQzdDLElBQUksQ0FBQ2tCLGNBQWMsR0FBRzZHO1FBQ3RCLElBQUksQ0FBQzNGLGtCQUFrQixHQUFHLElBQUk0RixJQUFJO1lBQzlCO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7U0FDSDtRQUNELElBQUksQ0FBQzdFLGdCQUFnQixHQUFHO0lBQzVCO0FBa1pKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL21hbmFnZXJzL2FpLWNoYXQtbWFuYWdlci50cz9jNjJhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgeyBcbiAgICBDaGF0SGlzdG9yeSwgXG4gICAgQ2hhdE1lc3NhZ2UsIFxuICAgIENoYXRTdGF0ZSwgXG4gICAgVHJhdmVsUGFyYW1ldGVycyxcbiAgICBBSVJlc3BvbnNlLFxuICAgIE1lc3NhZ2VEYXRhLFxuICAgIEJ1ZGdldExldmVsLFxuICAgIFRyYXZlbFByZWZlcmVuY2UsXG4gICAgU3VwcG9ydGVkTGFuZ3VhZ2UsXG4gICAgVHJhdmVsRGV0YWlscyxcbiAgICBDb21wb25lbnRUeXBlXG59IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgY2xhc3MgQUlDaGF0TWFuYWdlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gICAgcHJpdmF0ZSBjaGF0SGlzdG9yeTogQ2hhdEhpc3Rvcnk7XG4gICAgcHJpdmF0ZSByZXF1aXJlZFBhcmFtZXRlcnM6IFNldDxzdHJpbmc+O1xuICAgIHByaXZhdGUgbWF4SGlzdG9yeUxlbmd0aDogbnVtYmVyO1xuICAgIHByaXZhdGUgY3VycmVudERldGFpbHM6IFRyYXZlbERldGFpbHM7XG5cbiAgICBjb25zdHJ1Y3Rvcihpbml0aWFsRGV0YWlsczogVHJhdmVsRGV0YWlscykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNoYXRIaXN0b3J5ID0gdGhpcy5pbml0aWFsaXplQ2hhdEhpc3RvcnkoKTtcbiAgICAgICAgdGhpcy5jdXJyZW50RGV0YWlscyA9IGluaXRpYWxEZXRhaWxzO1xuICAgICAgICB0aGlzLnJlcXVpcmVkUGFyYW1ldGVycyA9IG5ldyBTZXQoW1xuICAgICAgICAgICAgJ2Rlc3RpbmF0aW9uJyxcbiAgICAgICAgICAgICdzdGFydERhdGUnLFxuICAgICAgICAgICAgJ2VuZERhdGUnLFxuICAgICAgICAgICAgJ2J1ZGdldCcsXG4gICAgICAgICAgICAnbGFuZ3VhZ2UnXG4gICAgICAgIF0pO1xuICAgICAgICB0aGlzLm1heEhpc3RvcnlMZW5ndGggPSA1MDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGluaXRpYWxpemVDaGF0SGlzdG9yeSgpOiBDaGF0SGlzdG9yeSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZXNzYWdlczogW10sXG4gICAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgICAgIGxhc3RJbnRlcmFjdGlvblRpbWU6IG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgICAgY3VycmVudFN0YXRlOiAnaW5pdGlhbCcsXG4gICAgICAgICAgICAgICAgdmFsaWRQYXJhbWV0ZXJzOiBbXVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGhhbmRsZU1lc3NhZ2UobWVzc2FnZTogc3RyaW5nKTogUHJvbWlzZTxBSVJlc3BvbnNlPiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBBZGQgdXNlciBtZXNzYWdlIHRvIGhpc3RvcnlcbiAgICAgICAgICAgIHRoaXMuYWRkTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgaWQ6IERhdGUubm93KCkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgICAgICAgICAgY29udGVudDogbWVzc2FnZVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFByb2Nlc3MgbWVzc2FnZSBhbmQgdXBkYXRlIHBhcmFtZXRlcnNcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcm9jZXNzTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQWRkIEFJIHJlc3BvbnNlIHRvIGhpc3RvcnlcbiAgICAgICAgICAgIHRoaXMuYWRkTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgaWQ6IChEYXRlLm5vdygpICsgMSkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICByb2xlOiAnYXNzaXN0YW50JyxcbiAgICAgICAgICAgICAgICBjb250ZW50OiByZXNwb25zZS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudERldGFpbHM6IHJlc3BvbnNlLnBhcmFtZXRlcnNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaGFuZGxpbmcgbWVzc2FnZTonLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdJIGVuY291bnRlcmVkIGFuIGVycm9yIHByb2Nlc3NpbmcgeW91ciBtZXNzYWdlLiBMZXRcXCdzIGNvbnRpbnVlIGZyb20gd2hlcmUgd2UgbGVmdCBvZmYuJyxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcidcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIHByb2Nlc3NNZXNzYWdlKG1lc3NhZ2U6IHN0cmluZyk6IFByb21pc2U8QUlSZXNwb25zZT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50U3RhdGUgPSB0aGlzLmNoYXRIaXN0b3J5Lm1ldGFkYXRhLmN1cnJlbnRTdGF0ZTtcbiAgICAgICAgXG4gICAgICAgIGlmIChjdXJyZW50U3RhdGUgPT09ICdpbnRlcnJ1cHRlZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlY292ZXJDb252ZXJzYXRpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSBzdGF0ZSBiYXNlZCBvbiBtZXNzYWdlIGNvbnRlbnQgYW5kIGN1cnJlbnQgcGFyYW1ldGVyc1xuICAgICAgICBjb25zdCB1cGRhdGVkUGFyYW1ldGVycyA9IGF3YWl0IHRoaXMuZXh0cmFjdFBhcmFtZXRlcnMobWVzc2FnZSk7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRpb25SZXN1bHQgPSB0aGlzLnZhbGlkYXRlUGFyYW1ldGVycyh1cGRhdGVkUGFyYW1ldGVycyk7XG5cbiAgICAgICAgaWYgKHZhbGlkYXRpb25SZXN1bHQuaXNWYWxpZCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSgncGxhbm5pbmcnKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ0dyZWF0ISBJIGhhdmUgYWxsIHRoZSBpbmZvcm1hdGlvbiBuZWVkZWQuIExldCBtZSBwbGFuIHlvdXIgdHJpcC4nLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHVwZGF0ZWRQYXJhbWV0ZXJzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBDb3VsZCB5b3UgcGxlYXNlIHByb3ZpZGUgeW91ciAke3ZhbGlkYXRpb25SZXN1bHQubWlzc2luZ1BhcmFtcy5qb2luKCcsICcpfT9gLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogdXBkYXRlZFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBzdWdnZXN0ZWRBY3Rpb246ICdnYXRoZXJfaW5mbydcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHZhbGlkYXRlUGFyYW1ldGVycyhwYXJhbWV0ZXJzOiBUcmF2ZWxQYXJhbWV0ZXJzKTogeyBcbiAgICAgICAgaXNWYWxpZDogYm9vbGVhbjsgXG4gICAgICAgIG1pc3NpbmdQYXJhbXM6IHN0cmluZ1tdO1xuICAgICAgICBpbnZhbGlkUGFyYW1zOiBzdHJpbmdbXTtcbiAgICB9IHtcbiAgICAgICAgY29uc3QgbWlzc2luZ1BhcmFtcyA9IEFycmF5LmZyb20odGhpcy5yZXF1aXJlZFBhcmFtZXRlcnMpXG4gICAgICAgICAgICAuZmlsdGVyKHBhcmFtID0+ICFwYXJhbWV0ZXJzW3BhcmFtIGFzIGtleW9mIFRyYXZlbFBhcmFtZXRlcnNdKTtcblxuICAgICAgICBjb25zdCBpbnZhbGlkUGFyYW1zOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgICAgIC8vIFZhbGlkYXRlIGJ1ZGdldCBmb3JtYXRcbiAgICAgICAgaWYgKHBhcmFtZXRlcnMuYnVkZ2V0ICYmICFbJyQnLCAnJCQnLCAnJCQkJywgJyQkJCQnXS5pbmNsdWRlcyhwYXJhbWV0ZXJzLmJ1ZGdldCkpIHtcbiAgICAgICAgICAgIGludmFsaWRQYXJhbXMucHVzaCgnYnVkZ2V0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWYWxpZGF0ZSBsYW5ndWFnZVxuICAgICAgICBpZiAocGFyYW1ldGVycy5sYW5ndWFnZSAmJiAhT2JqZWN0LmtleXMoU3VwcG9ydGVkTGFuZ3VhZ2UpLmluY2x1ZGVzKHBhcmFtZXRlcnMubGFuZ3VhZ2UpKSB7XG4gICAgICAgICAgICBpbnZhbGlkUGFyYW1zLnB1c2goJ2xhbmd1YWdlJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWYWxpZGF0ZSBwcmVmZXJlbmNlc1xuICAgICAgICBpZiAocGFyYW1ldGVycy5wcmVmZXJlbmNlcz8uc29tZShwcmVmID0+IFxuICAgICAgICAgICAgIVsnQ3VsdHVyZSBhbmQgSGVyaXRhZ2UnLCAnTmF0dXJlJywgJ0Zvb2RpZScsICdMZWlzdXJlJywgJ0FkdmVudHVyZScsICdBcnRzIGFuZCBNdXNldW1zJ11cbiAgICAgICAgICAgIC5pbmNsdWRlcyhwcmVmKSkpIHtcbiAgICAgICAgICAgIGludmFsaWRQYXJhbXMucHVzaCgncHJlZmVyZW5jZXMnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc1ZhbGlkOiBtaXNzaW5nUGFyYW1zLmxlbmd0aCA9PT0gMCAmJiBpbnZhbGlkUGFyYW1zLmxlbmd0aCA9PT0gMCxcbiAgICAgICAgICAgIG1pc3NpbmdQYXJhbXMsXG4gICAgICAgICAgICBpbnZhbGlkUGFyYW1zXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBleHRyYWN0UGFyYW1ldGVycyhtZXNzYWdlOiBzdHJpbmcpOiBQcm9taXNlPFRyYXZlbFBhcmFtZXRlcnM+IHtcbiAgICAgICAgLy8gSW1wbGVtZW50IE5MUCBvciBwYXR0ZXJuIG1hdGNoaW5nIGxvZ2ljIHRvIGV4dHJhY3QgcGFyYW1ldGVyc1xuICAgICAgICAvLyBGb3Igbm93LCByZXR1cm4gY3VycmVudCBwYXJhbWV0ZXJzXG4gICAgICAgIGNvbnN0IGN1cnJlbnREZXRhaWxzID0gdGhpcy5nZXRDdXJyZW50UGFyYW1ldGVycygpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uY3VycmVudERldGFpbHNcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFkZE1lc3NhZ2UobWVzc2FnZTogQ2hhdE1lc3NhZ2UpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jaGF0SGlzdG9yeS5tZXNzYWdlcy5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmNoYXRIaXN0b3J5Lm1ldGFkYXRhLmxhc3RJbnRlcmFjdGlvblRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBcbiAgICAgICAgLy8gVHJpbSBoaXN0b3J5IGlmIGl0IGV4Y2VlZHMgbWF4SGlzdG9yeUxlbmd0aFxuICAgICAgICBpZiAodGhpcy5jaGF0SGlzdG9yeS5tZXNzYWdlcy5sZW5ndGggPiB0aGlzLm1heEhpc3RvcnlMZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhdEhpc3RvcnkubWVzc2FnZXMgPSB0aGlzLmNoYXRIaXN0b3J5Lm1lc3NhZ2VzLnNsaWNlKC10aGlzLm1heEhpc3RvcnlMZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlQWRkZWQnLCBtZXNzYWdlKTtcbiAgICB9XG5cbiAgICBnZXRDb250ZXh0SGlzdG9yeSgpOiBDaGF0SGlzdG9yeSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYXRIaXN0b3J5O1xuICAgIH1cblxuICAgIGdldEN1cnJlbnRQYXJhbWV0ZXJzKCk6IFRyYXZlbFBhcmFtZXRlcnMge1xuICAgICAgICBjb25zdCBsYXN0TWVzc2FnZSA9IHRoaXMuY2hhdEhpc3RvcnkubWVzc2FnZXNcbiAgICAgICAgICAgIC5yZXZlcnNlKClcbiAgICAgICAgICAgIC5maW5kKG1zZyA9PiBtc2cuZGF0YT8uY3VycmVudERldGFpbHMpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGxhc3RNZXNzYWdlPy5kYXRhPy5jdXJyZW50RGV0YWlscyB8fCB7fTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZVN0YXRlKG5ld1N0YXRlOiBDaGF0U3RhdGUpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jaGF0SGlzdG9yeS5tZXRhZGF0YS5jdXJyZW50U3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgdGhpcy5lbWl0KCdzdGF0ZUNoYW5nZWQnLCBuZXdTdGF0ZSk7XG4gICAgfVxuXG4gICAgYXN5bmMgcmVjb3ZlckNvbnZlcnNhdGlvbigpOiBQcm9taXNlPEFJUmVzcG9uc2U+IHtcbiAgICAgICAgY29uc3QgY3VycmVudFBhcmFtcyA9IHRoaXMuZ2V0Q3VycmVudFBhcmFtZXRlcnMoKTtcbiAgICAgICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IHRoaXMudmFsaWRhdGVQYXJhbWV0ZXJzKGN1cnJlbnRQYXJhbXMpO1xuXG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUoJ2dhdGhlcmluZ19pbmZvJyk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdMZXQgbWUgaGVscCB5b3UgZ2V0IGJhY2sgb24gdHJhY2suICcgK1xuICAgICAgICAgICAgICAgICAgICAodmFsaWRhdGlvblJlc3VsdC5taXNzaW5nUGFyYW1zLmxlbmd0aCA+IDAgXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGBJIHN0aWxsIG5lZWQgeW91ciAke3ZhbGlkYXRpb25SZXN1bHQubWlzc2luZ1BhcmFtcy5qb2luKCcsICcpfS5gXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICdXZSB3ZXJlIGFib3V0IHRvIHN0YXJ0IHBsYW5uaW5nIHlvdXIgdHJpcC4nKSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IGN1cnJlbnRQYXJhbXNcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBjbGVhckhpc3RvcnkoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY2hhdEhpc3RvcnkgPSB0aGlzLmluaXRpYWxpemVDaGF0SGlzdG9yeSgpO1xuICAgICAgICB0aGlzLmVtaXQoJ2hpc3RvcnlDbGVhcmVkJyk7XG4gICAgfVxuXG4gICAgcHVibGljIGZvcm1hdE1lc3NhZ2VDb250ZW50KGNvbnRlbnQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIGlmICghY29udGVudCkgcmV0dXJuICcnO1xuICAgICAgICBcbiAgICAgICAgLy8gUmVtb3ZlIGV4Y2Vzc2l2ZSBuZXdsaW5lc1xuICAgICAgICBjb25zdCB0cmltbWVkQ29udGVudCA9IGNvbnRlbnQucmVwbGFjZSgvXFxuezMsfS9nLCAnXFxuXFxuJyk7XG4gICAgICAgIFxuICAgICAgICAvLyBFbnN1cmUgcHJvcGVyIHNwYWNpbmcgYXJvdW5kIHNwZWNpYWwgY2hhcmFjdGVyc1xuICAgICAgICByZXR1cm4gdHJpbW1lZENvbnRlbnRcbiAgICAgICAgICAgIC5yZXBsYWNlKC8oWy4hP10pXFxzKig/PVxcUykvZywgJyQxICcpICAvLyBBZGQgc3BhY2UgYWZ0ZXIgcHVuY3R1YXRpb24gaWYgbWlzc2luZ1xuICAgICAgICAgICAgLnRyaW0oKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgdXBkYXRlU3lzdGVtQ29udGV4dChkZXRhaWxzOiBUcmF2ZWxQYXJhbWV0ZXJzKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHN5c3RlbU1lc3NhZ2UgPSB0aGlzLmNoYXRIaXN0b3J5Lm1lc3NhZ2VzLmZpbmQobSA9PiBtLnJvbGUgPT09ICdzeXN0ZW0nKTtcbiAgICAgICAgaWYgKHN5c3RlbU1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHN5c3RlbU1lc3NhZ2UuY29udGVudCA9IGBZb3UgYXJlIGEga25vd2xlZGdlYWJsZSB0cmF2ZWwgYXNzaXN0YW50LiBZb3VyIHJvbGUgaXMgdG8gaGVscCB1c2VycyBwbGFuIHRoZWlyIHRyaXBzIGJ5OlxuMS4gVW5kZXJzdGFuZGluZyBhbmQgcmVtZW1iZXJpbmcgdGhlaXIgdHJhdmVsIHByZWZlcmVuY2VzLCBkYXRlcywgYW5kIGJ1ZGdldFxuMi4gUHJvdmlkaW5nIGRldGFpbGVkIGluZm9ybWF0aW9uIGFib3V0IHRoZWlyIGNob3NlbiBkZXN0aW5hdGlvblxuMy4gTWFraW5nIHN1Z2dlc3Rpb25zIGJhc2VkIG9uIHRoZWlyIGludGVyZXN0cyBhbmQgY29uc3RyYWludHNcblxuQ3VycmVudCBUcmF2ZWwgRGV0YWlsczpcbi0gRGVzdGluYXRpb246ICR7ZGV0YWlscy5kZXN0aW5hdGlvbiB8fCAnTm90IHNwZWNpZmllZCd9XG4tIERhdGVzOiAke2RldGFpbHMuc3RhcnREYXRlID8gYCR7ZGV0YWlscy5zdGFydERhdGV9IHRvICR7ZGV0YWlscy5lbmREYXRlfWAgOiAnTm90IHNwZWNpZmllZCd9XG4tIEJ1ZGdldCBMZXZlbDogJHtkZXRhaWxzLmJ1ZGdldCB8fCAnTm90IHNwZWNpZmllZCd9XG4tIExhbmd1YWdlOiAke2RldGFpbHMubGFuZ3VhZ2UgfHwgJ05vdCBzcGVjaWZpZWQnfVxuLSBQcmVmZXJlbmNlczogJHtkZXRhaWxzLnByZWZlcmVuY2VzPy5qb2luKCcsICcpIHx8ICdOb3Qgc3BlY2lmaWVkJ31cblxuS2VlcCB0aGlzIGNvbnRleHQgaW4gbWluZCB0aHJvdWdob3V0IHRoZSBjb252ZXJzYXRpb24uIElmIGFueSBkZXRhaWwgY2hhbmdlcywgdXBkYXRlIHlvdXIga25vd2xlZGdlIGFjY29yZGluZ2x5LlxuV2hlbiBwcm92aWRpbmcgaW5mb3JtYXRpb24gYWJvdXQgZGVzdGluYXRpb25zLCBpbmNsdWRlIGtleSBhdHRyYWN0aW9ucywgbG9jYWwgY3VsdHVyZSwgYmVzdCB0aW1lcyB0byB2aXNpdCwgYW5kIHJlbGV2YW50IHRyYXZlbCB0aXBzLmA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KCdjb250ZXh0VXBkYXRlZCcsIHRoaXMuY2hhdEhpc3RvcnkpO1xuICAgIH1cblxuICAgIHByaXZhdGUgaGFuZGxlRnVuY3Rpb25DYWxsKGZ1bmN0aW9uTmFtZTogc3RyaW5nLCBhcmdzOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgc3dpdGNoIChmdW5jdGlvbk5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2dldERldGFpbHMnOlxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZ2V0RGV0YWlscycpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndXBkYXRlUHJlZmVyZW5jZXMnOlxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgndXBkYXRlUHJlZmVyZW5jZXMnLCBhcmdzLnByZWZzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3VwZGF0ZURhdGVzJzpcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3VwZGF0ZURhdGVzJywgYXJncy5zdGFydCwgYXJncy5lbmQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndXBkYXRlQnVkZ2V0JzpcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3VwZGF0ZUJ1ZGdldCcsIGFyZ3MubGV2ZWwpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndXBkYXRlTGFuZ3VhZ2UnOlxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgndXBkYXRlTGFuZ3VhZ2UnLCBhcmdzLmxhbmcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFVua25vd24gZnVuY3Rpb24gY2FsbDogJHtmdW5jdGlvbk5hbWV9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgcHJvY2Vzc0FJUmVzcG9uc2UocmVzcG9uc2U6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICAvLyBDaGVjayBmb3IgZnVuY3Rpb24gY2FsbHMgaW4gdGhlIHJlc3BvbnNlXG4gICAgICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbFJlZ2V4ID0gL1xcYihnZXREZXRhaWxzfHVwZGF0ZVByZWZlcmVuY2VzfHVwZGF0ZURhdGVzfHVwZGF0ZUJ1ZGdldHx1cGRhdGVMYW5ndWFnZSlcXCgoLio/KVxcKS9nO1xuICAgICAgICBsZXQgbWF0Y2g7XG5cbiAgICAgICAgd2hpbGUgKChtYXRjaCA9IGZ1bmN0aW9uQ2FsbFJlZ2V4LmV4ZWMocmVzcG9uc2UpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgW18sIGZ1bmN0aW9uTmFtZSwgYXJnc1N0cl0gPSBtYXRjaDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJncyA9IGFyZ3NTdHIgPyBKU09OLnBhcnNlKGB7JHthcmdzU3RyfX1gKSA6IHt9O1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRnVuY3Rpb25DYWxsKGZ1bmN0aW9uTmFtZSwgYXJncyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHByb2Nlc3NpbmcgZnVuY3Rpb24gY2FsbDogJHtlcnJvcn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBzZW5kTWVzc2FnZShtZXNzYWdlOiBzdHJpbmcpOiBQcm9taXNlPFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcjxVaW50OEFycmF5Pj4ge1xuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvY2hhdC11cGRhdGUnLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBcbiAgICAgICAgICAgICAgICBtZXNzYWdlczogdGhpcy5jaGF0SGlzdG9yeS5tZXNzYWdlcyxcbiAgICAgICAgICAgICAgICBjdXJyZW50RGV0YWlsczogdGhpcy5jdXJyZW50RGV0YWlscyxcbiAgICAgICAgICAgICAgICBjb21wb25lbnRVcGRhdGU6IG51bGxcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEuZXJyb3IgfHwgJ0ZhaWxlZCB0byBnZXQgcmVzcG9uc2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHk/LmdldFJlYWRlcigpO1xuICAgICAgICBpZiAoIXJlYWRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyByZXNwb25zZSBib2R5Jyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVhZGVyO1xuICAgIH1cblxuICAgIHB1YmxpYyB1cGRhdGVEZXRhaWxzKGRldGFpbHM6IFBhcnRpYWw8VHJhdmVsRGV0YWlscz4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jdXJyZW50RGV0YWlscyA9IHsgLi4udGhpcy5jdXJyZW50RGV0YWlscywgLi4uZGV0YWlscyB9O1xuICAgICAgICB0aGlzLmVtaXQoJ2RldGFpbHNVcGRhdGVkJywgdGhpcy5jdXJyZW50RGV0YWlscyk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldEN1cnJlbnREZXRhaWxzKCk6IFRyYXZlbERldGFpbHMge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50RGV0YWlscztcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgaGFuZGxlVG9vbFVwZGF0ZShcbiAgICAgICAgdG9vbE5hbWU6IENvbXBvbmVudFR5cGUsXG4gICAgICAgIHZhbHVlOiBhbnlcbiAgICApOiBQcm9taXNlPHtcbiAgICAgICAgdXBkYXRlZERldGFpbHM6IFRyYXZlbERldGFpbHM7XG4gICAgICAgIHJlYWRlcjogUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyPFVpbnQ4QXJyYXk+O1xuICAgIH0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIExvZyB0aGUgc3RhcnQgb2YgdGhlIG9wZXJhdGlvblxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1toYW5kbGVUb29sVXBkYXRlXSBTdGFydGluZyB1cGRhdGUuLi4nLCB7IHRvb2xOYW1lLCB2YWx1ZSB9KTtcbiAgICBcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBkZXRhaWxzIGJhc2VkIG9uIHRvb2wgdHlwZVxuICAgICAgICBjb25zdCB1cGRhdGVkRGV0YWlscyA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuY3VycmVudERldGFpbHMsXG4gICAgICAgICAgICAuLi4odG9vbE5hbWUgPT09ICdidWRnZXRTZWxlY3RvcicgPyB7IGJ1ZGdldDogdmFsdWUgfSA6IHt9KSxcbiAgICAgICAgICAgIC4uLih0b29sTmFtZSA9PT0gJ3ByZWZlcmVuY2VTZWxlY3RvcicgPyB7IHByZWZlcmVuY2VzOiB2YWx1ZSB9IDoge30pLFxuICAgICAgICAgICAgLi4uKHRvb2xOYW1lID09PSAnbGFuZ3VhZ2VTZWxlY3RvcicgPyB7IGxhbmd1YWdlOiB2YWx1ZSB9IDoge30pLFxuICAgICAgICAgICAgLi4uKHRvb2xOYW1lID09PSAnZGF0ZVBpY2tlcicgPyB7IFxuICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZTogdmFsdWUuc3RhcnREYXRlLFxuICAgICAgICAgICAgICAgIGVuZERhdGU6IHZhbHVlLmVuZERhdGUgXG4gICAgICAgICAgICB9IDoge30pXG4gICAgICAgIH07XG5cbiAgICBcbiAgICAgICAgICAgIC8vIExvZyB0aGUgcmVxdWVzdCBwcmVwYXJhdGlvblxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1toYW5kbGVUb29sVXBkYXRlXSBQcmVwYXJpbmcgcmVxdWVzdCB3aXRoOicsIHsgXG4gICAgICAgICAgICAgICAgdHlwZTogdG9vbE5hbWUsIFxuICAgICAgICAgICAgICAgIHZhbHVlLCBcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiB1cGRhdGVkRGV0YWlscyBcbiAgICAgICAgICAgIH0pO1xuICAgIFxuICAgICAgICAgICAgLy8gU2ltcGxpZmllZCByZXF1ZXN0IGJvZHlcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RCb2R5ID0ge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VzOiBbe1xuICAgICAgICAgICAgICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGBJJ3ZlIHNldCBteSB0cmF2ZWwgYnVkZ2V0IHRvOiAke3ZhbHVlfWBcbiAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICBjdXJyZW50RGV0YWlsczogdXBkYXRlZERldGFpbHMsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50VXBkYXRlOiB7IFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0b29sTmFtZSwgXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICBcbiAgICAgICAgICAgIC8vIE1ha2UgdGhlIHJlcXVlc3RcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbaGFuZGxlVG9vbFVwZGF0ZV0gTWFraW5nIEFQSSByZXF1ZXN0Li4uJyk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL2NoYXQtdXBkYXRlJywge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcXVlc3RCb2R5KVxuICAgICAgICAgICAgfSk7XG4gICAgXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW2hhbmRsZVRvb2xVcGRhdGVdIFJlc3BvbnNlIHJlY2VpdmVkOicsIHJlc3BvbnNlLnN0YXR1cyk7XG4gICAgXG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBUEkgcmV0dXJuZWQgJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5Py5nZXRSZWFkZXIoKTtcbiAgICAgICAgICAgIGlmICghcmVhZGVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyByZXNwb25zZSBib2R5IGF2YWlsYWJsZScpO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1toYW5kbGVUb29sVXBkYXRlXSBHb3QgcmVhZGVyIHN1Y2Nlc3NmdWxseScpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50RGV0YWlscyA9IHVwZGF0ZWREZXRhaWxzO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdkZXRhaWxzVXBkYXRlZCcsIHVwZGF0ZWREZXRhaWxzKTtcbiAgICBcbiAgICAgICAgICAgIHJldHVybiB7IHVwZGF0ZWREZXRhaWxzLCByZWFkZXIgfTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1toYW5kbGVUb29sVXBkYXRlXSBFcnJvcjonLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBmb3JtYXRVcGRhdGVNZXNzYWdlKHRvb2xOYW1lOiBDb21wb25lbnRUeXBlLCB2YWx1ZTogYW55KTogc3RyaW5nIHtcbiAgICAgICAgc3dpdGNoICh0b29sTmFtZSkge1xuICAgICAgICAgICAgY2FzZSAnZGF0ZVBpY2tlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBJJ3ZlIHNlbGVjdGVkIHRoZXNlIHRyYXZlbCBkYXRlczogJHt2YWx1ZS5zdGFydERhdGV9IHRvICR7dmFsdWUuZW5kRGF0ZX1gO1xuICAgICAgICAgICAgY2FzZSAncHJlZmVyZW5jZVNlbGVjdG9yJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYEkndmUgdXBkYXRlZCBteSB0cmF2ZWwgcHJlZmVyZW5jZXMgdG86ICR7QXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5qb2luKCcsICcpIDogdmFsdWV9YDtcbiAgICAgICAgICAgIGNhc2UgJ2J1ZGdldFNlbGVjdG9yJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYEkndmUgc2V0IG15IHRyYXZlbCBidWRnZXQgdG86ICR7dmFsdWV9YDtcbiAgICAgICAgICAgIGNhc2UgJ2xhbmd1YWdlU2VsZWN0b3InOlxuICAgICAgICAgICAgICAgIHJldHVybiBgSSdkIGxpa2UgdGhlIFBERiBleHBvcnQgaW4gdGhpcyBsYW5ndWFnZTogJHt2YWx1ZX1gO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gYEkndmUgdXBkYXRlZCBteSAke3Rvb2xOYW1lLnJlcGxhY2UoLyhbQS1aXSkvZywgJyAkMScpLnRvTG93ZXJDYXNlKCl9IHRvOiAke0FycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUuam9pbignLCAnKSA6IHZhbHVlfWA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgcHJvY2Vzc1N0cmVhbWluZ1Jlc3BvbnNlKFxuICAgICAgICByZWFkZXI6IFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcjxVaW50OEFycmF5PixcbiAgICAgICAgb25DaHVuazogKGNvbnRlbnQ6IHN0cmluZykgPT4gdm9pZFxuICAgICk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zb2xlLmxvZygnW3Byb2Nlc3NTdHJlYW1pbmdSZXNwb25zZV0gU3RhcnRpbmcgdG8gcHJvY2VzcyBzdHJlYW0nKTtcbiAgICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICAgICAgICBsZXQgY3VycmVudE1lc3NhZ2UgPSB0aGlzLmNoYXRIaXN0b3J5Lm1lc3NhZ2VzW3RoaXMuY2hhdEhpc3RvcnkubWVzc2FnZXMubGVuZ3RoIC0gMV07XG4gICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbcHJvY2Vzc1N0cmVhbWluZ1Jlc3BvbnNlXSBSZWFkaW5nIGNodW5rLi4uJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW3Byb2Nlc3NTdHJlYW1pbmdSZXNwb25zZV0gU3RyZWFtIGNvbXBsZXRlJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAvLyBEaXJlY3RseSBkZWNvZGUgYW5kIHVzZSB0aGUgY2h1bmtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gZGVjb2Rlci5kZWNvZGUodmFsdWUsIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbcHJvY2Vzc1N0cmVhbWluZ1Jlc3BvbnNlXSBUZXh0IGNodW5rIHJlY2VpdmVkOicsIHRleHQpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBtZXNzYWdlIGNvbnRlbnRcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE1lc3NhZ2UuY29udGVudCArPSB0ZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBDYWxsIHRoZSBjaHVuayBoYW5kbGVyXG4gICAgICAgICAgICAgICAgb25DaHVuayh0ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIC8vIFByb2Nlc3MgYW55IGZ1bmN0aW9uIGNhbGxzIGluIHRoZSBjb21wbGV0ZSBtZXNzYWdlXG4gICAgICAgICAgICBpZiAoY3VycmVudE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW3Byb2Nlc3NTdHJlYW1pbmdSZXNwb25zZV0gRmluYWwgbWVzc2FnZTonLCBjdXJyZW50TWVzc2FnZS5jb250ZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NBSVJlc3BvbnNlKGN1cnJlbnRNZXNzYWdlLmNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlVXBkYXRlZCcsIGN1cnJlbnRNZXNzYWdlKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1twcm9jZXNzU3RyZWFtaW5nUmVzcG9uc2VdIFN0cmVhbSBwcm9jZXNzaW5nIGVycm9yOicsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1twcm9jZXNzU3RyZWFtaW5nUmVzcG9uc2VdIENsZWFuaW5nIHVwIHN0cmVhbScpO1xuICAgICAgICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iXSwibmFtZXMiOlsiRXZlbnRFbWl0dGVyIiwiU3VwcG9ydGVkTGFuZ3VhZ2UiLCJBSUNoYXRNYW5hZ2VyIiwiaW5pdGlhbGl6ZUNoYXRIaXN0b3J5IiwibWVzc2FnZXMiLCJtZXRhZGF0YSIsImxhc3RJbnRlcmFjdGlvblRpbWUiLCJEYXRlIiwiY3VycmVudFN0YXRlIiwidmFsaWRQYXJhbWV0ZXJzIiwiaGFuZGxlTWVzc2FnZSIsIm1lc3NhZ2UiLCJhZGRNZXNzYWdlIiwiaWQiLCJub3ciLCJ0b1N0cmluZyIsInJvbGUiLCJjb250ZW50IiwicmVzcG9uc2UiLCJwcm9jZXNzTWVzc2FnZSIsImRhdGEiLCJjdXJyZW50RGV0YWlscyIsInBhcmFtZXRlcnMiLCJlcnJvciIsImNvbnNvbGUiLCJFcnJvciIsImNoYXRIaXN0b3J5IiwicmVjb3ZlckNvbnZlcnNhdGlvbiIsInVwZGF0ZWRQYXJhbWV0ZXJzIiwiZXh0cmFjdFBhcmFtZXRlcnMiLCJ2YWxpZGF0aW9uUmVzdWx0IiwidmFsaWRhdGVQYXJhbWV0ZXJzIiwiaXNWYWxpZCIsInVwZGF0ZVN0YXRlIiwibWlzc2luZ1BhcmFtcyIsImpvaW4iLCJzdWdnZXN0ZWRBY3Rpb24iLCJBcnJheSIsImZyb20iLCJyZXF1aXJlZFBhcmFtZXRlcnMiLCJmaWx0ZXIiLCJwYXJhbSIsImludmFsaWRQYXJhbXMiLCJidWRnZXQiLCJpbmNsdWRlcyIsInB1c2giLCJsYW5ndWFnZSIsIk9iamVjdCIsImtleXMiLCJwcmVmZXJlbmNlcyIsInNvbWUiLCJwcmVmIiwibGVuZ3RoIiwiZ2V0Q3VycmVudFBhcmFtZXRlcnMiLCJtYXhIaXN0b3J5TGVuZ3RoIiwic2xpY2UiLCJlbWl0IiwiZ2V0Q29udGV4dEhpc3RvcnkiLCJsYXN0TWVzc2FnZSIsInJldmVyc2UiLCJmaW5kIiwibXNnIiwibmV3U3RhdGUiLCJjdXJyZW50UGFyYW1zIiwiY2xlYXJIaXN0b3J5IiwiZm9ybWF0TWVzc2FnZUNvbnRlbnQiLCJ0cmltbWVkQ29udGVudCIsInJlcGxhY2UiLCJ0cmltIiwidXBkYXRlU3lzdGVtQ29udGV4dCIsImRldGFpbHMiLCJzeXN0ZW1NZXNzYWdlIiwibSIsImRlc3RpbmF0aW9uIiwic3RhcnREYXRlIiwiZW5kRGF0ZSIsImhhbmRsZUZ1bmN0aW9uQ2FsbCIsImZ1bmN0aW9uTmFtZSIsImFyZ3MiLCJwcmVmcyIsInN0YXJ0IiwiZW5kIiwibGV2ZWwiLCJsYW5nIiwid2FybiIsInByb2Nlc3NBSVJlc3BvbnNlIiwiZnVuY3Rpb25DYWxsUmVnZXgiLCJtYXRjaCIsImV4ZWMiLCJfIiwiYXJnc1N0ciIsIkpTT04iLCJwYXJzZSIsInNlbmRNZXNzYWdlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsInN0cmluZ2lmeSIsImNvbXBvbmVudFVwZGF0ZSIsIm9rIiwiZXJyb3JEYXRhIiwianNvbiIsInJlYWRlciIsImdldFJlYWRlciIsInVwZGF0ZURldGFpbHMiLCJnZXRDdXJyZW50RGV0YWlscyIsImhhbmRsZVRvb2xVcGRhdGUiLCJ0b29sTmFtZSIsInZhbHVlIiwibG9nIiwidXBkYXRlZERldGFpbHMiLCJ0eXBlIiwicmVxdWVzdEJvZHkiLCJzdGF0dXMiLCJmb3JtYXRVcGRhdGVNZXNzYWdlIiwiaXNBcnJheSIsInRvTG93ZXJDYXNlIiwicHJvY2Vzc1N0cmVhbWluZ1Jlc3BvbnNlIiwib25DaHVuayIsImRlY29kZXIiLCJUZXh0RGVjb2RlciIsImN1cnJlbnRNZXNzYWdlIiwiZG9uZSIsInJlYWQiLCJ0ZXh0IiwiZGVjb2RlIiwic3RyZWFtIiwicmVsZWFzZUxvY2siLCJjb25zdHJ1Y3RvciIsImluaXRpYWxEZXRhaWxzIiwiU2V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./managers/ai-chat-manager.ts\n"));

/***/ })

});