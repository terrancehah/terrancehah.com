"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("components_travel-chat_tsx",{

/***/ "./managers/ai-chat-manager.ts":
/*!*************************************!*\
  !*** ./managers/ai-chat-manager.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AIChatManager: function() { return /* binding */ AIChatManager; }\n/* harmony export */ });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"./node_modules/next/dist/compiled/events/events.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ \"./managers/types.ts\");\n\n\nclass AIChatManager extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    initializeChatHistory() {\n        return {\n            messages: [],\n            metadata: {\n                lastInteractionTime: new Date(),\n                currentState: \"initial\",\n                validParameters: []\n            }\n        };\n    }\n    async handleMessage(message) {\n        try {\n            // Add user message to history\n            this.addMessage({\n                id: Date.now().toString(),\n                role: \"user\",\n                content: message\n            });\n            // Process message and update parameters\n            const response = await this.processMessage(message);\n            // Add AI response to history\n            this.addMessage({\n                id: (Date.now() + 1).toString(),\n                role: \"assistant\",\n                content: response.message,\n                data: {\n                    currentDetails: response.parameters\n                }\n            });\n            return response;\n        } catch (error) {\n            console.error(\"Error handling message:\", error);\n            return {\n                message: \"I encountered an error processing your message. Let's continue from where we left off.\",\n                error: error instanceof Error ? error.message : \"Unknown error\"\n            };\n        }\n    }\n    async processMessage(message) {\n        const currentState = this.chatHistory.metadata.currentState;\n        if (currentState === \"interrupted\") {\n            return this.recoverConversation();\n        }\n        // Update state based on message content and current parameters\n        const updatedParameters = await this.extractParameters(message);\n        const validationResult = this.validateParameters(updatedParameters);\n        if (validationResult.isValid) {\n            this.updateState(\"planning\");\n            return {\n                message: \"Great! I have all the information needed. Let me plan your trip.\",\n                parameters: updatedParameters\n            };\n        }\n        return {\n            message: \"Could you please provide your \".concat(validationResult.missingParams.join(\", \"), \"?\"),\n            parameters: updatedParameters,\n            suggestedAction: \"gather_info\"\n        };\n    }\n    validateParameters(parameters) {\n        var _parameters_preferences;\n        const missingParams = Array.from(this.requiredParameters).filter((param)=>!parameters[param]);\n        const invalidParams = [];\n        // Validate budget format\n        if (parameters.budget && ![\n            \"$\",\n            \"$$\",\n            \"$$$\",\n            \"$$$$\"\n        ].includes(parameters.budget)) {\n            invalidParams.push(\"budget\");\n        }\n        // Validate language\n        if (parameters.language && !Object.keys(_types__WEBPACK_IMPORTED_MODULE_1__.SupportedLanguage).includes(parameters.language)) {\n            invalidParams.push(\"language\");\n        }\n        // Validate preferences\n        if ((_parameters_preferences = parameters.preferences) === null || _parameters_preferences === void 0 ? void 0 : _parameters_preferences.some((pref)=>![\n                \"Culture and Heritage\",\n                \"Nature\",\n                \"Foodie\",\n                \"Leisure\",\n                \"Adventure\",\n                \"Arts and Museums\"\n            ].includes(pref))) {\n            invalidParams.push(\"preferences\");\n        }\n        return {\n            isValid: missingParams.length === 0 && invalidParams.length === 0,\n            missingParams,\n            invalidParams\n        };\n    }\n    async extractParameters(message) {\n        // Implement NLP or pattern matching logic to extract parameters\n        // For now, return current parameters\n        const currentDetails = this.getCurrentParameters();\n        return {\n            ...currentDetails\n        };\n    }\n    addMessage(message) {\n        this.chatHistory.messages.push(message);\n        this.chatHistory.metadata.lastInteractionTime = new Date();\n        // Trim history if it exceeds maxHistoryLength\n        if (this.chatHistory.messages.length > this.maxHistoryLength) {\n            this.chatHistory.messages = this.chatHistory.messages.slice(-this.maxHistoryLength);\n        }\n        this.emit(\"messageAdded\", message);\n    }\n    getContextHistory() {\n        return this.chatHistory;\n    }\n    getCurrentParameters() {\n        var _lastMessage_data;\n        const lastMessage = this.chatHistory.messages.reverse().find((msg)=>{\n            var _msg_data;\n            return (_msg_data = msg.data) === null || _msg_data === void 0 ? void 0 : _msg_data.currentDetails;\n        });\n        return (lastMessage === null || lastMessage === void 0 ? void 0 : (_lastMessage_data = lastMessage.data) === null || _lastMessage_data === void 0 ? void 0 : _lastMessage_data.currentDetails) || {};\n    }\n    updateState(newState) {\n        this.chatHistory.metadata.currentState = newState;\n        this.emit(\"stateChanged\", newState);\n    }\n    async recoverConversation() {\n        const currentParams = this.getCurrentParameters();\n        const validationResult = this.validateParameters(currentParams);\n        this.updateState(\"gathering_info\");\n        return {\n            message: \"Let me help you get back on track. \" + (validationResult.missingParams.length > 0 ? \"I still need your \".concat(validationResult.missingParams.join(\", \"), \".\") : \"We were about to start planning your trip.\"),\n            parameters: currentParams\n        };\n    }\n    clearHistory() {\n        this.chatHistory = this.initializeChatHistory();\n        this.emit(\"historyCleared\");\n    }\n    formatMessageContent(content) {\n        if (!content) return \"\";\n        // Remove excessive newlines\n        const trimmedContent = content.replace(/\\n{3,}/g, \"\\n\\n\");\n        // Ensure proper spacing around special characters\n        return trimmedContent.replace(/([.!?])\\s*(?=\\S)/g, \"$1 \") // Add space after punctuation if missing\n        .trim();\n    }\n    updateSystemContext(details) {\n        const systemMessage = this.chatHistory.messages.find((m)=>m.role === \"system\");\n        if (systemMessage) {\n            var _details_preferences;\n            systemMessage.content = \"You are a knowledgeable travel assistant. Your role is to help users plan their trips by:\\n1. Understanding and remembering their travel preferences, dates, and budget\\n2. Providing detailed information about their chosen destination\\n3. Making suggestions based on their interests and constraints\\n\\nCurrent Travel Details:\\n- Destination: \".concat(details.destination || \"Not specified\", \"\\n- Dates: \").concat(details.startDate ? \"\".concat(details.startDate, \" to \").concat(details.endDate) : \"Not specified\", \"\\n- Budget Level: \").concat(details.budget || \"Not specified\", \"\\n- Language: \").concat(details.language || \"Not specified\", \"\\n- Preferences: \").concat(((_details_preferences = details.preferences) === null || _details_preferences === void 0 ? void 0 : _details_preferences.join(\", \")) || \"Not specified\", \"\\n\\nKeep this context in mind throughout the conversation. If any detail changes, update your knowledge accordingly.\\nWhen providing information about destinations, include key attractions, local culture, best times to visit, and relevant travel tips.\");\n        }\n        this.emit(\"contextUpdated\", this.chatHistory);\n    }\n    handleFunctionCall(functionName, args) {\n        switch(functionName){\n            case \"getDetails\":\n                this.emit(\"getDetails\");\n                break;\n            case \"updatePreferences\":\n                this.emit(\"updatePreferences\", args.prefs);\n                break;\n            case \"updateDates\":\n                this.emit(\"updateDates\", args.start, args.end);\n                break;\n            case \"updateBudget\":\n                this.emit(\"updateBudget\", args.level);\n                break;\n            case \"updateLanguage\":\n                this.emit(\"updateLanguage\", args.lang);\n                break;\n            default:\n                console.warn(\"Unknown function call: \".concat(functionName));\n        }\n    }\n    processAIResponse(response) {\n        // Check for function calls in the response\n        const functionCallRegex = /\\b(getDetails|updatePreferences|updateDates|updateBudget|updateLanguage)\\((.*?)\\)/g;\n        let match;\n        while((match = functionCallRegex.exec(response)) !== null){\n            const [_, functionName, argsStr] = match;\n            try {\n                const args = argsStr ? JSON.parse(\"{\".concat(argsStr, \"}\")) : {};\n                this.handleFunctionCall(functionName, args);\n            } catch (error) {\n                console.error(\"Error processing function call: \".concat(error));\n            }\n        }\n    }\n    async sendMessage(message) {\n        var _response_body;\n        const userMessage = {\n            id: Date.now().toString(),\n            role: \"user\",\n            content: message\n        };\n        this.addMessage(userMessage);\n        const response = await fetch(\"/api/chat-update\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                messages: this.chatHistory.messages,\n                currentDetails: this.currentDetails,\n                componentUpdate: null\n            })\n        });\n        if (!response.ok) {\n            const errorData = await response.json();\n            throw new Error(errorData.error || \"Failed to get response\");\n        }\n        const reader = (_response_body = response.body) === null || _response_body === void 0 ? void 0 : _response_body.getReader();\n        if (!reader) {\n            throw new Error(\"No response body\");\n        }\n        // Add empty assistant message that will be updated during streaming\n        this.addMessage({\n            id: (Date.now() + 1).toString(),\n            role: \"assistant\",\n            content: \"\"\n        });\n        return reader;\n    }\n    updateDetails(details) {\n        this.currentDetails = {\n            ...this.currentDetails,\n            ...details\n        };\n        this.emit(\"detailsUpdated\", this.currentDetails);\n    }\n    getCurrentDetails() {\n        return this.currentDetails;\n    }\n    async handleToolUpdate(toolName, value) {\n        try {\n            var _response_body;\n            const updatedDetails = {\n                ...this.currentDetails,\n                ...toolName === \"datePicker\" ? {\n                    startDate: value.startDate,\n                    endDate: value.endDate\n                } : {},\n                ...toolName === \"preferenceSelector\" ? {\n                    preferences: value\n                } : {},\n                ...toolName === \"budgetSelector\" ? {\n                    budget: value\n                } : {},\n                ...toolName === \"languageSelector\" ? {\n                    language: value\n                } : {}\n            };\n            this.currentDetails = updatedDetails;\n            const updateMessage = this.formatUpdateMessage(toolName, value);\n            const requestBody = {\n                messages: [\n                    {\n                        role: \"user\",\n                        content: updateMessage\n                    }\n                ],\n                currentDetails: updatedDetails,\n                componentUpdate: {\n                    type: toolName,\n                    value,\n                    timestamp: Date.now()\n                }\n            };\n            const response = await fetch(\"/api/chat-update\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify(requestBody)\n            });\n            if (!response.ok) {\n                const errorText = await response.text();\n                throw new Error(\"API Error: \".concat(response.status, \" - \").concat(errorText));\n            }\n            const reader = (_response_body = response.body) === null || _response_body === void 0 ? void 0 : _response_body.getReader();\n            if (!reader) {\n                throw new Error(\"No response body available\");\n            }\n            this.addMessage({\n                id: Date.now().toString(),\n                role: \"assistant\",\n                content: \"\",\n                data: {\n                    currentDetails: updatedDetails,\n                    updateType: toolName\n                }\n            });\n            this.emit(\"detailsUpdated\", updatedDetails);\n            this.emit(\"updateStarted\", {\n                toolName,\n                value\n            });\n            return {\n                updatedDetails,\n                reader\n            };\n        } catch (error) {\n            this.emit(\"updateError\", {\n                toolName,\n                error: error instanceof Error ? error.message : \"API connection failed\",\n                status: error.status\n            });\n            throw error;\n        }\n    }\n    formatUpdateMessage(toolName, value) {\n        switch(toolName){\n            case \"datePicker\":\n                return \"I've selected these travel dates: \".concat(value.startDate, \" to \").concat(value.endDate);\n            case \"preferenceSelector\":\n                return \"I've updated my travel preferences to: \".concat(Array.isArray(value) ? value.join(\", \") : value);\n            case \"budgetSelector\":\n                return \"I've set my travel budget to: \".concat(value);\n            case \"languageSelector\":\n                return \"I'd like the PDF export in this language: \".concat(value);\n            default:\n                return \"I've updated my \".concat(toolName.replace(/([A-Z])/g, \" $1\").toLowerCase(), \" to: \").concat(Array.isArray(value) ? value.join(\", \") : value);\n        }\n    }\n    async processStreamingResponse(reader, onChunk) {\n        console.log(\"[processStreamingResponse] Starting to process stream\");\n        const decoder = new TextDecoder();\n        let buffer = \"\";\n        let currentMessage = this.chatHistory.messages[this.chatHistory.messages.length - 1];\n        try {\n            while(true){\n                console.log(\"[processStreamingResponse] Reading chunk...\");\n                const { done, value } = await reader.read();\n                if (done) {\n                    console.log(\"[processStreamingResponse] Stream complete\");\n                    break;\n                }\n                const chunk = decoder.decode(value, {\n                    stream: true\n                });\n                console.log(\"[processStreamingResponse] Raw chunk received:\", chunk);\n                buffer += chunk;\n                const lines = buffer.split(\"\\n\");\n                buffer = lines.pop() || \"\";\n                for (const line of lines){\n                    console.log(\"[processStreamingResponse] Processing line:\", line);\n                    if (line.startsWith(\"data: \")) {\n                        const data = line.slice(6);\n                        if (data === \"[DONE]\") {\n                            console.log(\"[processStreamingResponse] Received [DONE] signal\");\n                            continue;\n                        }\n                        try {\n                            var _parsed_choices__delta, _parsed_choices_, _parsed_choices;\n                            const parsed = JSON.parse(data);\n                            console.log(\"[processStreamingResponse] Parsed data:\", parsed);\n                            if ((_parsed_choices = parsed.choices) === null || _parsed_choices === void 0 ? void 0 : (_parsed_choices_ = _parsed_choices[0]) === null || _parsed_choices_ === void 0 ? void 0 : (_parsed_choices__delta = _parsed_choices_.delta) === null || _parsed_choices__delta === void 0 ? void 0 : _parsed_choices__delta.content) {\n                                const content = parsed.choices[0].delta.content;\n                                console.log(\"[processStreamingResponse] Content chunk:\", content);\n                                onChunk(content);\n                                // Update the current message content\n                                if (currentMessage) {\n                                    currentMessage.content += content;\n                                }\n                            }\n                        } catch (e) {\n                            console.error(\"[processStreamingResponse] Error parsing data:\", e, \"Raw data:\", data);\n                        }\n                    }\n                }\n            }\n            // Process any function calls in the complete message\n            if (currentMessage) {\n                console.log(\"[processStreamingResponse] Final message:\", currentMessage.content);\n                this.processAIResponse(currentMessage.content);\n            }\n            this.emit(\"messageUpdated\", currentMessage);\n        } catch (error) {\n            console.error(\"[processStreamingResponse] Stream processing error:\", error);\n            throw error;\n        } finally{\n            console.log(\"[processStreamingResponse] Cleaning up stream\");\n            reader.releaseLock();\n        }\n    }\n    constructor(initialDetails){\n        super();\n        this.chatHistory = this.initializeChatHistory();\n        this.currentDetails = initialDetails;\n        this.requiredParameters = new Set([\n            \"destination\",\n            \"startDate\",\n            \"endDate\",\n            \"budget\",\n            \"language\"\n        ]);\n        this.maxHistoryLength = 50;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUssQ0FBQyx1REFBdURBO1lBQ3JFLE1BQU1BO1FBQ1YsU0FBVTtZQUNOQyxRQUFRcUcsR0FBRyxDQUFDO1lBQ1pyQixPQUFPd0MsV0FBVztRQUN0QjtJQUNKO0lBcGNBQyxZQUFZQyxjQUE2QixDQUFFO1FBQ3ZDLEtBQUs7UUFDTCxJQUFJLENBQUN4SCxXQUFXLEdBQUcsSUFBSSxDQUFDdkIscUJBQXFCO1FBQzdDLElBQUksQ0FBQ2tCLGNBQWMsR0FBRzZIO1FBQ3RCLElBQUksQ0FBQzNHLGtCQUFrQixHQUFHLElBQUk0RyxJQUFJO1lBQzlCO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7U0FDSDtRQUNELElBQUksQ0FBQzdGLGdCQUFnQixHQUFHO0lBQzVCO0FBeWJKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL21hbmFnZXJzL2FpLWNoYXQtbWFuYWdlci50cz9jNjJhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgeyBcbiAgICBDaGF0SGlzdG9yeSwgXG4gICAgQ2hhdE1lc3NhZ2UsIFxuICAgIENoYXRTdGF0ZSwgXG4gICAgVHJhdmVsUGFyYW1ldGVycyxcbiAgICBBSVJlc3BvbnNlLFxuICAgIE1lc3NhZ2VEYXRhLFxuICAgIEJ1ZGdldExldmVsLFxuICAgIFRyYXZlbFByZWZlcmVuY2UsXG4gICAgU3VwcG9ydGVkTGFuZ3VhZ2UsXG4gICAgVHJhdmVsRGV0YWlscyxcbiAgICBDb21wb25lbnRUeXBlXG59IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgY2xhc3MgQUlDaGF0TWFuYWdlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gICAgcHJpdmF0ZSBjaGF0SGlzdG9yeTogQ2hhdEhpc3Rvcnk7XG4gICAgcHJpdmF0ZSByZXF1aXJlZFBhcmFtZXRlcnM6IFNldDxzdHJpbmc+O1xuICAgIHByaXZhdGUgbWF4SGlzdG9yeUxlbmd0aDogbnVtYmVyO1xuICAgIHByaXZhdGUgY3VycmVudERldGFpbHM6IFRyYXZlbERldGFpbHM7XG5cbiAgICBjb25zdHJ1Y3Rvcihpbml0aWFsRGV0YWlsczogVHJhdmVsRGV0YWlscykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNoYXRIaXN0b3J5ID0gdGhpcy5pbml0aWFsaXplQ2hhdEhpc3RvcnkoKTtcbiAgICAgICAgdGhpcy5jdXJyZW50RGV0YWlscyA9IGluaXRpYWxEZXRhaWxzO1xuICAgICAgICB0aGlzLnJlcXVpcmVkUGFyYW1ldGVycyA9IG5ldyBTZXQoW1xuICAgICAgICAgICAgJ2Rlc3RpbmF0aW9uJyxcbiAgICAgICAgICAgICdzdGFydERhdGUnLFxuICAgICAgICAgICAgJ2VuZERhdGUnLFxuICAgICAgICAgICAgJ2J1ZGdldCcsXG4gICAgICAgICAgICAnbGFuZ3VhZ2UnXG4gICAgICAgIF0pO1xuICAgICAgICB0aGlzLm1heEhpc3RvcnlMZW5ndGggPSA1MDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGluaXRpYWxpemVDaGF0SGlzdG9yeSgpOiBDaGF0SGlzdG9yeSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZXNzYWdlczogW10sXG4gICAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgICAgIGxhc3RJbnRlcmFjdGlvblRpbWU6IG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgICAgY3VycmVudFN0YXRlOiAnaW5pdGlhbCcsXG4gICAgICAgICAgICAgICAgdmFsaWRQYXJhbWV0ZXJzOiBbXVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGhhbmRsZU1lc3NhZ2UobWVzc2FnZTogc3RyaW5nKTogUHJvbWlzZTxBSVJlc3BvbnNlPiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBBZGQgdXNlciBtZXNzYWdlIHRvIGhpc3RvcnlcbiAgICAgICAgICAgIHRoaXMuYWRkTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgaWQ6IERhdGUubm93KCkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgICAgICAgICAgY29udGVudDogbWVzc2FnZVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFByb2Nlc3MgbWVzc2FnZSBhbmQgdXBkYXRlIHBhcmFtZXRlcnNcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcm9jZXNzTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQWRkIEFJIHJlc3BvbnNlIHRvIGhpc3RvcnlcbiAgICAgICAgICAgIHRoaXMuYWRkTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgaWQ6IChEYXRlLm5vdygpICsgMSkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICByb2xlOiAnYXNzaXN0YW50JyxcbiAgICAgICAgICAgICAgICBjb250ZW50OiByZXNwb25zZS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudERldGFpbHM6IHJlc3BvbnNlLnBhcmFtZXRlcnNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaGFuZGxpbmcgbWVzc2FnZTonLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdJIGVuY291bnRlcmVkIGFuIGVycm9yIHByb2Nlc3NpbmcgeW91ciBtZXNzYWdlLiBMZXRcXCdzIGNvbnRpbnVlIGZyb20gd2hlcmUgd2UgbGVmdCBvZmYuJyxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcidcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIHByb2Nlc3NNZXNzYWdlKG1lc3NhZ2U6IHN0cmluZyk6IFByb21pc2U8QUlSZXNwb25zZT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50U3RhdGUgPSB0aGlzLmNoYXRIaXN0b3J5Lm1ldGFkYXRhLmN1cnJlbnRTdGF0ZTtcbiAgICAgICAgXG4gICAgICAgIGlmIChjdXJyZW50U3RhdGUgPT09ICdpbnRlcnJ1cHRlZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlY292ZXJDb252ZXJzYXRpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSBzdGF0ZSBiYXNlZCBvbiBtZXNzYWdlIGNvbnRlbnQgYW5kIGN1cnJlbnQgcGFyYW1ldGVyc1xuICAgICAgICBjb25zdCB1cGRhdGVkUGFyYW1ldGVycyA9IGF3YWl0IHRoaXMuZXh0cmFjdFBhcmFtZXRlcnMobWVzc2FnZSk7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRpb25SZXN1bHQgPSB0aGlzLnZhbGlkYXRlUGFyYW1ldGVycyh1cGRhdGVkUGFyYW1ldGVycyk7XG5cbiAgICAgICAgaWYgKHZhbGlkYXRpb25SZXN1bHQuaXNWYWxpZCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSgncGxhbm5pbmcnKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ0dyZWF0ISBJIGhhdmUgYWxsIHRoZSBpbmZvcm1hdGlvbiBuZWVkZWQuIExldCBtZSBwbGFuIHlvdXIgdHJpcC4nLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHVwZGF0ZWRQYXJhbWV0ZXJzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBDb3VsZCB5b3UgcGxlYXNlIHByb3ZpZGUgeW91ciAke3ZhbGlkYXRpb25SZXN1bHQubWlzc2luZ1BhcmFtcy5qb2luKCcsICcpfT9gLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogdXBkYXRlZFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBzdWdnZXN0ZWRBY3Rpb246ICdnYXRoZXJfaW5mbydcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHZhbGlkYXRlUGFyYW1ldGVycyhwYXJhbWV0ZXJzOiBUcmF2ZWxQYXJhbWV0ZXJzKTogeyBcbiAgICAgICAgaXNWYWxpZDogYm9vbGVhbjsgXG4gICAgICAgIG1pc3NpbmdQYXJhbXM6IHN0cmluZ1tdO1xuICAgICAgICBpbnZhbGlkUGFyYW1zOiBzdHJpbmdbXTtcbiAgICB9IHtcbiAgICAgICAgY29uc3QgbWlzc2luZ1BhcmFtcyA9IEFycmF5LmZyb20odGhpcy5yZXF1aXJlZFBhcmFtZXRlcnMpXG4gICAgICAgICAgICAuZmlsdGVyKHBhcmFtID0+ICFwYXJhbWV0ZXJzW3BhcmFtIGFzIGtleW9mIFRyYXZlbFBhcmFtZXRlcnNdKTtcblxuICAgICAgICBjb25zdCBpbnZhbGlkUGFyYW1zOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgICAgIC8vIFZhbGlkYXRlIGJ1ZGdldCBmb3JtYXRcbiAgICAgICAgaWYgKHBhcmFtZXRlcnMuYnVkZ2V0ICYmICFbJyQnLCAnJCQnLCAnJCQkJywgJyQkJCQnXS5pbmNsdWRlcyhwYXJhbWV0ZXJzLmJ1ZGdldCkpIHtcbiAgICAgICAgICAgIGludmFsaWRQYXJhbXMucHVzaCgnYnVkZ2V0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWYWxpZGF0ZSBsYW5ndWFnZVxuICAgICAgICBpZiAocGFyYW1ldGVycy5sYW5ndWFnZSAmJiAhT2JqZWN0LmtleXMoU3VwcG9ydGVkTGFuZ3VhZ2UpLmluY2x1ZGVzKHBhcmFtZXRlcnMubGFuZ3VhZ2UpKSB7XG4gICAgICAgICAgICBpbnZhbGlkUGFyYW1zLnB1c2goJ2xhbmd1YWdlJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWYWxpZGF0ZSBwcmVmZXJlbmNlc1xuICAgICAgICBpZiAocGFyYW1ldGVycy5wcmVmZXJlbmNlcz8uc29tZShwcmVmID0+IFxuICAgICAgICAgICAgIVsnQ3VsdHVyZSBhbmQgSGVyaXRhZ2UnLCAnTmF0dXJlJywgJ0Zvb2RpZScsICdMZWlzdXJlJywgJ0FkdmVudHVyZScsICdBcnRzIGFuZCBNdXNldW1zJ11cbiAgICAgICAgICAgIC5pbmNsdWRlcyhwcmVmKSkpIHtcbiAgICAgICAgICAgIGludmFsaWRQYXJhbXMucHVzaCgncHJlZmVyZW5jZXMnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc1ZhbGlkOiBtaXNzaW5nUGFyYW1zLmxlbmd0aCA9PT0gMCAmJiBpbnZhbGlkUGFyYW1zLmxlbmd0aCA9PT0gMCxcbiAgICAgICAgICAgIG1pc3NpbmdQYXJhbXMsXG4gICAgICAgICAgICBpbnZhbGlkUGFyYW1zXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBleHRyYWN0UGFyYW1ldGVycyhtZXNzYWdlOiBzdHJpbmcpOiBQcm9taXNlPFRyYXZlbFBhcmFtZXRlcnM+IHtcbiAgICAgICAgLy8gSW1wbGVtZW50IE5MUCBvciBwYXR0ZXJuIG1hdGNoaW5nIGxvZ2ljIHRvIGV4dHJhY3QgcGFyYW1ldGVyc1xuICAgICAgICAvLyBGb3Igbm93LCByZXR1cm4gY3VycmVudCBwYXJhbWV0ZXJzXG4gICAgICAgIGNvbnN0IGN1cnJlbnREZXRhaWxzID0gdGhpcy5nZXRDdXJyZW50UGFyYW1ldGVycygpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uY3VycmVudERldGFpbHNcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFkZE1lc3NhZ2UobWVzc2FnZTogQ2hhdE1lc3NhZ2UpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jaGF0SGlzdG9yeS5tZXNzYWdlcy5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmNoYXRIaXN0b3J5Lm1ldGFkYXRhLmxhc3RJbnRlcmFjdGlvblRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBcbiAgICAgICAgLy8gVHJpbSBoaXN0b3J5IGlmIGl0IGV4Y2VlZHMgbWF4SGlzdG9yeUxlbmd0aFxuICAgICAgICBpZiAodGhpcy5jaGF0SGlzdG9yeS5tZXNzYWdlcy5sZW5ndGggPiB0aGlzLm1heEhpc3RvcnlMZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhdEhpc3RvcnkubWVzc2FnZXMgPSB0aGlzLmNoYXRIaXN0b3J5Lm1lc3NhZ2VzLnNsaWNlKC10aGlzLm1heEhpc3RvcnlMZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlQWRkZWQnLCBtZXNzYWdlKTtcbiAgICB9XG5cbiAgICBnZXRDb250ZXh0SGlzdG9yeSgpOiBDaGF0SGlzdG9yeSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYXRIaXN0b3J5O1xuICAgIH1cblxuICAgIGdldEN1cnJlbnRQYXJhbWV0ZXJzKCk6IFRyYXZlbFBhcmFtZXRlcnMge1xuICAgICAgICBjb25zdCBsYXN0TWVzc2FnZSA9IHRoaXMuY2hhdEhpc3RvcnkubWVzc2FnZXNcbiAgICAgICAgICAgIC5yZXZlcnNlKClcbiAgICAgICAgICAgIC5maW5kKG1zZyA9PiBtc2cuZGF0YT8uY3VycmVudERldGFpbHMpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGxhc3RNZXNzYWdlPy5kYXRhPy5jdXJyZW50RGV0YWlscyB8fCB7fTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZVN0YXRlKG5ld1N0YXRlOiBDaGF0U3RhdGUpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jaGF0SGlzdG9yeS5tZXRhZGF0YS5jdXJyZW50U3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgdGhpcy5lbWl0KCdzdGF0ZUNoYW5nZWQnLCBuZXdTdGF0ZSk7XG4gICAgfVxuXG4gICAgYXN5bmMgcmVjb3ZlckNvbnZlcnNhdGlvbigpOiBQcm9taXNlPEFJUmVzcG9uc2U+IHtcbiAgICAgICAgY29uc3QgY3VycmVudFBhcmFtcyA9IHRoaXMuZ2V0Q3VycmVudFBhcmFtZXRlcnMoKTtcbiAgICAgICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IHRoaXMudmFsaWRhdGVQYXJhbWV0ZXJzKGN1cnJlbnRQYXJhbXMpO1xuXG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUoJ2dhdGhlcmluZ19pbmZvJyk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdMZXQgbWUgaGVscCB5b3UgZ2V0IGJhY2sgb24gdHJhY2suICcgK1xuICAgICAgICAgICAgICAgICAgICAodmFsaWRhdGlvblJlc3VsdC5taXNzaW5nUGFyYW1zLmxlbmd0aCA+IDAgXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGBJIHN0aWxsIG5lZWQgeW91ciAke3ZhbGlkYXRpb25SZXN1bHQubWlzc2luZ1BhcmFtcy5qb2luKCcsICcpfS5gXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICdXZSB3ZXJlIGFib3V0IHRvIHN0YXJ0IHBsYW5uaW5nIHlvdXIgdHJpcC4nKSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IGN1cnJlbnRQYXJhbXNcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBjbGVhckhpc3RvcnkoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY2hhdEhpc3RvcnkgPSB0aGlzLmluaXRpYWxpemVDaGF0SGlzdG9yeSgpO1xuICAgICAgICB0aGlzLmVtaXQoJ2hpc3RvcnlDbGVhcmVkJyk7XG4gICAgfVxuXG4gICAgcHVibGljIGZvcm1hdE1lc3NhZ2VDb250ZW50KGNvbnRlbnQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIGlmICghY29udGVudCkgcmV0dXJuICcnO1xuICAgICAgICBcbiAgICAgICAgLy8gUmVtb3ZlIGV4Y2Vzc2l2ZSBuZXdsaW5lc1xuICAgICAgICBjb25zdCB0cmltbWVkQ29udGVudCA9IGNvbnRlbnQucmVwbGFjZSgvXFxuezMsfS9nLCAnXFxuXFxuJyk7XG4gICAgICAgIFxuICAgICAgICAvLyBFbnN1cmUgcHJvcGVyIHNwYWNpbmcgYXJvdW5kIHNwZWNpYWwgY2hhcmFjdGVyc1xuICAgICAgICByZXR1cm4gdHJpbW1lZENvbnRlbnRcbiAgICAgICAgICAgIC5yZXBsYWNlKC8oWy4hP10pXFxzKig/PVxcUykvZywgJyQxICcpICAvLyBBZGQgc3BhY2UgYWZ0ZXIgcHVuY3R1YXRpb24gaWYgbWlzc2luZ1xuICAgICAgICAgICAgLnRyaW0oKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgdXBkYXRlU3lzdGVtQ29udGV4dChkZXRhaWxzOiBUcmF2ZWxQYXJhbWV0ZXJzKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHN5c3RlbU1lc3NhZ2UgPSB0aGlzLmNoYXRIaXN0b3J5Lm1lc3NhZ2VzLmZpbmQobSA9PiBtLnJvbGUgPT09ICdzeXN0ZW0nKTtcbiAgICAgICAgaWYgKHN5c3RlbU1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHN5c3RlbU1lc3NhZ2UuY29udGVudCA9IGBZb3UgYXJlIGEga25vd2xlZGdlYWJsZSB0cmF2ZWwgYXNzaXN0YW50LiBZb3VyIHJvbGUgaXMgdG8gaGVscCB1c2VycyBwbGFuIHRoZWlyIHRyaXBzIGJ5OlxuMS4gVW5kZXJzdGFuZGluZyBhbmQgcmVtZW1iZXJpbmcgdGhlaXIgdHJhdmVsIHByZWZlcmVuY2VzLCBkYXRlcywgYW5kIGJ1ZGdldFxuMi4gUHJvdmlkaW5nIGRldGFpbGVkIGluZm9ybWF0aW9uIGFib3V0IHRoZWlyIGNob3NlbiBkZXN0aW5hdGlvblxuMy4gTWFraW5nIHN1Z2dlc3Rpb25zIGJhc2VkIG9uIHRoZWlyIGludGVyZXN0cyBhbmQgY29uc3RyYWludHNcblxuQ3VycmVudCBUcmF2ZWwgRGV0YWlsczpcbi0gRGVzdGluYXRpb246ICR7ZGV0YWlscy5kZXN0aW5hdGlvbiB8fCAnTm90IHNwZWNpZmllZCd9XG4tIERhdGVzOiAke2RldGFpbHMuc3RhcnREYXRlID8gYCR7ZGV0YWlscy5zdGFydERhdGV9IHRvICR7ZGV0YWlscy5lbmREYXRlfWAgOiAnTm90IHNwZWNpZmllZCd9XG4tIEJ1ZGdldCBMZXZlbDogJHtkZXRhaWxzLmJ1ZGdldCB8fCAnTm90IHNwZWNpZmllZCd9XG4tIExhbmd1YWdlOiAke2RldGFpbHMubGFuZ3VhZ2UgfHwgJ05vdCBzcGVjaWZpZWQnfVxuLSBQcmVmZXJlbmNlczogJHtkZXRhaWxzLnByZWZlcmVuY2VzPy5qb2luKCcsICcpIHx8ICdOb3Qgc3BlY2lmaWVkJ31cblxuS2VlcCB0aGlzIGNvbnRleHQgaW4gbWluZCB0aHJvdWdob3V0IHRoZSBjb252ZXJzYXRpb24uIElmIGFueSBkZXRhaWwgY2hhbmdlcywgdXBkYXRlIHlvdXIga25vd2xlZGdlIGFjY29yZGluZ2x5LlxuV2hlbiBwcm92aWRpbmcgaW5mb3JtYXRpb24gYWJvdXQgZGVzdGluYXRpb25zLCBpbmNsdWRlIGtleSBhdHRyYWN0aW9ucywgbG9jYWwgY3VsdHVyZSwgYmVzdCB0aW1lcyB0byB2aXNpdCwgYW5kIHJlbGV2YW50IHRyYXZlbCB0aXBzLmA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KCdjb250ZXh0VXBkYXRlZCcsIHRoaXMuY2hhdEhpc3RvcnkpO1xuICAgIH1cblxuICAgIHByaXZhdGUgaGFuZGxlRnVuY3Rpb25DYWxsKGZ1bmN0aW9uTmFtZTogc3RyaW5nLCBhcmdzOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgc3dpdGNoIChmdW5jdGlvbk5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2dldERldGFpbHMnOlxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZ2V0RGV0YWlscycpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndXBkYXRlUHJlZmVyZW5jZXMnOlxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgndXBkYXRlUHJlZmVyZW5jZXMnLCBhcmdzLnByZWZzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3VwZGF0ZURhdGVzJzpcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3VwZGF0ZURhdGVzJywgYXJncy5zdGFydCwgYXJncy5lbmQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndXBkYXRlQnVkZ2V0JzpcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3VwZGF0ZUJ1ZGdldCcsIGFyZ3MubGV2ZWwpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndXBkYXRlTGFuZ3VhZ2UnOlxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgndXBkYXRlTGFuZ3VhZ2UnLCBhcmdzLmxhbmcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFVua25vd24gZnVuY3Rpb24gY2FsbDogJHtmdW5jdGlvbk5hbWV9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgcHJvY2Vzc0FJUmVzcG9uc2UocmVzcG9uc2U6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICAvLyBDaGVjayBmb3IgZnVuY3Rpb24gY2FsbHMgaW4gdGhlIHJlc3BvbnNlXG4gICAgICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbFJlZ2V4ID0gL1xcYihnZXREZXRhaWxzfHVwZGF0ZVByZWZlcmVuY2VzfHVwZGF0ZURhdGVzfHVwZGF0ZUJ1ZGdldHx1cGRhdGVMYW5ndWFnZSlcXCgoLio/KVxcKS9nO1xuICAgICAgICBsZXQgbWF0Y2g7XG5cbiAgICAgICAgd2hpbGUgKChtYXRjaCA9IGZ1bmN0aW9uQ2FsbFJlZ2V4LmV4ZWMocmVzcG9uc2UpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgW18sIGZ1bmN0aW9uTmFtZSwgYXJnc1N0cl0gPSBtYXRjaDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJncyA9IGFyZ3NTdHIgPyBKU09OLnBhcnNlKGB7JHthcmdzU3RyfX1gKSA6IHt9O1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRnVuY3Rpb25DYWxsKGZ1bmN0aW9uTmFtZSwgYXJncyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHByb2Nlc3NpbmcgZnVuY3Rpb24gY2FsbDogJHtlcnJvcn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBzZW5kTWVzc2FnZShtZXNzYWdlOiBzdHJpbmcpOiBQcm9taXNlPFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcjxVaW50OEFycmF5Pj4ge1xuICAgICAgICBjb25zdCB1c2VyTWVzc2FnZSA9IHtcbiAgICAgICAgICAgIGlkOiBEYXRlLm5vdygpLnRvU3RyaW5nKCksXG4gICAgICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgICAgICBjb250ZW50OiBtZXNzYWdlXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5hZGRNZXNzYWdlKHVzZXJNZXNzYWdlKTtcblxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL2NoYXQtdXBkYXRlJywge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgXG4gICAgICAgICAgICAgICAgbWVzc2FnZXM6IHRoaXMuY2hhdEhpc3RvcnkubWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgY3VycmVudERldGFpbHM6IHRoaXMuY3VycmVudERldGFpbHMsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50VXBkYXRlOiBudWxsXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLmVycm9yIHx8ICdGYWlsZWQgdG8gZ2V0IHJlc3BvbnNlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5Py5nZXRSZWFkZXIoKTtcbiAgICAgICAgaWYgKCFyZWFkZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcmVzcG9uc2UgYm9keScpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIGVtcHR5IGFzc2lzdGFudCBtZXNzYWdlIHRoYXQgd2lsbCBiZSB1cGRhdGVkIGR1cmluZyBzdHJlYW1pbmdcbiAgICAgICAgdGhpcy5hZGRNZXNzYWdlKHtcbiAgICAgICAgICAgIGlkOiAoRGF0ZS5ub3coKSArIDEpLnRvU3RyaW5nKCksXG4gICAgICAgICAgICByb2xlOiAnYXNzaXN0YW50JyxcbiAgICAgICAgICAgIGNvbnRlbnQ6ICcnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZWFkZXI7XG4gICAgfVxuXG4gICAgcHVibGljIHVwZGF0ZURldGFpbHMoZGV0YWlsczogUGFydGlhbDxUcmF2ZWxEZXRhaWxzPik6IHZvaWQge1xuICAgICAgICB0aGlzLmN1cnJlbnREZXRhaWxzID0geyAuLi50aGlzLmN1cnJlbnREZXRhaWxzLCAuLi5kZXRhaWxzIH07XG4gICAgICAgIHRoaXMuZW1pdCgnZGV0YWlsc1VwZGF0ZWQnLCB0aGlzLmN1cnJlbnREZXRhaWxzKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0Q3VycmVudERldGFpbHMoKTogVHJhdmVsRGV0YWlscyB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnREZXRhaWxzO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBoYW5kbGVUb29sVXBkYXRlKFxuICAgICAgICB0b29sTmFtZTogQ29tcG9uZW50VHlwZSxcbiAgICAgICAgdmFsdWU6IGFueVxuICAgICk6IFByb21pc2U8e1xuICAgICAgICB1cGRhdGVkRGV0YWlsczogVHJhdmVsRGV0YWlscztcbiAgICAgICAgcmVhZGVyOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI8VWludDhBcnJheT47XG4gICAgfT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlZERldGFpbHMgPSB7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5jdXJyZW50RGV0YWlscyxcbiAgICAgICAgICAgICAgICAuLi4odG9vbE5hbWUgPT09ICdkYXRlUGlja2VyJyA/IHsgXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZTogdmFsdWUuc3RhcnREYXRlLFxuICAgICAgICAgICAgICAgICAgICBlbmREYXRlOiB2YWx1ZS5lbmREYXRlXG4gICAgICAgICAgICAgICAgfSA6IHt9KSxcbiAgICAgICAgICAgICAgICAuLi4odG9vbE5hbWUgPT09ICdwcmVmZXJlbmNlU2VsZWN0b3InID8geyBwcmVmZXJlbmNlczogdmFsdWUgfSA6IHt9KSxcbiAgICAgICAgICAgICAgICAuLi4odG9vbE5hbWUgPT09ICdidWRnZXRTZWxlY3RvcicgPyB7IGJ1ZGdldDogdmFsdWUgfSA6IHt9KSxcbiAgICAgICAgICAgICAgICAuLi4odG9vbE5hbWUgPT09ICdsYW5ndWFnZVNlbGVjdG9yJyA/IHsgbGFuZ3VhZ2U6IHZhbHVlIH0gOiB7fSlcbiAgICAgICAgICAgIH07XG4gICAgXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnREZXRhaWxzID0gdXBkYXRlZERldGFpbHM7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVNZXNzYWdlID0gdGhpcy5mb3JtYXRVcGRhdGVNZXNzYWdlKHRvb2xOYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0Qm9keSA9IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlczogW3tcbiAgICAgICAgICAgICAgICAgICAgcm9sZTogJ3VzZXInLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiB1cGRhdGVNZXNzYWdlXG4gICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgY3VycmVudERldGFpbHM6IHVwZGF0ZWREZXRhaWxzLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudFVwZGF0ZTogeyBcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdG9vbE5hbWUsIFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9jaGF0LXVwZGF0ZScsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7IFxuICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0Qm9keSlcbiAgICAgICAgICAgIH0pO1xuICAgIFxuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFQSSBFcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9IC0gJHtlcnJvclRleHR9YCk7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5Py5nZXRSZWFkZXIoKTtcbiAgICAgICAgICAgIGlmICghcmVhZGVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyByZXNwb25zZSBib2R5IGF2YWlsYWJsZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmFkZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGlkOiBEYXRlLm5vdygpLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgcm9sZTogJ2Fzc2lzdGFudCcsXG4gICAgICAgICAgICAgICAgY29udGVudDogJycsXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGV0YWlsczogdXBkYXRlZERldGFpbHMsXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVR5cGU6IHRvb2xOYW1lXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2RldGFpbHNVcGRhdGVkJywgdXBkYXRlZERldGFpbHMpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCd1cGRhdGVTdGFydGVkJywgeyB0b29sTmFtZSwgdmFsdWUgfSk7XG4gICAgXG4gICAgICAgICAgICByZXR1cm4geyB1cGRhdGVkRGV0YWlscywgcmVhZGVyIH07XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3VwZGF0ZUVycm9yJywgeyBcbiAgICAgICAgICAgICAgICB0b29sTmFtZSwgXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ0FQSSBjb25uZWN0aW9uIGZhaWxlZCcsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiBlcnJvci5zdGF0dXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgZm9ybWF0VXBkYXRlTWVzc2FnZSh0b29sTmFtZTogQ29tcG9uZW50VHlwZSwgdmFsdWU6IGFueSk6IHN0cmluZyB7XG4gICAgICAgIHN3aXRjaCAodG9vbE5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2RhdGVQaWNrZXInOlxuICAgICAgICAgICAgICAgIHJldHVybiBgSSd2ZSBzZWxlY3RlZCB0aGVzZSB0cmF2ZWwgZGF0ZXM6ICR7dmFsdWUuc3RhcnREYXRlfSB0byAke3ZhbHVlLmVuZERhdGV9YDtcbiAgICAgICAgICAgIGNhc2UgJ3ByZWZlcmVuY2VTZWxlY3Rvcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBJJ3ZlIHVwZGF0ZWQgbXkgdHJhdmVsIHByZWZlcmVuY2VzIHRvOiAke0FycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUuam9pbignLCAnKSA6IHZhbHVlfWA7XG4gICAgICAgICAgICBjYXNlICdidWRnZXRTZWxlY3Rvcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBJJ3ZlIHNldCBteSB0cmF2ZWwgYnVkZ2V0IHRvOiAke3ZhbHVlfWA7XG4gICAgICAgICAgICBjYXNlICdsYW5ndWFnZVNlbGVjdG9yJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYEknZCBsaWtlIHRoZSBQREYgZXhwb3J0IGluIHRoaXMgbGFuZ3VhZ2U6ICR7dmFsdWV9YDtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBJJ3ZlIHVwZGF0ZWQgbXkgJHt0b29sTmFtZS5yZXBsYWNlKC8oW0EtWl0pL2csICcgJDEnKS50b0xvd2VyQ2FzZSgpfSB0bzogJHtBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLmpvaW4oJywgJykgOiB2YWx1ZX1gO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIHByb2Nlc3NTdHJlYW1pbmdSZXNwb25zZShcbiAgICAgICAgcmVhZGVyOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI8VWludDhBcnJheT4sXG4gICAgICAgIG9uQ2h1bms6IChjb250ZW50OiBzdHJpbmcpID0+IHZvaWRcbiAgICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ1twcm9jZXNzU3RyZWFtaW5nUmVzcG9uc2VdIFN0YXJ0aW5nIHRvIHByb2Nlc3Mgc3RyZWFtJyk7XG4gICAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgICAgICAgbGV0IGJ1ZmZlciA9ICcnO1xuICAgICAgICBsZXQgY3VycmVudE1lc3NhZ2UgPSB0aGlzLmNoYXRIaXN0b3J5Lm1lc3NhZ2VzW3RoaXMuY2hhdEhpc3RvcnkubWVzc2FnZXMubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1twcm9jZXNzU3RyZWFtaW5nUmVzcG9uc2VdIFJlYWRpbmcgY2h1bmsuLi4nKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbcHJvY2Vzc1N0cmVhbWluZ1Jlc3BvbnNlXSBTdHJlYW0gY29tcGxldGUnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBkZWNvZGVyLmRlY29kZSh2YWx1ZSwgeyBzdHJlYW06IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1twcm9jZXNzU3RyZWFtaW5nUmVzcG9uc2VdIFJhdyBjaHVuayByZWNlaXZlZDonLCBjaHVuayk7XG4gICAgICAgICAgICAgICAgYnVmZmVyICs9IGNodW5rO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gYnVmZmVyLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICBidWZmZXIgPSBsaW5lcy5wb3AoKSB8fCAnJztcblxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW3Byb2Nlc3NTdHJlYW1pbmdSZXNwb25zZV0gUHJvY2Vzc2luZyBsaW5lOicsIGxpbmUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGluZS5zdGFydHNXaXRoKCdkYXRhOiAnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGxpbmUuc2xpY2UoNik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSA9PT0gJ1tET05FXScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW3Byb2Nlc3NTdHJlYW1pbmdSZXNwb25zZV0gUmVjZWl2ZWQgW0RPTkVdIHNpZ25hbCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1twcm9jZXNzU3RyZWFtaW5nUmVzcG9uc2VdIFBhcnNlZCBkYXRhOicsIHBhcnNlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlZC5jaG9pY2VzPy5bMF0/LmRlbHRhPy5jb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBwYXJzZWQuY2hvaWNlc1swXS5kZWx0YS5jb250ZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW3Byb2Nlc3NTdHJlYW1pbmdSZXNwb25zZV0gQ29udGVudCBjaHVuazonLCBjb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaHVuayhjb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgY3VycmVudCBtZXNzYWdlIGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50TWVzc2FnZS5jb250ZW50ICs9IGNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignW3Byb2Nlc3NTdHJlYW1pbmdSZXNwb25zZV0gRXJyb3IgcGFyc2luZyBkYXRhOicsIGUsICdSYXcgZGF0YTonLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUHJvY2VzcyBhbnkgZnVuY3Rpb24gY2FsbHMgaW4gdGhlIGNvbXBsZXRlIG1lc3NhZ2VcbiAgICAgICAgICAgIGlmIChjdXJyZW50TWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbcHJvY2Vzc1N0cmVhbWluZ1Jlc3BvbnNlXSBGaW5hbCBtZXNzYWdlOicsIGN1cnJlbnRNZXNzYWdlLmNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc0FJUmVzcG9uc2UoY3VycmVudE1lc3NhZ2UuY29udGVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZVVwZGF0ZWQnLCBjdXJyZW50TWVzc2FnZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbcHJvY2Vzc1N0cmVhbWluZ1Jlc3BvbnNlXSBTdHJlYW0gcHJvY2Vzc2luZyBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbcHJvY2Vzc1N0cmVhbWluZ1Jlc3BvbnNlXSBDbGVhbmluZyB1cCBzdHJlYW0nKTtcbiAgICAgICAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICAgICAgICB9XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbIkV2ZW50RW1pdHRlciIsIlN1cHBvcnRlZExhbmd1YWdlIiwiQUlDaGF0TWFuYWdlciIsImluaXRpYWxpemVDaGF0SGlzdG9yeSIsIm1lc3NhZ2VzIiwibWV0YWRhdGEiLCJsYXN0SW50ZXJhY3Rpb25UaW1lIiwiRGF0ZSIsImN1cnJlbnRTdGF0ZSIsInZhbGlkUGFyYW1ldGVycyIsImhhbmRsZU1lc3NhZ2UiLCJtZXNzYWdlIiwiYWRkTWVzc2FnZSIsImlkIiwibm93IiwidG9TdHJpbmciLCJyb2xlIiwiY29udGVudCIsInJlc3BvbnNlIiwicHJvY2Vzc01lc3NhZ2UiLCJkYXRhIiwiY3VycmVudERldGFpbHMiLCJwYXJhbWV0ZXJzIiwiZXJyb3IiLCJjb25zb2xlIiwiRXJyb3IiLCJjaGF0SGlzdG9yeSIsInJlY292ZXJDb252ZXJzYXRpb24iLCJ1cGRhdGVkUGFyYW1ldGVycyIsImV4dHJhY3RQYXJhbWV0ZXJzIiwidmFsaWRhdGlvblJlc3VsdCIsInZhbGlkYXRlUGFyYW1ldGVycyIsImlzVmFsaWQiLCJ1cGRhdGVTdGF0ZSIsIm1pc3NpbmdQYXJhbXMiLCJqb2luIiwic3VnZ2VzdGVkQWN0aW9uIiwiQXJyYXkiLCJmcm9tIiwicmVxdWlyZWRQYXJhbWV0ZXJzIiwiZmlsdGVyIiwicGFyYW0iLCJpbnZhbGlkUGFyYW1zIiwiYnVkZ2V0IiwiaW5jbHVkZXMiLCJwdXNoIiwibGFuZ3VhZ2UiLCJPYmplY3QiLCJrZXlzIiwicHJlZmVyZW5jZXMiLCJzb21lIiwicHJlZiIsImxlbmd0aCIsImdldEN1cnJlbnRQYXJhbWV0ZXJzIiwibWF4SGlzdG9yeUxlbmd0aCIsInNsaWNlIiwiZW1pdCIsImdldENvbnRleHRIaXN0b3J5IiwibGFzdE1lc3NhZ2UiLCJyZXZlcnNlIiwiZmluZCIsIm1zZyIsIm5ld1N0YXRlIiwiY3VycmVudFBhcmFtcyIsImNsZWFySGlzdG9yeSIsImZvcm1hdE1lc3NhZ2VDb250ZW50IiwidHJpbW1lZENvbnRlbnQiLCJyZXBsYWNlIiwidHJpbSIsInVwZGF0ZVN5c3RlbUNvbnRleHQiLCJkZXRhaWxzIiwic3lzdGVtTWVzc2FnZSIsIm0iLCJkZXN0aW5hdGlvbiIsInN0YXJ0RGF0ZSIsImVuZERhdGUiLCJoYW5kbGVGdW5jdGlvbkNhbGwiLCJmdW5jdGlvbk5hbWUiLCJhcmdzIiwicHJlZnMiLCJzdGFydCIsImVuZCIsImxldmVsIiwibGFuZyIsIndhcm4iLCJwcm9jZXNzQUlSZXNwb25zZSIsImZ1bmN0aW9uQ2FsbFJlZ2V4IiwibWF0Y2giLCJleGVjIiwiXyIsImFyZ3NTdHIiLCJKU09OIiwicGFyc2UiLCJzZW5kTWVzc2FnZSIsInVzZXJNZXNzYWdlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsInN0cmluZ2lmeSIsImNvbXBvbmVudFVwZGF0ZSIsIm9rIiwiZXJyb3JEYXRhIiwianNvbiIsInJlYWRlciIsImdldFJlYWRlciIsInVwZGF0ZURldGFpbHMiLCJnZXRDdXJyZW50RGV0YWlscyIsImhhbmRsZVRvb2xVcGRhdGUiLCJ0b29sTmFtZSIsInZhbHVlIiwidXBkYXRlZERldGFpbHMiLCJ1cGRhdGVNZXNzYWdlIiwiZm9ybWF0VXBkYXRlTWVzc2FnZSIsInJlcXVlc3RCb2R5IiwidHlwZSIsInRpbWVzdGFtcCIsImVycm9yVGV4dCIsInRleHQiLCJzdGF0dXMiLCJ1cGRhdGVUeXBlIiwiaXNBcnJheSIsInRvTG93ZXJDYXNlIiwicHJvY2Vzc1N0cmVhbWluZ1Jlc3BvbnNlIiwib25DaHVuayIsImxvZyIsImRlY29kZXIiLCJUZXh0RGVjb2RlciIsImJ1ZmZlciIsImN1cnJlbnRNZXNzYWdlIiwiZG9uZSIsInJlYWQiLCJjaHVuayIsImRlY29kZSIsInN0cmVhbSIsImxpbmVzIiwic3BsaXQiLCJwb3AiLCJsaW5lIiwic3RhcnRzV2l0aCIsInBhcnNlZCIsImNob2ljZXMiLCJkZWx0YSIsImUiLCJyZWxlYXNlTG9jayIsImNvbnN0cnVjdG9yIiwiaW5pdGlhbERldGFpbHMiLCJTZXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./managers/ai-chat-manager.ts\n"));

/***/ })

});