/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["components_map-component_tsx"],{

/***/ "./components/map-component.tsx":
/*!**************************************!*\
  !*** ./components/map-component.tsx ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_script__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/script */ \"./node_modules/next/script.js\");\n/* harmony import */ var next_script__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_script__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _utils_places_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/utils/places-utils */ \"./utils/places-utils.ts\");\n\nvar _s = $RefreshSig$();\n\n\n\nconst MapComponent = (param)=>{\n    let { city, apiKey } = param;\n    _s();\n    const mapRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [map, setMap] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [markers, setMarkers] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(new Map());\n    const [infoWindow, setInfoWindow] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [scriptLoaded, setScriptLoaded] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [selectedPlace, setSelectedPlace] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        console.log(\"MapComponent: Received props:\", {\n            city,\n            apiKeyLength: apiKey === null || apiKey === void 0 ? void 0 : apiKey.length\n        });\n        if (!apiKey) {\n            console.error(\"MapComponent: Google Maps API key is missing\");\n            setError(\"Google Maps API key is missing\");\n            setIsLoading(false);\n            return;\n        }\n        if (!scriptLoaded || !mapRef.current) {\n            console.log(\"MapComponent: Waiting for script to load or map ref to be ready...\");\n            return;\n        }\n        console.log(\"MapComponent: Initializing map with city:\", city);\n        const initMap = async ()=>{\n            try {\n                // Import required libraries\n                const { Map: Map1 } = await window.google.maps.importLibrary(\"maps\");\n                const { AdvancedMarkerElement } = await google.maps.importLibrary(\"marker\");\n                const geocoder = new window.google.maps.Geocoder();\n                geocoder.geocode({\n                    address: city\n                }, async (results, status)=>{\n                    var _results__geometry, _results_;\n                    console.log(\"Geocoding response:\", {\n                        status,\n                        resultsLength: results === null || results === void 0 ? void 0 : results.length\n                    });\n                    if (status !== \"OK\" || !(results === null || results === void 0 ? void 0 : (_results_ = results[0]) === null || _results_ === void 0 ? void 0 : (_results__geometry = _results_.geometry) === null || _results__geometry === void 0 ? void 0 : _results__geometry.location)) {\n                        console.error(\"Geocoding failed:\", status);\n                        setError(\"Could not find location for \".concat(city));\n                        setIsLoading(false);\n                        return;\n                    }\n                    try {\n                        const location = results[0].geometry.location;\n                        const newMap = new Map1(mapRef.current, {\n                            center: location,\n                            zoom: 12,\n                            mapId: \"2d604af04a7c7fa8\"\n                        });\n                        setMap(newMap);\n                        const newInfoWindow = new google.maps.InfoWindow({\n                            maxWidth: 400\n                        });\n                        setInfoWindow(newInfoWindow);\n                        const createCityInfoWindowContent = async (city, location)=>{\n                            try {\n                                // Search for the city to get its details including photos\n                                const cityPlace = await (0,_utils_places_utils__WEBPACK_IMPORTED_MODULE_3__.searchPlaceByText)(city, {\n                                    latitude: location.lat(),\n                                    longitude: location.lng()\n                                });\n                                if (!cityPlace) return null;\n                                // Create a photo carousel HTML\n                                const photoCarousel = cityPlace.photos && cityPlace.photos.length > 0 ? '\\n                                            <div class=\"relative w-full\" style=\"height: 200px;\">\\n                                                <div class=\"carousel-container overflow-hidden w-full h-full\">\\n                                                    <div class=\"carousel-track flex transition-transform duration-500\" style=\"height: 100%;\">\\n                                                        '.concat(cityPlace.photos.slice(0, 5).map((photo, index)=>'\\n                                                            <div class=\"carousel-slide w-full h-full flex-none\">\\n                                                                <img src=\"https://places.googleapis.com/v1/'.concat(photo.name, \"/media?maxHeightPx=340&maxWidthPx=340&key=\").concat(apiKey, '\"\\n                                                                    alt=\"').concat(city, '\"\\n                                                                    class=\"w-full h-full object-cover\"\\n                                                                />\\n                                                            </div>\\n                                                        ')).join(\"\"), '\\n                                                    </div>\\n                                                </div>\\n                                                <button onclick=\"window.prevSlide()\" class=\"absolute left-2 top-1/2 transform -translate-y-1/2 bg-white/80 rounded-full p-1 shadow-md hover:bg-white\">\\n                                                    <svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\" class=\"w-5 h-5\">\\n                                                        <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M15.75 19.5L8.25 12l7.5-7.5\" />\\n                                                    </svg>\\n                                                </button>\\n                                                <button onclick=\"window.nextSlide()\" class=\"absolute right-2 top-1/2 transform -translate-y-1/2 bg-white/80 rounded-full p-1 shadow-md hover:bg-white\">\\n                                                    <svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\" class=\"w-5 h-5\">\\n                                                        <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M8.25 4.5l7.5 7.5-7.5 7.5\" />\\n                                                    </svg>\\n                                                </button>\\n                                                <div class=\"absolute bottom-2 left-0 right-0 flex justify-center gap-1\">\\n                                                    ').concat(cityPlace.photos.slice(0, 5).map((_, index)=>'\\n                                                        <button onclick=\"window.goToSlide('.concat(index, ')\" class=\"w-2 h-2 rounded-full bg-white/80 hover:bg-white shadow-sm carousel-dot\" data-index=\"').concat(index, '\">\\n                                                        </button>\\n                                                    ')).join(\"\"), \"\\n                                                </div>\\n                                            </div>\\n                                        \") : \"\";\n                                // Add carousel control functions to window\n                                if (cityPlace.photos && cityPlace.photos.length > 0) {\n                                    const numSlides = Math.min(cityPlace.photos.length, 5);\n                                    window.currentSlide = 0;\n                                    window.updateCarousel = ()=>{\n                                        const track = document.querySelector(\".carousel-track\");\n                                        if (track) {\n                                            track.style.transform = \"translateX(-\".concat(window.currentSlide * 100, \"%)\");\n                                            // Update dots\n                                            document.querySelectorAll(\".carousel-dot\").forEach((dot, index)=>{\n                                                if (index === window.currentSlide) {\n                                                    dot.classList.add(\"bg-white\");\n                                                    dot.classList.remove(\"bg-white/80\");\n                                                } else {\n                                                    dot.classList.remove(\"bg-white\");\n                                                    dot.classList.add(\"bg-white/80\");\n                                                }\n                                            });\n                                        }\n                                    };\n                                    window.nextSlide = ()=>{\n                                        window.currentSlide = (window.currentSlide + 1) % numSlides;\n                                        window.updateCarousel();\n                                    };\n                                    window.prevSlide = ()=>{\n                                        window.currentSlide = (window.currentSlide - 1 + numSlides) % numSlides;\n                                        window.updateCarousel();\n                                    };\n                                    window.goToSlide = (index)=>{\n                                        window.currentSlide = index;\n                                        window.updateCarousel();\n                                    };\n                                }\n                                return '\\n                                        <div class=\"bg-white rounded-lg shadow-sm\" style=\"max-width: 340px;\">\\n                                            '.concat(photoCarousel, '\\n                                            <div class=\"p-4\">\\n                                                <h2 class=\"text-xl font-semibold text-gray-900 mb-2\">').concat(city, \"</h2>\\n                                                \").concat(cityPlace.formattedAddress ? '<p class=\"text-sm text-gray-500 mb-2\">'.concat(cityPlace.formattedAddress, \"</p>\") : \"\", \"\\n                                            </div>\\n                                        </div>\\n                                    \");\n                            } catch (error) {\n                                console.error(\"Error creating city info window:\", error);\n                                return null;\n                            }\n                        };\n                        // Create a marker for the city\n                        const cityMarker = new google.maps.marker.AdvancedMarkerElement({\n                            map: newMap,\n                            position: location,\n                            title: city\n                        });\n                        // Add click listener to the marker\n                        cityMarker.addListener(\"click\", async ()=>{\n                            if (infoWindow) {\n                                const content = createCityInfoWindowContent(city, location);\n                                if (content) {\n                                    infoWindow.setContent(await content);\n                                    infoWindow.open(newMap, cityMarker);\n                                }\n                            }\n                        });\n                        markers.set(city, cityMarker);\n                        // Add click listener for future interaction\n                        cityMarker.addListener(\"click\", async ()=>{\n                            const content = await createCityInfoWindowContent(city, location);\n                            if (content) {\n                                newInfoWindow.setContent(content);\n                                newInfoWindow.open({\n                                    anchor: cityMarker,\n                                    map: newMap\n                                });\n                            }\n                        });\n                    } catch (err) {\n                        console.error(\"Error setting up map:\", err);\n                        setError(\"Failed to initialize map\");\n                    }\n                });\n            } catch (err) {\n                console.error(\"Error initializing map:\", err);\n                setError(\"Failed to initialize map\");\n                setIsLoading(false);\n            }\n        };\n        initMap();\n    }, [\n        city,\n        scriptLoaded,\n        apiKey\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!map) return;\n        window.addPlaceToMap = async (placeData)=>{\n            try {\n                // Import both marker and pin libraries\n                const [{ AdvancedMarkerElement }, { PinElement }] = await Promise.all([\n                    google.maps.importLibrary(\"marker\"),\n                    google.maps.importLibrary(\"marker\")\n                ]);\n                // Create a custom pin element\n                const pinElement = new google.maps.marker.PinElement({\n                    // background: \"#FBBC04\",\n                    // borderColor: \"#EA4335\",\n                    // glyphColor: \"#000000\",\n                    scale: 1\n                });\n                const marker = new google.maps.marker.AdvancedMarkerElement({\n                    map,\n                    position: {\n                        lat: placeData.latitude,\n                        lng: placeData.longitude\n                    },\n                    title: placeData.title,\n                    content: pinElement.element,\n                    gmpDraggable: false\n                });\n                // Add click listener\n                marker.addListener(\"click\", ()=>{\n                    if (placeData.place) {\n                        // Your existing click handler logic\n                        const content = createPlaceInfoWindowContent(placeData.place);\n                        if (content && infoWindow) {\n                            infoWindow.setContent(content);\n                            infoWindow.open(map, marker);\n                        }\n                    }\n                });\n                // Store the marker reference\n                markers.set(placeData.title || \"unnamed\", marker);\n            } catch (err) {\n                console.error(\"Error adding place marker:\", err);\n            }\n        };\n        window.clearPlaceMarkers = ()=>{\n            markers.forEach((marker)=>{\n                marker.setMap(null);\n            });\n            markers.clear();\n        };\n        return ()=>{\n            delete window.addPlaceToMap;\n            delete window.clearPlaceMarkers;\n        };\n    }, [\n        map,\n        infoWindow\n    ]);\n    const createPlaceInfoWindowContent = (place)=>{\n        const photoUrl = place.photos && place.photos[0] ? \"https://places.googleapis.com/v1/\".concat(place.photos[0].name, \"/media?maxHeightPx=200&maxWidthPx=300&key=\").concat(apiKey) : \"\";\n        return '\\n            <div class=\"bg-white rounded-lg shadow-sm\" style=\"max-width: 300px;\">\\n                '.concat(photoUrl ? '\\n                    <div style=\"height: 150px; width: 100%;\">\\n                        <img src=\"'.concat(photoUrl, '\" \\n                            alt=\"').concat(typeof place.displayName === \"string\" ? place.displayName : place.displayName.text, '\"\\n                            style=\"width: 100%; height: 100%; object-fit: cover; border-top-left-radius: 0.5rem; border-top-right-radius: 0.5rem;\"\\n                        />\\n                    </div>\\n                ') : \"\", '\\n                <div class=\"p-3\">\\n                    <h3 class=\"text-lg font-semibold text-gray-900 mb-1\">\\n                        ').concat(typeof place.displayName === \"string\" ? place.displayName : place.displayName.text, \"\\n                    </h3>\\n                    \").concat(place.primaryTypeDisplayName ? '<div class=\"text-sm text-gray-600 mb-1\">\\n                            '.concat(place.primaryTypeDisplayName.text, \"\\n                            </div>\") : \"\", \"\\n                    \").concat(place.formattedAddress ? '<p class=\"text-sm text-gray-500\">\\n                            '.concat(place.formattedAddress, \"\\n                            </p>\") : \"\", \"\\n                </div>\\n            </div>\\n        \");\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"relative w-full h-full min-h-[340px]\",\n        children: [\n            apiKey && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_script__WEBPACK_IMPORTED_MODULE_2___default()), {\n                src: \"https://maps.googleapis.com/maps/api/js?key=\".concat(apiKey, \"&libraries=places,marker&v=beta&callback=Function.prototype\"),\n                strategy: \"afterInteractive\",\n                onLoad: ()=>{\n                    console.log(\"Google Maps script loaded\");\n                    setScriptLoaded(true);\n                },\n                onError: (e)=>{\n                    console.error(\"Failed to load Google Maps script:\", e);\n                    setError(\"Failed to load Google Maps\");\n                    setIsLoading(false);\n                }\n            }, void 0, false, {\n                fileName: \"/Users/terrancehah/Documents/terrancehah.com/components/map-component.tsx\",\n                lineNumber: 348,\n                columnNumber: 17\n            }, undefined),\n            error && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"absolute inset-0 flex items-center justify-center bg-gray-100 text-red-500 p-4 text-center\",\n                children: error\n            }, void 0, false, {\n                fileName: \"/Users/terrancehah/Documents/terrancehah.com/components/map-component.tsx\",\n                lineNumber: 363,\n                columnNumber: 17\n            }, undefined),\n            isLoading && !error && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"absolute inset-0 flex items-center justify-center bg-gray-100\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"text-gray-600\",\n                    children: [\n                        \"Loading map...\",\n                        !apiKey && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: \"Waiting for API key...\"\n                        }, void 0, false, {\n                            fileName: \"/Users/terrancehah/Documents/terrancehah.com/components/map-component.tsx\",\n                            lineNumber: 371,\n                            columnNumber: 37\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/terrancehah/Documents/terrancehah.com/components/map-component.tsx\",\n                    lineNumber: 369,\n                    columnNumber: 21\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/Users/terrancehah/Documents/terrancehah.com/components/map-component.tsx\",\n                lineNumber: 368,\n                columnNumber: 17\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                ref: mapRef,\n                className: \"w-full h-full\"\n            }, void 0, false, {\n                fileName: \"/Users/terrancehah/Documents/terrancehah.com/components/map-component.tsx\",\n                lineNumber: 375,\n                columnNumber: 13\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/terrancehah/Documents/terrancehah.com/components/map-component.tsx\",\n        lineNumber: 346,\n        columnNumber: 9\n    }, undefined);\n};\n_s(MapComponent, \"DjppaNpR4krxPZNUsBds4eL8Guo=\");\n_c = MapComponent;\n/* harmony default export */ __webpack_exports__[\"default\"] = (MapComponent);\nvar _c;\n$RefreshReg$(_c, \"MapComponent\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL21hcC1jb21wb25lbnQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUEyRDtBQUMxQjtBQUMrQjtBQW1DaEUsTUFBTU0sZUFBNEM7UUFBQyxFQUFFQyxJQUFJLEVBQUVDLE1BQU0sRUFBRTs7SUFDL0QsTUFBTUMsU0FBU1AsNkNBQU1BLENBQWlCO0lBQ3RDLE1BQU0sQ0FBQ1EsS0FBS0MsT0FBTyxHQUFHUiwrQ0FBUUEsQ0FBeUI7SUFDdkQsTUFBTSxDQUFDUyxTQUFTQyxXQUFXLEdBQUdWLCtDQUFRQSxDQUF3RCxJQUFJVztJQUNsRyxNQUFNLENBQUNDLFlBQVlDLGNBQWMsR0FBR2IsK0NBQVFBLENBQWdDO0lBQzVFLE1BQU0sQ0FBQ2MsT0FBT0MsU0FBUyxHQUFHZiwrQ0FBUUEsQ0FBZ0I7SUFDbEQsTUFBTSxDQUFDZ0IsV0FBV0MsYUFBYSxHQUFHakIsK0NBQVFBLENBQUM7SUFDM0MsTUFBTSxDQUFDa0IsY0FBY0MsZ0JBQWdCLEdBQUduQiwrQ0FBUUEsQ0FBQztJQUNqRCxNQUFNLENBQUNvQixlQUFlQyxpQkFBaUIsR0FBR3JCLCtDQUFRQSxDQUFlO0lBRWpFRixnREFBU0EsQ0FBQztRQUNOd0IsUUFBUUMsR0FBRyxDQUFDLGlDQUFpQztZQUFFbkI7WUFBTW9CLFlBQVksRUFBRW5CLG1CQUFBQSw2QkFBQUEsT0FBUW9CLE1BQU07UUFBQztRQUVsRixJQUFJLENBQUNwQixRQUFRO1lBQ1RpQixRQUFRUixLQUFLLENBQUM7WUFDZEMsU0FBUztZQUNURSxhQUFhO1lBQ2I7UUFDSjtRQUVBLElBQUksQ0FBQ0MsZ0JBQWdCLENBQUNaLE9BQU9vQixPQUFPLEVBQUU7WUFDbENKLFFBQVFDLEdBQUcsQ0FBQztZQUNaO1FBQ0o7UUFFQUQsUUFBUUMsR0FBRyxDQUFDLDZDQUE2Q25CO1FBQ3pELE1BQU11QixVQUFVO1lBQ1osSUFBSTtnQkFDQSw0QkFBNEI7Z0JBQzVCLE1BQU0sRUFBRWhCLEtBQUFBLElBQUcsRUFBRSxHQUFHLE1BQU1pQixPQUFPQyxNQUFNLENBQUNDLElBQUksQ0FBQ0MsYUFBYSxDQUFDO2dCQUN2RCxNQUFNLEVBQUVDLHFCQUFxQixFQUFFLEdBQUcsTUFBTUgsT0FBT0MsSUFBSSxDQUFDQyxhQUFhLENBQUM7Z0JBQ2xFLE1BQU1FLFdBQVcsSUFBSUwsT0FBT0MsTUFBTSxDQUFDQyxJQUFJLENBQUNJLFFBQVE7Z0JBRWhERCxTQUFTRSxPQUFPLENBQ1o7b0JBQUVDLFNBQVNoQztnQkFBSyxHQUNoQixPQUFPaUMsU0FBU0M7d0JBR1lELG9CQUFBQTtvQkFGeEJmLFFBQVFDLEdBQUcsQ0FBQyx1QkFBdUI7d0JBQUVlO3dCQUFRQyxhQUFhLEVBQUVGLG9CQUFBQSw4QkFBQUEsUUFBU1osTUFBTTtvQkFBQztvQkFFNUUsSUFBSWEsV0FBVyxRQUFRLEVBQUNELG9CQUFBQSwrQkFBQUEsWUFBQUEsT0FBUyxDQUFDLEVBQUUsY0FBWkEsaUNBQUFBLHFCQUFBQSxVQUFjRyxRQUFRLGNBQXRCSCx5Q0FBQUEsbUJBQXdCSSxRQUFRLEdBQUU7d0JBQ3REbkIsUUFBUVIsS0FBSyxDQUFDLHFCQUFxQndCO3dCQUNuQ3ZCLFNBQVMsK0JBQW9DLE9BQUxYO3dCQUN4Q2EsYUFBYTt3QkFDYjtvQkFDSjtvQkFFQSxJQUFJO3dCQUNBLE1BQU13QixXQUFXSixPQUFPLENBQUMsRUFBRSxDQUFDRyxRQUFRLENBQUNDLFFBQVE7d0JBQzdDLE1BQU1DLFNBQVMsSUFBSS9CLEtBQUlMLE9BQU9vQixPQUFPLEVBQUc7NEJBQ3BDaUIsUUFBUUY7NEJBQ1JHLE1BQU07NEJBQ05DLE9BQU87d0JBQ1g7d0JBRUFyQyxPQUFPa0M7d0JBRVAsTUFBTUksZ0JBQWdCLElBQUlqQixPQUFPQyxJQUFJLENBQUNpQixVQUFVLENBQUM7NEJBQzdDQyxVQUFVO3dCQUNkO3dCQUNBbkMsY0FBY2lDO3dCQUVkLE1BQU1HLDhCQUE4QixPQUFPN0MsTUFBY3FDOzRCQUNyRCxJQUFJO2dDQUNBLDBEQUEwRDtnQ0FDMUQsTUFBTVMsWUFBWSxNQUFNaEQsc0VBQWlCQSxDQUFDRSxNQUFNO29DQUM1QytDLFVBQVVWLFNBQVNXLEdBQUc7b0NBQ3RCQyxXQUFXWixTQUFTYSxHQUFHO2dDQUMzQjtnQ0FFQSxJQUFJLENBQUNKLFdBQVcsT0FBTztnQ0FFdkIsK0JBQStCO2dDQUMvQixNQUFNSyxnQkFBZ0JMLFVBQVVNLE1BQU0sSUFBSU4sVUFBVU0sTUFBTSxDQUFDL0IsTUFBTSxHQUFHLElBQzlELDhaQXlCWXlCLE9BckJJQSxVQUFVTSxNQUFNLENBQUNDLEtBQUssQ0FBQyxHQUFHLEdBQUdsRCxHQUFHLENBQUMsQ0FBQ21ELE9BQU9DLFFBQVUsa09BRXVEdEQsT0FBdkRxRCxNQUFNRSxJQUFJLEVBQUMsOENBQzdDeEQsT0FEeUZDLFFBQU8sZ0ZBQzNGLE9BQUxELE1BQUssZ1RBSXJCeUQsSUFBSSxDQUFDLEtBQUkscWpEQWlCSixPQUhWWCxVQUFVTSxNQUFNLENBQUNDLEtBQUssQ0FBQyxHQUFHLEdBQUdsRCxHQUFHLENBQUMsQ0FBQ3VELEdBQUdILFFBQVUsK0ZBQzZGQSxPQUF0R0EsT0FBTSxrR0FBc0csT0FBTkEsT0FBTSxnSUFFakpFLElBQUksQ0FBQyxLQUFJLDRKQUl0QjtnQ0FFTiwyQ0FBMkM7Z0NBQzNDLElBQUlYLFVBQVVNLE1BQU0sSUFBSU4sVUFBVU0sTUFBTSxDQUFDL0IsTUFBTSxHQUFHLEdBQUc7b0NBQ2pELE1BQU1zQyxZQUFZQyxLQUFLQyxHQUFHLENBQUNmLFVBQVVNLE1BQU0sQ0FBQy9CLE1BQU0sRUFBRTtvQ0FDcERHLE9BQU9zQyxZQUFZLEdBQUc7b0NBRXRCdEMsT0FBT3VDLGNBQWMsR0FBRzt3Q0FDcEIsTUFBTUMsUUFBUUMsU0FBU0MsYUFBYSxDQUFDO3dDQUNyQyxJQUFJRixPQUFPOzRDQUNOQSxNQUFzQkcsS0FBSyxDQUFDQyxTQUFTLEdBQUcsZUFBeUMsT0FBMUI1QyxPQUFPc0MsWUFBWSxHQUFHLEtBQUk7NENBQ2xGLGNBQWM7NENBQ2RHLFNBQVNJLGdCQUFnQixDQUFDLGlCQUFpQkMsT0FBTyxDQUFDLENBQUNDLEtBQUtoQjtnREFDckQsSUFBSUEsVUFBVS9CLE9BQU9zQyxZQUFZLEVBQUU7b0RBQy9CUyxJQUFJQyxTQUFTLENBQUNDLEdBQUcsQ0FBQztvREFDbEJGLElBQUlDLFNBQVMsQ0FBQ0UsTUFBTSxDQUFDO2dEQUN6QixPQUFPO29EQUNISCxJQUFJQyxTQUFTLENBQUNFLE1BQU0sQ0FBQztvREFDckJILElBQUlDLFNBQVMsQ0FBQ0MsR0FBRyxDQUFDO2dEQUN0Qjs0Q0FDSjt3Q0FDSjtvQ0FDSjtvQ0FFQWpELE9BQU9tRCxTQUFTLEdBQUc7d0NBQ2ZuRCxPQUFPc0MsWUFBWSxHQUFHLENBQUN0QyxPQUFPc0MsWUFBWSxHQUFHLEtBQUtIO3dDQUNsRG5DLE9BQU91QyxjQUFjO29DQUN6QjtvQ0FFQXZDLE9BQU9vRCxTQUFTLEdBQUc7d0NBQ2ZwRCxPQUFPc0MsWUFBWSxHQUFHLENBQUN0QyxPQUFPc0MsWUFBWSxHQUFHLElBQUlILFNBQVEsSUFBS0E7d0NBQzlEbkMsT0FBT3VDLGNBQWM7b0NBQ3pCO29DQUVBdkMsT0FBT3FELFNBQVMsR0FBRyxDQUFDdEI7d0NBQ2hCL0IsT0FBT3NDLFlBQVksR0FBR1A7d0NBQ3RCL0IsT0FBT3VDLGNBQWM7b0NBQ3pCO2dDQUNKO2dDQUVBLE9BQU8sZ0tBSTREL0QsT0FGekRtRCxlQUFjLDBLQUdWTCxPQURxRDlDLE1BQUssMkRBR25ELE9BRlA4QyxVQUFVZ0MsZ0JBQWdCLEdBQ3RCLHlDQUFvRSxPQUEzQmhDLFVBQVVnQyxnQkFBZ0IsRUFBQyxVQUNwRSxJQUFHOzRCQUl6QixFQUFFLE9BQU9wRSxPQUFPO2dDQUNaUSxRQUFRUixLQUFLLENBQUMsb0NBQW9DQTtnQ0FDbEQsT0FBTzs0QkFDWDt3QkFDSjt3QkFFQSwrQkFBK0I7d0JBQy9CLE1BQU1xRSxhQUFhLElBQUl0RCxPQUFPQyxJQUFJLENBQUNzRCxNQUFNLENBQUNwRCxxQkFBcUIsQ0FBQzs0QkFDNUR6QixLQUFLbUM7NEJBQ0wyQyxVQUFVNUM7NEJBQ1Y2QyxPQUFPbEY7d0JBQ1g7d0JBRUEsbUNBQW1DO3dCQUNuQytFLFdBQVdJLFdBQVcsQ0FBQyxTQUFTOzRCQUM1QixJQUFJM0UsWUFBWTtnQ0FDWixNQUFNNEUsVUFBVXZDLDRCQUE0QjdDLE1BQU1xQztnQ0FDbEQsSUFBSStDLFNBQVM7b0NBQ1Q1RSxXQUFXNkUsVUFBVSxDQUFDLE1BQU1EO29DQUM1QjVFLFdBQVc4RSxJQUFJLENBQUNoRCxRQUFReUM7Z0NBQzVCOzRCQUNKO3dCQUNKO3dCQUVBMUUsUUFBUWtGLEdBQUcsQ0FBQ3ZGLE1BQU0rRTt3QkFFbEIsNENBQTRDO3dCQUM1Q0EsV0FBV0ksV0FBVyxDQUFDLFNBQVM7NEJBQzVCLE1BQU1DLFVBQVUsTUFBTXZDLDRCQUE0QjdDLE1BQU1xQzs0QkFDeEQsSUFBSStDLFNBQVM7Z0NBQ1QxQyxjQUFjMkMsVUFBVSxDQUFDRDtnQ0FDekIxQyxjQUFjNEMsSUFBSSxDQUFDO29DQUNmRSxRQUFRVDtvQ0FDUjVFLEtBQUttQztnQ0FDVDs0QkFDSjt3QkFDSjtvQkFFSixFQUFFLE9BQU9tRCxLQUFLO3dCQUNWdkUsUUFBUVIsS0FBSyxDQUFDLHlCQUF5QitFO3dCQUN2QzlFLFNBQVM7b0JBQ2I7Z0JBQ0o7WUFFUixFQUFFLE9BQU84RSxLQUFLO2dCQUNWdkUsUUFBUVIsS0FBSyxDQUFDLDJCQUEyQitFO2dCQUN6QzlFLFNBQVM7Z0JBQ1RFLGFBQWE7WUFDakI7UUFDSjtRQUVBVTtJQUNKLEdBQUc7UUFBQ3ZCO1FBQU1jO1FBQWNiO0tBQU87SUFFL0JQLGdEQUFTQSxDQUFDO1FBQ04sSUFBSSxDQUFDUyxLQUFLO1FBRVZxQixPQUFPa0UsYUFBYSxHQUFHLE9BQU9DO1lBQzFCLElBQUk7Z0JBQ0EsdUNBQXVDO2dCQUN2QyxNQUFNLENBQUMsRUFBRS9ELHFCQUFxQixFQUFFLEVBQUUsRUFBRWdFLFVBQVUsRUFBRSxDQUFDLEdBQUcsTUFBTUMsUUFBUUMsR0FBRyxDQUFDO29CQUNsRXJFLE9BQU9DLElBQUksQ0FBQ0MsYUFBYSxDQUFDO29CQUMxQkYsT0FBT0MsSUFBSSxDQUFDQyxhQUFhLENBQUM7aUJBQzdCO2dCQUVELDhCQUE4QjtnQkFDOUIsTUFBTW9FLGFBQWEsSUFBSXRFLE9BQU9DLElBQUksQ0FBQ3NELE1BQU0sQ0FBQ1ksVUFBVSxDQUFDO29CQUNqRCx5QkFBeUI7b0JBQ3pCLDBCQUEwQjtvQkFDMUIseUJBQXlCO29CQUN6QkksT0FBTztnQkFDWDtnQkFFQSxNQUFNaEIsU0FBUyxJQUFJdkQsT0FBT0MsSUFBSSxDQUFDc0QsTUFBTSxDQUFDcEQscUJBQXFCLENBQUM7b0JBQ3hEekI7b0JBQ0E4RSxVQUFVO3dCQUNOakMsS0FBSzJDLFVBQVU1QyxRQUFRO3dCQUN2QkcsS0FBS3lDLFVBQVUxQyxTQUFTO29CQUM1QjtvQkFDQWlDLE9BQU9TLFVBQVVULEtBQUs7b0JBQ3RCRSxTQUFTVyxXQUFXRSxPQUFPO29CQUMzQkMsY0FBYztnQkFDbEI7Z0JBRUEscUJBQXFCO2dCQUNyQmxCLE9BQU9HLFdBQVcsQ0FBQyxTQUFTO29CQUN4QixJQUFJUSxVQUFVUSxLQUFLLEVBQUU7d0JBQ2pCLG9DQUFvQzt3QkFDcEMsTUFBTWYsVUFBVWdCLDZCQUE2QlQsVUFBVVEsS0FBSzt3QkFDNUQsSUFBSWYsV0FBVzVFLFlBQVk7NEJBQ3ZCQSxXQUFXNkUsVUFBVSxDQUFDRDs0QkFDdEI1RSxXQUFXOEUsSUFBSSxDQUFDbkYsS0FBSzZFO3dCQUN6QjtvQkFDSjtnQkFDSjtnQkFFQSw2QkFBNkI7Z0JBQzdCM0UsUUFBUWtGLEdBQUcsQ0FBQ0ksVUFBVVQsS0FBSyxJQUFJLFdBQVdGO1lBQzlDLEVBQUUsT0FBT1MsS0FBSztnQkFDVnZFLFFBQVFSLEtBQUssQ0FBQyw4QkFBOEIrRTtZQUNoRDtRQUNKO1FBRUFqRSxPQUFPNkUsaUJBQWlCLEdBQUc7WUFDdkJoRyxRQUFRaUUsT0FBTyxDQUFDVSxDQUFBQTtnQkFDWkEsT0FBTzVFLE1BQU0sQ0FBQztZQUNsQjtZQUNBQyxRQUFRaUcsS0FBSztRQUNqQjtRQUVBLE9BQU87WUFDSCxPQUFPOUUsT0FBT2tFLGFBQWE7WUFDM0IsT0FBT2xFLE9BQU82RSxpQkFBaUI7UUFDbkM7SUFDSixHQUFHO1FBQUNsRztRQUFLSztLQUFXO0lBRXBCLE1BQU00RiwrQkFBK0IsQ0FBQ0Q7UUFDbEMsTUFBTUksV0FBV0osTUFBTS9DLE1BQU0sSUFBSStDLE1BQU0vQyxNQUFNLENBQUMsRUFBRSxHQUMxQyxvQ0FBcUduRCxPQUFqRWtHLE1BQU0vQyxNQUFNLENBQUMsRUFBRSxDQUFDSSxJQUFJLEVBQUMsOENBQW1ELE9BQVB2RCxVQUNyRztRQUVOLE9BQU8sd0dBWVcsT0FWUnNHLFdBQVcsc0dBR00sT0FEQ0EsVUFBUyx5Q0FDeUUsT0FBbkYsT0FBT0osTUFBTUssV0FBVyxLQUFLLFdBQVdMLE1BQU1LLFdBQVcsR0FBR0wsTUFBTUssV0FBVyxDQUFDQyxJQUFJLEVBQUMscU9BSWxHLElBQUcsNElBT0ROLE9BSkksT0FBT0EsTUFBTUssV0FBVyxLQUFLLFdBQ3pCTCxNQUFNSyxXQUFXLEdBQ2pCTCxNQUFNSyxXQUFXLENBQUNDLElBQUksRUFBQyxxREFPL0JOLE9BTEFBLE1BQU1PLHNCQUFzQixHQUN4Qix5RUFDc0MsT0FBbENQLE1BQU1PLHNCQUFzQixDQUFDRCxJQUFJLEVBQUMsMENBRXRDLElBQUcsMEJBS0EsT0FKUE4sTUFBTXJCLGdCQUFnQixHQUNsQixrRUFDMkIsT0FBdkJxQixNQUFNckIsZ0JBQWdCLEVBQUMsd0NBRTNCLElBQUc7SUFJekI7SUFFQSxxQkFDSSw4REFBQzZCO1FBQUlDLFdBQVU7O1lBQ1YzRyx3QkFDRyw4REFBQ0osb0RBQU1BO2dCQUNIZ0gsS0FBSywrQ0FBc0QsT0FBUDVHLFFBQU87Z0JBQzNENkcsVUFBUztnQkFDVEMsUUFBUTtvQkFDSjdGLFFBQVFDLEdBQUcsQ0FBQztvQkFDWkosZ0JBQWdCO2dCQUNwQjtnQkFDQWlHLFNBQVMsQ0FBQ0M7b0JBQ04vRixRQUFRUixLQUFLLENBQUMsc0NBQXNDdUc7b0JBQ3BEdEcsU0FBUztvQkFDVEUsYUFBYTtnQkFDakI7Ozs7OztZQUdQSCx1QkFDRyw4REFBQ2lHO2dCQUFJQyxXQUFVOzBCQUNWbEc7Ozs7OztZQUdSRSxhQUFhLENBQUNGLHVCQUNYLDhEQUFDaUc7Z0JBQUlDLFdBQVU7MEJBQ1gsNEVBQUNEO29CQUFJQyxXQUFVOzt3QkFBZ0I7d0JBRTFCLENBQUMzRyx3QkFBVSw4REFBQzBHO3NDQUFJOzs7Ozs7Ozs7Ozs7Ozs7OzswQkFJN0IsOERBQUNBO2dCQUFJTyxLQUFLaEg7Z0JBQVEwRyxXQUFVOzs7Ozs7Ozs7Ozs7QUFTeEM7R0ExVk03RztLQUFBQTtBQTRWTiwrREFBZUEsWUFBWUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL21hcC1jb21wb25lbnQudHN4PzM0MGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBTY3JpcHQgZnJvbSAnbmV4dC9zY3JpcHQnO1xuaW1wb3J0IHsgUGxhY2UsIHNlYXJjaFBsYWNlQnlUZXh0IH0gZnJvbSAnQC91dGlscy9wbGFjZXMtdXRpbHMnO1xuXG5pbnRlcmZhY2UgTWFwQ29tcG9uZW50UHJvcHMge1xuICAgIGNpdHk6IHN0cmluZztcbiAgICBhcGlLZXk6IHN0cmluZztcbn1cblxuZGVjbGFyZSBnbG9iYWwge1xuICAgIGludGVyZmFjZSBXaW5kb3cge1xuICAgICAgICBpbml0TWFwOiAoKSA9PiB2b2lkO1xuICAgICAgICBjdXJyZW50U2xpZGU6IG51bWJlcjtcbiAgICAgICAgdXBkYXRlQ2Fyb3VzZWw6ICgpID0+IHZvaWQ7XG4gICAgICAgIG5leHRTbGlkZTogKCkgPT4gdm9pZDtcbiAgICAgICAgcHJldlNsaWRlOiAoKSA9PiB2b2lkO1xuICAgICAgICBnb1RvU2xpZGU6IChpbmRleDogbnVtYmVyKSA9PiB2b2lkO1xuICAgICAgICBnb29nbGU6IHR5cGVvZiBnb29nbGU7XG4gICAgICAgIGFkZFBsYWNlVG9NYXA6IChwbGFjZTogeyBcbiAgICAgICAgICAgIGxhdGl0dWRlOiBudW1iZXI7IFxuICAgICAgICAgICAgbG9uZ2l0dWRlOiBudW1iZXI7IFxuICAgICAgICAgICAgdGl0bGU/OiBzdHJpbmc7XG4gICAgICAgICAgICBwbGFjZT86IFBsYWNlO1xuICAgICAgICB9KSA9PiB2b2lkO1xuICAgICAgICBjbGVhclBsYWNlTWFya2VyczogKCkgPT4gdm9pZDtcbiAgICB9XG59XG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgICBuYW1lc3BhY2UgZ29vZ2xlLm1hcHMge1xuICAgICAgICBpbnRlcmZhY2UgTWFya2VyTGlicmFyeSB7XG4gICAgICAgICAgICBBZHZhbmNlZE1hcmtlckVsZW1lbnQ6IHR5cGVvZiBnb29nbGUubWFwcy5tYXJrZXIuQWR2YW5jZWRNYXJrZXJFbGVtZW50O1xuICAgICAgICAgICAgUGluRWxlbWVudDogdHlwZW9mIGdvb2dsZS5tYXBzLm1hcmtlci5QaW5FbGVtZW50O1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBNYXBDb21wb25lbnQ6IFJlYWN0LkZDPE1hcENvbXBvbmVudFByb3BzPiA9ICh7IGNpdHksIGFwaUtleSB9KSA9PiB7XG4gICAgY29uc3QgbWFwUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKTtcbiAgICBjb25zdCBbbWFwLCBzZXRNYXBdID0gdXNlU3RhdGU8Z29vZ2xlLm1hcHMuTWFwIHwgbnVsbD4obnVsbCk7XG4gICAgY29uc3QgW21hcmtlcnMsIHNldE1hcmtlcnNdID0gdXNlU3RhdGU8TWFwPHN0cmluZywgZ29vZ2xlLm1hcHMubWFya2VyLkFkdmFuY2VkTWFya2VyRWxlbWVudD4+KG5ldyBNYXAoKSk7XG4gICAgY29uc3QgW2luZm9XaW5kb3csIHNldEluZm9XaW5kb3ddID0gdXNlU3RhdGU8Z29vZ2xlLm1hcHMuSW5mb1dpbmRvdyB8IG51bGw+KG51bGwpO1xuICAgIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gICAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IHVzZVN0YXRlKHRydWUpO1xuICAgIGNvbnN0IFtzY3JpcHRMb2FkZWQsIHNldFNjcmlwdExvYWRlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW3NlbGVjdGVkUGxhY2UsIHNldFNlbGVjdGVkUGxhY2VdID0gdXNlU3RhdGU8UGxhY2UgfCBudWxsPihudWxsKTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdNYXBDb21wb25lbnQ6IFJlY2VpdmVkIHByb3BzOicsIHsgY2l0eSwgYXBpS2V5TGVuZ3RoOiBhcGlLZXk/Lmxlbmd0aCB9KTtcbiAgICAgICAgXG4gICAgICAgIGlmICghYXBpS2V5KSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdNYXBDb21wb25lbnQ6IEdvb2dsZSBNYXBzIEFQSSBrZXkgaXMgbWlzc2luZycpO1xuICAgICAgICAgICAgc2V0RXJyb3IoJ0dvb2dsZSBNYXBzIEFQSSBrZXkgaXMgbWlzc2luZycpO1xuICAgICAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2NyaXB0TG9hZGVkIHx8ICFtYXBSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ01hcENvbXBvbmVudDogV2FpdGluZyBmb3Igc2NyaXB0IHRvIGxvYWQgb3IgbWFwIHJlZiB0byBiZSByZWFkeS4uLicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2coJ01hcENvbXBvbmVudDogSW5pdGlhbGl6aW5nIG1hcCB3aXRoIGNpdHk6JywgY2l0eSk7XG4gICAgICAgIGNvbnN0IGluaXRNYXAgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIEltcG9ydCByZXF1aXJlZCBsaWJyYXJpZXNcbiAgICAgICAgICAgICAgICBjb25zdCB7IE1hcCB9ID0gYXdhaXQgd2luZG93Lmdvb2dsZS5tYXBzLmltcG9ydExpYnJhcnkoXCJtYXBzXCIpIGFzIGdvb2dsZS5tYXBzLk1hcHNMaWJyYXJ5O1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgQWR2YW5jZWRNYXJrZXJFbGVtZW50IH0gPSBhd2FpdCBnb29nbGUubWFwcy5pbXBvcnRMaWJyYXJ5KFwibWFya2VyXCIpIGFzIGdvb2dsZS5tYXBzLk1hcmtlckxpYnJhcnk7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2VvY29kZXIgPSBuZXcgd2luZG93Lmdvb2dsZS5tYXBzLkdlb2NvZGVyKCk7XG5cbiAgICAgICAgICAgICAgICBnZW9jb2Rlci5nZW9jb2RlKFxuICAgICAgICAgICAgICAgICAgICB7IGFkZHJlc3M6IGNpdHkgfSxcbiAgICAgICAgICAgICAgICAgICAgYXN5bmMgKHJlc3VsdHMsIHN0YXR1cykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0dlb2NvZGluZyByZXNwb25zZTonLCB7IHN0YXR1cywgcmVzdWx0c0xlbmd0aDogcmVzdWx0cz8ubGVuZ3RoIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzICE9PSAnT0snIHx8ICFyZXN1bHRzPy5bMF0/Lmdlb21ldHJ5Py5sb2NhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0dlb2NvZGluZyBmYWlsZWQ6Jywgc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRFcnJvcihgQ291bGQgbm90IGZpbmQgbG9jYXRpb24gZm9yICR7Y2l0eX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2NhdGlvbiA9IHJlc3VsdHNbMF0uZ2VvbWV0cnkubG9jYXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3TWFwID0gbmV3IE1hcChtYXBSZWYuY3VycmVudCEsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VudGVyOiBsb2NhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgem9vbTogMTIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcElkOiAnMmQ2MDRhZjA0YTdjN2ZhOCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0TWFwKG5ld01hcCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdJbmZvV2luZG93ID0gbmV3IGdvb2dsZS5tYXBzLkluZm9XaW5kb3coe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhXaWR0aDogNDAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0SW5mb1dpbmRvdyhuZXdJbmZvV2luZG93KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNyZWF0ZUNpdHlJbmZvV2luZG93Q29udGVudCA9IGFzeW5jIChjaXR5OiBzdHJpbmcsIGxvY2F0aW9uOiBnb29nbGUubWFwcy5MYXRMbmcpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlYXJjaCBmb3IgdGhlIGNpdHkgdG8gZ2V0IGl0cyBkZXRhaWxzIGluY2x1ZGluZyBwaG90b3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNpdHlQbGFjZSA9IGF3YWl0IHNlYXJjaFBsYWNlQnlUZXh0KGNpdHksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXRpdHVkZTogbG9jYXRpb24ubGF0KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9uZ2l0dWRlOiBsb2NhdGlvbi5sbmcoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2l0eVBsYWNlKSByZXR1cm4gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgcGhvdG8gY2Fyb3VzZWwgSFRNTFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGhvdG9DYXJvdXNlbCA9IGNpdHlQbGFjZS5waG90b3MgJiYgY2l0eVBsYWNlLnBob3Rvcy5sZW5ndGggPiAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJyZWxhdGl2ZSB3LWZ1bGxcIiBzdHlsZT1cImhlaWdodDogMjAwcHg7XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2Fyb3VzZWwtY29udGFpbmVyIG92ZXJmbG93LWhpZGRlbiB3LWZ1bGwgaC1mdWxsXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNhcm91c2VsLXRyYWNrIGZsZXggdHJhbnNpdGlvbi10cmFuc2Zvcm0gZHVyYXRpb24tNTAwXCIgc3R5bGU9XCJoZWlnaHQ6IDEwMCU7XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7Y2l0eVBsYWNlLnBob3Rvcy5zbGljZSgwLCA1KS5tYXAoKHBob3RvLCBpbmRleCkgPT4gYFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNhcm91c2VsLXNsaWRlIHctZnVsbCBoLWZ1bGwgZmxleC1ub25lXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGltZyBzcmM9XCJodHRwczovL3BsYWNlcy5nb29nbGVhcGlzLmNvbS92MS8ke3Bob3RvLm5hbWV9L21lZGlhP21heEhlaWdodFB4PTM0MCZtYXhXaWR0aFB4PTM0MCZrZXk9JHthcGlLZXl9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWx0PVwiJHtjaXR5fVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwidy1mdWxsIGgtZnVsbCBvYmplY3QtY292ZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYCkuam9pbignJyl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gb25jbGljaz1cIndpbmRvdy5wcmV2U2xpZGUoKVwiIGNsYXNzPVwiYWJzb2x1dGUgbGVmdC0yIHRvcC0xLzIgdHJhbnNmb3JtIC10cmFuc2xhdGUteS0xLzIgYmctd2hpdGUvODAgcm91bmRlZC1mdWxsIHAtMSBzaGFkb3ctbWQgaG92ZXI6Ymctd2hpdGVcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInctNSBoLTVcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk0xNS43NSAxOS41TDguMjUgMTJsNy41LTcuNVwiIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zdmc+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gb25jbGljaz1cIndpbmRvdy5uZXh0U2xpZGUoKVwiIGNsYXNzPVwiYWJzb2x1dGUgcmlnaHQtMiB0b3AtMS8yIHRyYW5zZm9ybSAtdHJhbnNsYXRlLXktMS8yIGJnLXdoaXRlLzgwIHJvdW5kZWQtZnVsbCBwLTEgc2hhZG93LW1kIGhvdmVyOmJnLXdoaXRlXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJ3LTUgaC01XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNOC4yNSA0LjVsNy41IDcuNS03LjUgNy41XCIgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImFic29sdXRlIGJvdHRvbS0yIGxlZnQtMCByaWdodC0wIGZsZXgganVzdGlmeS1jZW50ZXIgZ2FwLTFcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAke2NpdHlQbGFjZS5waG90b3Muc2xpY2UoMCwgNSkubWFwKChfLCBpbmRleCkgPT4gYFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIG9uY2xpY2s9XCJ3aW5kb3cuZ29Ub1NsaWRlKCR7aW5kZXh9KVwiIGNsYXNzPVwidy0yIGgtMiByb3VuZGVkLWZ1bGwgYmctd2hpdGUvODAgaG92ZXI6Ymctd2hpdGUgc2hhZG93LXNtIGNhcm91c2VsLWRvdFwiIGRhdGEtaW5kZXg9XCIke2luZGV4fVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgKS5qb2luKCcnKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnJztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGNhcm91c2VsIGNvbnRyb2wgZnVuY3Rpb25zIHRvIHdpbmRvd1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNpdHlQbGFjZS5waG90b3MgJiYgY2l0eVBsYWNlLnBob3Rvcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbnVtU2xpZGVzID0gTWF0aC5taW4oY2l0eVBsYWNlLnBob3Rvcy5sZW5ndGgsIDUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jdXJyZW50U2xpZGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy51cGRhdGVDYXJvdXNlbCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhY2sgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY2Fyb3VzZWwtdHJhY2snKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodHJhY2sgYXMgSFRNTEVsZW1lbnQpLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGVYKC0ke3dpbmRvdy5jdXJyZW50U2xpZGUgKiAxMDB9JSlgO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGRvdHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5jYXJvdXNlbC1kb3QnKS5mb3JFYWNoKChkb3QsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSB3aW5kb3cuY3VycmVudFNsaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdC5jbGFzc0xpc3QuYWRkKCdiZy13aGl0ZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QuY2xhc3NMaXN0LnJlbW92ZSgnYmctd2hpdGUvODAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QuY2xhc3NMaXN0LnJlbW92ZSgnYmctd2hpdGUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90LmNsYXNzTGlzdC5hZGQoJ2JnLXdoaXRlLzgwJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93Lm5leHRTbGlkZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmN1cnJlbnRTbGlkZSA9ICh3aW5kb3cuY3VycmVudFNsaWRlICsgMSkgJSBudW1TbGlkZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy51cGRhdGVDYXJvdXNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cucHJldlNsaWRlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY3VycmVudFNsaWRlID0gKHdpbmRvdy5jdXJyZW50U2xpZGUgLSAxICsgbnVtU2xpZGVzKSAlIG51bVNsaWRlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LnVwZGF0ZUNhcm91c2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5nb1RvU2xpZGUgPSAoaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmN1cnJlbnRTbGlkZSA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cudXBkYXRlQ2Fyb3VzZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJiZy13aGl0ZSByb3VuZGVkLWxnIHNoYWRvdy1zbVwiIHN0eWxlPVwibWF4LXdpZHRoOiAzNDBweDtcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHtwaG90b0Nhcm91c2VsfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicC00XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aDIgY2xhc3M9XCJ0ZXh0LXhsIGZvbnQtc2VtaWJvbGQgdGV4dC1ncmF5LTkwMCBtYi0yXCI+JHtjaXR5fTwvaDI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAke2NpdHlQbGFjZS5mb3JtYXR0ZWRBZGRyZXNzIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYDxwIGNsYXNzPVwidGV4dC1zbSB0ZXh0LWdyYXktNTAwIG1iLTJcIj4ke2NpdHlQbGFjZS5mb3JtYXR0ZWRBZGRyZXNzfTwvcD5gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnJ31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgY2l0eSBpbmZvIHdpbmRvdzonLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBtYXJrZXIgZm9yIHRoZSBjaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2l0eU1hcmtlciA9IG5ldyBnb29nbGUubWFwcy5tYXJrZXIuQWR2YW5jZWRNYXJrZXJFbGVtZW50KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwOiBuZXdNYXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGNpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBjbGljayBsaXN0ZW5lciB0byB0aGUgbWFya2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2l0eU1hcmtlci5hZGRMaXN0ZW5lcignY2xpY2snLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmZvV2luZG93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gY3JlYXRlQ2l0eUluZm9XaW5kb3dDb250ZW50KGNpdHksIGxvY2F0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mb1dpbmRvdy5zZXRDb250ZW50KGF3YWl0IGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm9XaW5kb3cub3BlbihuZXdNYXAsIGNpdHlNYXJrZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrZXJzLnNldChjaXR5LCBjaXR5TWFya2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgY2xpY2sgbGlzdGVuZXIgZm9yIGZ1dHVyZSBpbnRlcmFjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNpdHlNYXJrZXIuYWRkTGlzdGVuZXIoJ2NsaWNrJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgY3JlYXRlQ2l0eUluZm9XaW5kb3dDb250ZW50KGNpdHksIGxvY2F0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0luZm9XaW5kb3cuc2V0Q29udGVudChjb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0luZm9XaW5kb3cub3Blbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5jaG9yOiBjaXR5TWFya2VyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcDogbmV3TWFwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzZXR0aW5nIHVwIG1hcDonLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEVycm9yKCdGYWlsZWQgdG8gaW5pdGlhbGl6ZSBtYXAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbml0aWFsaXppbmcgbWFwOicsIGVycik7XG4gICAgICAgICAgICAgICAgc2V0RXJyb3IoJ0ZhaWxlZCB0byBpbml0aWFsaXplIG1hcCcpO1xuICAgICAgICAgICAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaW5pdE1hcCgpO1xuICAgIH0sIFtjaXR5LCBzY3JpcHRMb2FkZWQsIGFwaUtleV0pO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFtYXApIHJldHVybjtcblxuICAgICAgICB3aW5kb3cuYWRkUGxhY2VUb01hcCA9IGFzeW5jIChwbGFjZURhdGEpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gSW1wb3J0IGJvdGggbWFya2VyIGFuZCBwaW4gbGlicmFyaWVzXG4gICAgICAgICAgICAgICAgY29uc3QgW3sgQWR2YW5jZWRNYXJrZXJFbGVtZW50IH0sIHsgUGluRWxlbWVudCB9XSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuaW1wb3J0TGlicmFyeShcIm1hcmtlclwiKSBhcyBQcm9taXNlPGdvb2dsZS5tYXBzLk1hcmtlckxpYnJhcnk+LFxuICAgICAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5pbXBvcnRMaWJyYXJ5KFwibWFya2VyXCIpIGFzIFByb21pc2U8Z29vZ2xlLm1hcHMuTWFya2VyTGlicmFyeT5cbiAgICAgICAgICAgICAgICBdKTtcblxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIGN1c3RvbSBwaW4gZWxlbWVudFxuICAgICAgICAgICAgICAgIGNvbnN0IHBpbkVsZW1lbnQgPSBuZXcgZ29vZ2xlLm1hcHMubWFya2VyLlBpbkVsZW1lbnQoe1xuICAgICAgICAgICAgICAgICAgICAvLyBiYWNrZ3JvdW5kOiBcIiNGQkJDMDRcIixcbiAgICAgICAgICAgICAgICAgICAgLy8gYm9yZGVyQ29sb3I6IFwiI0VBNDMzNVwiLFxuICAgICAgICAgICAgICAgICAgICAvLyBnbHlwaENvbG9yOiBcIiMwMDAwMDBcIixcbiAgICAgICAgICAgICAgICAgICAgc2NhbGU6IDFcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG1hcmtlciA9IG5ldyBnb29nbGUubWFwcy5tYXJrZXIuQWR2YW5jZWRNYXJrZXJFbGVtZW50KHtcbiAgICAgICAgICAgICAgICAgICAgbWFwLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGF0OiBwbGFjZURhdGEubGF0aXR1ZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBsbmc6IHBsYWNlRGF0YS5sb25naXR1ZGVcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHBsYWNlRGF0YS50aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogcGluRWxlbWVudC5lbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICBnbXBEcmFnZ2FibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gQWRkIGNsaWNrIGxpc3RlbmVyXG4gICAgICAgICAgICAgICAgbWFya2VyLmFkZExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBsYWNlRGF0YS5wbGFjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gWW91ciBleGlzdGluZyBjbGljayBoYW5kbGVyIGxvZ2ljXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gY3JlYXRlUGxhY2VJbmZvV2luZG93Q29udGVudChwbGFjZURhdGEucGxhY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnQgJiYgaW5mb1dpbmRvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm9XaW5kb3cuc2V0Q29udGVudChjb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZvV2luZG93Lm9wZW4obWFwLCBtYXJrZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBTdG9yZSB0aGUgbWFya2VyIHJlZmVyZW5jZVxuICAgICAgICAgICAgICAgIG1hcmtlcnMuc2V0KHBsYWNlRGF0YS50aXRsZSB8fCAndW5uYW1lZCcsIG1hcmtlcik7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhZGRpbmcgcGxhY2UgbWFya2VyOicsIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgd2luZG93LmNsZWFyUGxhY2VNYXJrZXJzID0gKCkgPT4ge1xuICAgICAgICAgICAgbWFya2Vycy5mb3JFYWNoKG1hcmtlciA9PiB7XG4gICAgICAgICAgICAgICAgbWFya2VyLnNldE1hcChudWxsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbWFya2Vycy5jbGVhcigpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBkZWxldGUgd2luZG93LmFkZFBsYWNlVG9NYXA7XG4gICAgICAgICAgICBkZWxldGUgd2luZG93LmNsZWFyUGxhY2VNYXJrZXJzO1xuICAgICAgICB9O1xuICAgIH0sIFttYXAsIGluZm9XaW5kb3ddKTtcblxuICAgIGNvbnN0IGNyZWF0ZVBsYWNlSW5mb1dpbmRvd0NvbnRlbnQgPSAocGxhY2U6IFBsYWNlKSA9PiB7XG4gICAgICAgIGNvbnN0IHBob3RvVXJsID0gcGxhY2UucGhvdG9zICYmIHBsYWNlLnBob3Rvc1swXSBcbiAgICAgICAgICAgID8gYGh0dHBzOi8vcGxhY2VzLmdvb2dsZWFwaXMuY29tL3YxLyR7cGxhY2UucGhvdG9zWzBdLm5hbWV9L21lZGlhP21heEhlaWdodFB4PTIwMCZtYXhXaWR0aFB4PTMwMCZrZXk9JHthcGlLZXl9YFxuICAgICAgICAgICAgOiAnJztcblxuICAgICAgICByZXR1cm4gYFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImJnLXdoaXRlIHJvdW5kZWQtbGcgc2hhZG93LXNtXCIgc3R5bGU9XCJtYXgtd2lkdGg6IDMwMHB4O1wiPlxuICAgICAgICAgICAgICAgICR7cGhvdG9VcmwgPyBgXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9XCJoZWlnaHQ6IDE1MHB4OyB3aWR0aDogMTAwJTtcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPVwiJHtwaG90b1VybH1cIiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHQ9XCIke3R5cGVvZiBwbGFjZS5kaXNwbGF5TmFtZSA9PT0gJ3N0cmluZycgPyBwbGFjZS5kaXNwbGF5TmFtZSA6IHBsYWNlLmRpc3BsYXlOYW1lLnRleHR9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT1cIndpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7IG9iamVjdC1maXQ6IGNvdmVyOyBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAwLjVyZW07IGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiAwLjVyZW07XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIGAgOiAnJ31cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicC0zXCI+XG4gICAgICAgICAgICAgICAgICAgIDxoMyBjbGFzcz1cInRleHQtbGcgZm9udC1zZW1pYm9sZCB0ZXh0LWdyYXktOTAwIG1iLTFcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICR7dHlwZW9mIHBsYWNlLmRpc3BsYXlOYW1lID09PSAnc3RyaW5nJyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHBsYWNlLmRpc3BsYXlOYW1lIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcGxhY2UuZGlzcGxheU5hbWUudGV4dH1cbiAgICAgICAgICAgICAgICAgICAgPC9oMz5cbiAgICAgICAgICAgICAgICAgICAgJHtwbGFjZS5wcmltYXJ5VHlwZURpc3BsYXlOYW1lIFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBgPGRpdiBjbGFzcz1cInRleHQtc20gdGV4dC1ncmF5LTYwMCBtYi0xXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHtwbGFjZS5wcmltYXJ5VHlwZURpc3BsYXlOYW1lLnRleHR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+YFxuICAgICAgICAgICAgICAgICAgICAgICAgOiAnJ31cbiAgICAgICAgICAgICAgICAgICAgJHtwbGFjZS5mb3JtYXR0ZWRBZGRyZXNzIFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBgPHAgY2xhc3M9XCJ0ZXh0LXNtIHRleHQtZ3JheS01MDBcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAke3BsYWNlLmZvcm1hdHRlZEFkZHJlc3N9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9wPmBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogJyd9XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgYDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyZWxhdGl2ZSB3LWZ1bGwgaC1mdWxsIG1pbi1oLVszNDBweF1cIj5cbiAgICAgICAgICAgIHthcGlLZXkgJiYgKFxuICAgICAgICAgICAgICAgIDxTY3JpcHRcbiAgICAgICAgICAgICAgICAgICAgc3JjPXtgaHR0cHM6Ly9tYXBzLmdvb2dsZWFwaXMuY29tL21hcHMvYXBpL2pzP2tleT0ke2FwaUtleX0mbGlicmFyaWVzPXBsYWNlcyxtYXJrZXImdj1iZXRhJmNhbGxiYWNrPUZ1bmN0aW9uLnByb3RvdHlwZWB9XG4gICAgICAgICAgICAgICAgICAgIHN0cmF0ZWd5PVwiYWZ0ZXJJbnRlcmFjdGl2ZVwiXG4gICAgICAgICAgICAgICAgICAgIG9uTG9hZD17KCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0dvb2dsZSBNYXBzIHNjcmlwdCBsb2FkZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFNjcmlwdExvYWRlZCh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcj17KGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBsb2FkIEdvb2dsZSBNYXBzIHNjcmlwdDonLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEVycm9yKCdGYWlsZWQgdG8gbG9hZCBHb29nbGUgTWFwcycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIHtlcnJvciAmJiAoXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhYnNvbHV0ZSBpbnNldC0wIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIGJnLWdyYXktMTAwIHRleHQtcmVkLTUwMCBwLTQgdGV4dC1jZW50ZXJcIj5cbiAgICAgICAgICAgICAgICAgICAge2Vycm9yfVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIHtpc0xvYWRpbmcgJiYgIWVycm9yICYmIChcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFic29sdXRlIGluc2V0LTAgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgYmctZ3JheS0xMDBcIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LWdyYXktNjAwXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICBMb2FkaW5nIG1hcC4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgeyFhcGlLZXkgJiYgPGRpdj5XYWl0aW5nIGZvciBBUEkga2V5Li4uPC9kaXY+fVxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICl9XG4gICAgICAgICAgICA8ZGl2IHJlZj17bWFwUmVmfSBjbGFzc05hbWU9XCJ3LWZ1bGwgaC1mdWxsXCIgLz5cbiAgICAgICAgICAgIHsvKiB7c2VsZWN0ZWRQbGFjZSAmJiAoXG4gICAgICAgICAgICAgICAgPFNtYWxsUGxhY2VDYXJkIFxuICAgICAgICAgICAgICAgICAgICBwbGFjZT17c2VsZWN0ZWRQbGFjZX0gXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xvc2U9eygpID0+IHNldFNlbGVjdGVkUGxhY2UobnVsbCl9IFxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICApfSAqL31cbiAgICAgICAgPC9kaXY+XG4gICAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IE1hcENvbXBvbmVudDsiXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsIlNjcmlwdCIsInNlYXJjaFBsYWNlQnlUZXh0IiwiTWFwQ29tcG9uZW50IiwiY2l0eSIsImFwaUtleSIsIm1hcFJlZiIsIm1hcCIsInNldE1hcCIsIm1hcmtlcnMiLCJzZXRNYXJrZXJzIiwiTWFwIiwiaW5mb1dpbmRvdyIsInNldEluZm9XaW5kb3ciLCJlcnJvciIsInNldEVycm9yIiwiaXNMb2FkaW5nIiwic2V0SXNMb2FkaW5nIiwic2NyaXB0TG9hZGVkIiwic2V0U2NyaXB0TG9hZGVkIiwic2VsZWN0ZWRQbGFjZSIsInNldFNlbGVjdGVkUGxhY2UiLCJjb25zb2xlIiwibG9nIiwiYXBpS2V5TGVuZ3RoIiwibGVuZ3RoIiwiY3VycmVudCIsImluaXRNYXAiLCJ3aW5kb3ciLCJnb29nbGUiLCJtYXBzIiwiaW1wb3J0TGlicmFyeSIsIkFkdmFuY2VkTWFya2VyRWxlbWVudCIsImdlb2NvZGVyIiwiR2VvY29kZXIiLCJnZW9jb2RlIiwiYWRkcmVzcyIsInJlc3VsdHMiLCJzdGF0dXMiLCJyZXN1bHRzTGVuZ3RoIiwiZ2VvbWV0cnkiLCJsb2NhdGlvbiIsIm5ld01hcCIsImNlbnRlciIsInpvb20iLCJtYXBJZCIsIm5ld0luZm9XaW5kb3ciLCJJbmZvV2luZG93IiwibWF4V2lkdGgiLCJjcmVhdGVDaXR5SW5mb1dpbmRvd0NvbnRlbnQiLCJjaXR5UGxhY2UiLCJsYXRpdHVkZSIsImxhdCIsImxvbmdpdHVkZSIsImxuZyIsInBob3RvQ2Fyb3VzZWwiLCJwaG90b3MiLCJzbGljZSIsInBob3RvIiwiaW5kZXgiLCJuYW1lIiwiam9pbiIsIl8iLCJudW1TbGlkZXMiLCJNYXRoIiwibWluIiwiY3VycmVudFNsaWRlIiwidXBkYXRlQ2Fyb3VzZWwiLCJ0cmFjayIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsInN0eWxlIiwidHJhbnNmb3JtIiwicXVlcnlTZWxlY3RvckFsbCIsImZvckVhY2giLCJkb3QiLCJjbGFzc0xpc3QiLCJhZGQiLCJyZW1vdmUiLCJuZXh0U2xpZGUiLCJwcmV2U2xpZGUiLCJnb1RvU2xpZGUiLCJmb3JtYXR0ZWRBZGRyZXNzIiwiY2l0eU1hcmtlciIsIm1hcmtlciIsInBvc2l0aW9uIiwidGl0bGUiLCJhZGRMaXN0ZW5lciIsImNvbnRlbnQiLCJzZXRDb250ZW50Iiwib3BlbiIsInNldCIsImFuY2hvciIsImVyciIsImFkZFBsYWNlVG9NYXAiLCJwbGFjZURhdGEiLCJQaW5FbGVtZW50IiwiUHJvbWlzZSIsImFsbCIsInBpbkVsZW1lbnQiLCJzY2FsZSIsImVsZW1lbnQiLCJnbXBEcmFnZ2FibGUiLCJwbGFjZSIsImNyZWF0ZVBsYWNlSW5mb1dpbmRvd0NvbnRlbnQiLCJjbGVhclBsYWNlTWFya2VycyIsImNsZWFyIiwicGhvdG9VcmwiLCJkaXNwbGF5TmFtZSIsInRleHQiLCJwcmltYXJ5VHlwZURpc3BsYXlOYW1lIiwiZGl2IiwiY2xhc3NOYW1lIiwic3JjIiwic3RyYXRlZ3kiLCJvbkxvYWQiLCJvbkVycm9yIiwiZSIsInJlZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./components/map-component.tsx\n"));

/***/ }),

/***/ "./managers/types.ts":
/*!***************************!*\
  !*** ./managers/types.ts ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BUDGET_DESCRIPTIONS: function() { return /* binding */ BUDGET_DESCRIPTIONS; },\n/* harmony export */   BUDGET_OPTIONS: function() { return /* binding */ BUDGET_OPTIONS; },\n/* harmony export */   BudgetLevel: function() { return /* binding */ BudgetLevel; },\n/* harmony export */   ComponentType: function() { return /* binding */ ComponentType; },\n/* harmony export */   LANGUAGE_LABELS: function() { return /* binding */ LANGUAGE_LABELS; },\n/* harmony export */   LANGUAGE_OPTIONS: function() { return /* binding */ LANGUAGE_OPTIONS; },\n/* harmony export */   PREFERENCE_ICONS: function() { return /* binding */ PREFERENCE_ICONS; },\n/* harmony export */   PREFERENCE_OPTIONS: function() { return /* binding */ PREFERENCE_OPTIONS; },\n/* harmony export */   SupportedLanguage: function() { return /* binding */ SupportedLanguage; },\n/* harmony export */   TravelPreference: function() { return /* binding */ TravelPreference; }\n/* harmony export */ });\n///Users/terrancehah/Documents/terrancehah.com/managers/types.ts\nvar ComponentType;\n(function(ComponentType) {\n    ComponentType[\"DatePicker\"] = \"DatePicker\";\n    ComponentType[\"PreferenceSelector\"] = \"PreferenceSelector\";\n    ComponentType[\"BudgetSelector\"] = \"BudgetSelector\";\n    ComponentType[\"LanguageSelector\"] = \"LanguageSelector\";\n    ComponentType[\"PlaceCard\"] = \"PlaceCard\";\n    ComponentType[\"TransportSelector\"] = \"TransportSelector\";\n    ComponentType[\"Carousel\"] = \"Carousel\";\n    ComponentType[\"DetailsCard\"] = \"DetailsCard\";\n})(ComponentType || (ComponentType = {}));\nvar BudgetLevel;\n(function(BudgetLevel) {\n    BudgetLevel[\"Budget\"] = \"$\";\n    BudgetLevel[\"Moderate\"] = \"$$\";\n    BudgetLevel[\"Luxury\"] = \"$$$\";\n    BudgetLevel[\"UltraLuxury\"] = \"$$$$\";\n})(BudgetLevel || (BudgetLevel = {}));\nvar TravelPreference;\n(function(TravelPreference) {\n    TravelPreference[\"Culture\"] = \"Culture and Heritage\";\n    TravelPreference[\"Nature\"] = \"Nature\";\n    TravelPreference[\"Food\"] = \"Foodie\";\n    TravelPreference[\"Relaxation\"] = \"Leisure\";\n    TravelPreference[\"Adventure\"] = \"Adventure\";\n    TravelPreference[\"Shopping\"] = \"Arts & Museum\";\n})(TravelPreference || (TravelPreference = {}));\nvar SupportedLanguage;\n(function(SupportedLanguage) {\n    SupportedLanguage[\"English\"] = \"English\";\n    SupportedLanguage[\"Malay\"] = \"Malay (Bahasa Melayu)\";\n    SupportedLanguage[\"Spanish\"] = \"Espanol\";\n    SupportedLanguage[\"French\"] = \"Francais\";\n    SupportedLanguage[\"German\"] = \"Deutsch\";\n    SupportedLanguage[\"Italian\"] = \"Italiano\";\n    SupportedLanguage[\"Czech\"] = \"Czech (Cestina)\";\n    SupportedLanguage[\"SimplifiedChinese\"] = \"Simplified Chinese ()\";\n    SupportedLanguage[\"TraditionalChinese\"] = \"Traditional Chinese ()\";\n    SupportedLanguage[\"Japanese\"] = \"Japanese ()\";\n    SupportedLanguage[\"Korean\"] = \"Korean ()\";\n})(SupportedLanguage || (SupportedLanguage = {}));\nconst BUDGET_DESCRIPTIONS = {\n    [\"$\"]: \"Budget-friendly options ($)\",\n    [\"$$\"]: \"Mid-range options ($$)\",\n    [\"$$$\"]: \"High-end options ($$$)\",\n    [\"$$$$\"]: \"Ultra luxury options ($$$$)\"\n};\nconst PREFERENCE_ICONS = {\n    [\"Culture and Heritage\"]: \"\\uD83C\\uDF8F\",\n    [\"Nature\"]: \"\\uD83C\\uDF40\",\n    [\"Foodie\"]: \"\\uD83C\\uDF71\",\n    [\"Leisure\"]: \"\\uD83C\\uDF07\",\n    [\"Adventure\"]: \"\\uD83E\\uDE82\",\n    [\"Arts & Museum\"]: \"\\uD83C\\uDFA8\"\n};\nconst LANGUAGE_LABELS = {\n    [\"English\"]: \"English\",\n    [\"Malay (Bahasa Melayu)\"]: \"Malay (Bahasa Melayu)\",\n    [\"Espanol\"]: \"Espanol\",\n    [\"Francais\"]: \"Francais\",\n    [\"Deutsch\"]: \"Deutsch\",\n    [\"Italiano\"]: \"Italiano\",\n    [\"Czech (Cestina)\"]: \"Czech (Cestina)\",\n    [\"Simplified Chinese ()\"]: \"Simplified Chinese ()\",\n    [\"Traditional Chinese ()\"]: \"Traditional Chinese ()\",\n    [\"Japanese ()\"]: \"Japanese ()\",\n    [\"Korean ()\"]: \"Korean ()\"\n};\nconst BUDGET_OPTIONS = [\n    {\n        value: \"$\",\n        label: \"Budget\",\n        description: \"Budget-friendly options with basic amenities\"\n    },\n    {\n        value: \"$$\",\n        label: \"Moderate\",\n        description: \"Mid-range options with good value\"\n    },\n    {\n        value: \"$$$\",\n        label: \"Luxury\",\n        description: \"High-end options with premium services\"\n    },\n    {\n        value: \"$$$$\",\n        label: \"Ultra Luxury\",\n        description: \"Exclusive luxury experiences\"\n    }\n];\nconst LANGUAGE_OPTIONS = Object.entries(SupportedLanguage).map((param)=>{\n    let [key, value] = param;\n    return {\n        value,\n        label: LANGUAGE_LABELS[value]\n    };\n});\nconst PREFERENCE_OPTIONS = [\n    {\n        value: \"Culture and Heritage\",\n        label: \"Culture and Heritage\",\n        icon: PREFERENCE_ICONS[\"Culture and Heritage\"]\n    },\n    {\n        value: \"Nature\",\n        label: \"Nature\",\n        icon: PREFERENCE_ICONS[\"Nature\"]\n    },\n    {\n        value: \"Foodie\",\n        label: \"Foodie\",\n        icon: PREFERENCE_ICONS[\"Foodie\"]\n    },\n    {\n        value: \"Leisure\",\n        label: \"Leisure\",\n        icon: PREFERENCE_ICONS[\"Leisure\"]\n    },\n    {\n        value: \"Adventure\",\n        label: \"Adventure\",\n        icon: PREFERENCE_ICONS[\"Adventure\"]\n    },\n    {\n        value: \"Arts & Museum\",\n        label: \"Arts & Museum\",\n        icon: PREFERENCE_ICONS[\"Arts & Museum\"]\n    }\n];\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9tYW5hZ2Vycy90eXBlcy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUEsZ0VBQWdFOztVQW1CcERBOzs7Ozs7Ozs7R0FBQUEsa0JBQUFBOztVQVdBQzs7Ozs7R0FBQUEsZ0JBQUFBOztVQU9BQzs7Ozs7OztHQUFBQSxxQkFBQUE7O1VBU0FDOzs7Ozs7Ozs7Ozs7R0FBQUEsc0JBQUFBO0FBY0wsTUFBTUMsc0JBQW1EO0lBQzVELEtBQW9CLEVBQUU7SUFDdEIsTUFBc0IsRUFBRTtJQUN4QixPQUFvQixFQUFFO0lBQ3RCLFFBQXlCLEVBQUU7QUFDL0IsRUFBRTtBQUVLLE1BQU1DLG1CQUFxRDtJQUM5RCx3QkFBMEIsRUFBRTtJQUM1QixVQUF5QixFQUFFO0lBQzNCLFVBQXVCLEVBQUU7SUFDekIsV0FBNkIsRUFBRTtJQUMvQixhQUE0QixFQUFFO0lBQzlCLGlCQUEyQixFQUFFO0FBQ2pDLEVBQUU7QUFFSyxNQUFNQyxrQkFBcUQ7SUFDOUQsV0FBMkIsRUFBRTtJQUM3Qix5QkFBeUIsRUFBRTtJQUMzQixXQUEyQixFQUFFO0lBQzdCLFlBQTBCLEVBQUU7SUFDNUIsV0FBMEIsRUFBRTtJQUM1QixZQUEyQixFQUFFO0lBQzdCLG1CQUF5QixFQUFFO0lBQzNCLDZCQUFxQyxFQUFFO0lBQ3ZDLDhCQUFzQyxFQUFFO0lBQ3hDLGtCQUE0QixFQUFFO0lBQzlCLGdCQUEwQixFQUFFO0FBQ2hDLEVBQUU7QUFFSyxNQUFNQyxpQkFBaUI7SUFDMUI7UUFBRUMsS0FBSztRQUFzQkMsT0FBTztRQUFVQyxhQUFhO0lBQStDO0lBQzFHO1FBQUVGLEtBQUs7UUFBd0JDLE9BQU87UUFBWUMsYUFBYTtJQUFvQztJQUNuRztRQUFFRixLQUFLO1FBQXNCQyxPQUFPO1FBQVVDLGFBQWE7SUFBeUM7SUFDcEc7UUFBRUYsS0FBSztRQUEyQkMsT0FBTztRQUFnQkMsYUFBYTtJQUErQjtDQUN4RyxDQUFDO0FBRUssTUFBTUMsbUJBQW1CQyxPQUFPQyxPQUFPLENBQUNWLG1CQUFtQlcsR0FBRyxDQUFDO1FBQUMsQ0FBQ0MsS0FBS1AsTUFBTTtXQUFNO1FBQ3JGQTtRQUNBQyxPQUFPSCxlQUFlLENBQUNFLE1BQTJCO0lBQ3REO0FBQUEsR0FBSTtBQUVHLE1BQU1RLHFCQUFxQjtJQUM5QjtRQUFFUixLQUFLO1FBQTRCQyxPQUFPO1FBQXdCUSxNQUFNWixnQkFBZ0Isd0JBQTBCO0lBQUM7SUFDbkg7UUFBRUcsS0FBSztRQUEyQkMsT0FBTztRQUFVUSxNQUFNWixnQkFBZ0IsVUFBeUI7SUFBQztJQUNuRztRQUFFRyxLQUFLO1FBQXlCQyxPQUFPO1FBQVVRLE1BQU1aLGdCQUFnQixVQUF1QjtJQUFDO0lBQy9GO1FBQUVHLEtBQUs7UUFBK0JDLE9BQU87UUFBV1EsTUFBTVosZ0JBQWdCLFdBQTZCO0lBQUM7SUFDNUc7UUFBRUcsS0FBSztRQUE4QkMsT0FBTztRQUFhUSxNQUFNWixnQkFBZ0IsYUFBNEI7SUFBQztJQUM1RztRQUFFRyxLQUFLO1FBQTZCQyxPQUFPO1FBQWlCUSxNQUFNWixnQkFBZ0IsaUJBQTJCO0lBQUM7Q0FDakgsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9tYW5hZ2Vycy90eXBlcy50cz9jZDliIl0sInNvdXJjZXNDb250ZW50IjpbIi8vL1VzZXJzL3RlcnJhbmNlaGFoL0RvY3VtZW50cy90ZXJyYW5jZWhhaC5jb20vbWFuYWdlcnMvdHlwZXMudHNcblxuaW1wb3J0IHsgTWVzc2FnZSBhcyBBaU1lc3NhZ2UsIEpTT05WYWx1ZSB9IGZyb20gJ2FpJztcbmltcG9ydCB7IFBsYWNlIH0gZnJvbSAnLi4vdXRpbHMvcGxhY2VzLXV0aWxzJztcbmltcG9ydCB7IFJlYWN0Tm9kZSB9IGZyb20gJ3JlYWN0JztcblxuZXhwb3J0IGludGVyZmFjZSBUcmF2ZWxEZXRhaWxzIHtcbiAgICBkZXN0aW5hdGlvbj86IHN0cmluZztcbiAgICBkZXN0aW5hdGlvbkxhdD86IG51bWJlcjtcbiAgICBkZXN0aW5hdGlvbkxuZz86IG51bWJlcjtcbiAgICBzdGFydERhdGU/OiBzdHJpbmc7XG4gICAgZW5kRGF0ZT86IHN0cmluZztcbiAgICBidWRnZXQ/OiBCdWRnZXRMZXZlbDtcbiAgICBwcmVmZXJlbmNlcz86IFRyYXZlbFByZWZlcmVuY2VbXTtcbiAgICBsYW5ndWFnZT86IFN1cHBvcnRlZExhbmd1YWdlO1xuICAgIHRyYW5zcG9ydD86IHN0cmluZ1tdO1xuICAgIGRpbmluZz86IHN0cmluZ1tdO1xufVxuXG5leHBvcnQgZW51bSBDb21wb25lbnRUeXBlIHtcbiAgICBEYXRlUGlja2VyID0gJ0RhdGVQaWNrZXInLFxuICAgIFByZWZlcmVuY2VTZWxlY3RvciA9ICdQcmVmZXJlbmNlU2VsZWN0b3InLFxuICAgIEJ1ZGdldFNlbGVjdG9yID0gJ0J1ZGdldFNlbGVjdG9yJyxcbiAgICBMYW5ndWFnZVNlbGVjdG9yID0gJ0xhbmd1YWdlU2VsZWN0b3InLFxuICAgIFBsYWNlQ2FyZCA9ICdQbGFjZUNhcmQnLFxuICAgIFRyYW5zcG9ydFNlbGVjdG9yID0gJ1RyYW5zcG9ydFNlbGVjdG9yJyxcbiAgICBDYXJvdXNlbCA9ICdDYXJvdXNlbCcsXG4gICAgRGV0YWlsc0NhcmQgPSAnRGV0YWlsc0NhcmQnXG59XG5cbmV4cG9ydCBlbnVtIEJ1ZGdldExldmVsIHtcbiAgICBCdWRnZXQgPSAnJCcsXG4gICAgTW9kZXJhdGUgPSAnJCQnLFxuICAgIEx1eHVyeSA9ICckJCQnLFxuICAgIFVsdHJhTHV4dXJ5ID0gJyQkJCQnXG59XG5cbmV4cG9ydCBlbnVtIFRyYXZlbFByZWZlcmVuY2Uge1xuICAgIEN1bHR1cmUgPSAnQ3VsdHVyZSBhbmQgSGVyaXRhZ2UnLFxuICAgIE5hdHVyZSA9ICdOYXR1cmUnLFxuICAgIEZvb2QgPSAnRm9vZGllJyxcbiAgICBSZWxheGF0aW9uID0gJ0xlaXN1cmUnLFxuICAgIEFkdmVudHVyZSA9ICdBZHZlbnR1cmUnLFxuICAgIFNob3BwaW5nID0gJ0FydHMgJiBNdXNldW0nXG59XG5cbmV4cG9ydCBlbnVtIFN1cHBvcnRlZExhbmd1YWdlIHtcbiAgICBFbmdsaXNoID0gJ0VuZ2xpc2gnLFxuICAgIE1hbGF5ID0gJ01hbGF5IChCYWhhc2EgTWVsYXl1KScsXG4gICAgU3BhbmlzaCA9ICdFc3Bhbm9sJyxcbiAgICBGcmVuY2ggPSAnRnJhbmNhaXMnLFxuICAgIEdlcm1hbiA9ICdEZXV0c2NoJyxcbiAgICBJdGFsaWFuID0gJ0l0YWxpYW5vJyxcbiAgICBDemVjaCA9ICdDemVjaCAoQ2VzdGluYSknLFxuICAgIFNpbXBsaWZpZWRDaGluZXNlID0gJ1NpbXBsaWZpZWQgQ2hpbmVzZSAo566A5L2T5Lit5paHKScsXG4gICAgVHJhZGl0aW9uYWxDaGluZXNlID0gJ1RyYWRpdGlvbmFsIENoaW5lc2UgKOe5gemrlOS4reaWhyknLFxuICAgIEphcGFuZXNlID0gJ0phcGFuZXNlICjml6XmnKzoqp4pJyxcbiAgICBLb3JlYW4gPSAnS29yZWFuICjtlZzqta3slrQpJ1xufVxuXG5leHBvcnQgY29uc3QgQlVER0VUX0RFU0NSSVBUSU9OUzogUmVjb3JkPEJ1ZGdldExldmVsLCBzdHJpbmc+ID0ge1xuICAgIFtCdWRnZXRMZXZlbC5CdWRnZXRdOiAnQnVkZ2V0LWZyaWVuZGx5IG9wdGlvbnMgKCQpJyxcbiAgICBbQnVkZ2V0TGV2ZWwuTW9kZXJhdGVdOiAnTWlkLXJhbmdlIG9wdGlvbnMgKCQkKScsXG4gICAgW0J1ZGdldExldmVsLkx1eHVyeV06ICdIaWdoLWVuZCBvcHRpb25zICgkJCQpJyxcbiAgICBbQnVkZ2V0TGV2ZWwuVWx0cmFMdXh1cnldOiAnVWx0cmEgbHV4dXJ5IG9wdGlvbnMgKCQkJCQpJ1xufTtcblxuZXhwb3J0IGNvbnN0IFBSRUZFUkVOQ0VfSUNPTlM6IFJlY29yZDxUcmF2ZWxQcmVmZXJlbmNlLCBzdHJpbmc+ID0ge1xuICAgIFtUcmF2ZWxQcmVmZXJlbmNlLkN1bHR1cmVdOiAn8J+OjycsXG4gICAgW1RyYXZlbFByZWZlcmVuY2UuTmF0dXJlXTogJ/CfjYAnLFxuICAgIFtUcmF2ZWxQcmVmZXJlbmNlLkZvb2RdOiAn8J+NsScsXG4gICAgW1RyYXZlbFByZWZlcmVuY2UuUmVsYXhhdGlvbl06ICfwn4yHJyxcbiAgICBbVHJhdmVsUHJlZmVyZW5jZS5BZHZlbnR1cmVdOiAn8J+qgicsXG4gICAgW1RyYXZlbFByZWZlcmVuY2UuU2hvcHBpbmddOiAn8J+OqCdcbn07XG5cbmV4cG9ydCBjb25zdCBMQU5HVUFHRV9MQUJFTFM6IFJlY29yZDxTdXBwb3J0ZWRMYW5ndWFnZSwgc3RyaW5nPiA9IHtcbiAgICBbU3VwcG9ydGVkTGFuZ3VhZ2UuRW5nbGlzaF06ICdFbmdsaXNoJyxcbiAgICBbU3VwcG9ydGVkTGFuZ3VhZ2UuTWFsYXldOiAnTWFsYXkgKEJhaGFzYSBNZWxheXUpJyxcbiAgICBbU3VwcG9ydGVkTGFuZ3VhZ2UuU3BhbmlzaF06ICdFc3Bhbm9sJyxcbiAgICBbU3VwcG9ydGVkTGFuZ3VhZ2UuRnJlbmNoXTogJ0ZyYW5jYWlzJyxcbiAgICBbU3VwcG9ydGVkTGFuZ3VhZ2UuR2VybWFuXTogJ0RldXRzY2gnLFxuICAgIFtTdXBwb3J0ZWRMYW5ndWFnZS5JdGFsaWFuXTogJ0l0YWxpYW5vJyxcbiAgICBbU3VwcG9ydGVkTGFuZ3VhZ2UuQ3plY2hdOiAnQ3plY2ggKENlc3RpbmEpJyxcbiAgICBbU3VwcG9ydGVkTGFuZ3VhZ2UuU2ltcGxpZmllZENoaW5lc2VdOiAnU2ltcGxpZmllZCBDaGluZXNlICjnroDkvZPkuK3mlocpJyxcbiAgICBbU3VwcG9ydGVkTGFuZ3VhZ2UuVHJhZGl0aW9uYWxDaGluZXNlXTogJ1RyYWRpdGlvbmFsIENoaW5lc2UgKOe5gemrlOS4reaWhyknLFxuICAgIFtTdXBwb3J0ZWRMYW5ndWFnZS5KYXBhbmVzZV06ICdKYXBhbmVzZSAo5pel5pys6KqeKScsXG4gICAgW1N1cHBvcnRlZExhbmd1YWdlLktvcmVhbl06ICdLb3JlYW4gKO2VnOq1reyWtCknXG59O1xuXG5leHBvcnQgY29uc3QgQlVER0VUX09QVElPTlMgPSBbXG4gICAgeyB2YWx1ZTogQnVkZ2V0TGV2ZWwuQnVkZ2V0LCBsYWJlbDogJ0J1ZGdldCcsIGRlc2NyaXB0aW9uOiAnQnVkZ2V0LWZyaWVuZGx5IG9wdGlvbnMgd2l0aCBiYXNpYyBhbWVuaXRpZXMnIH0sXG4gICAgeyB2YWx1ZTogQnVkZ2V0TGV2ZWwuTW9kZXJhdGUsIGxhYmVsOiAnTW9kZXJhdGUnLCBkZXNjcmlwdGlvbjogJ01pZC1yYW5nZSBvcHRpb25zIHdpdGggZ29vZCB2YWx1ZScgfSxcbiAgICB7IHZhbHVlOiBCdWRnZXRMZXZlbC5MdXh1cnksIGxhYmVsOiAnTHV4dXJ5JywgZGVzY3JpcHRpb246ICdIaWdoLWVuZCBvcHRpb25zIHdpdGggcHJlbWl1bSBzZXJ2aWNlcycgfSxcbiAgICB7IHZhbHVlOiBCdWRnZXRMZXZlbC5VbHRyYUx1eHVyeSwgbGFiZWw6ICdVbHRyYSBMdXh1cnknLCBkZXNjcmlwdGlvbjogJ0V4Y2x1c2l2ZSBsdXh1cnkgZXhwZXJpZW5jZXMnIH1cbl07XG5cbmV4cG9ydCBjb25zdCBMQU5HVUFHRV9PUFRJT05TID0gT2JqZWN0LmVudHJpZXMoU3VwcG9ydGVkTGFuZ3VhZ2UpLm1hcCgoW2tleSwgdmFsdWVdKSA9PiAoe1xuICAgIHZhbHVlLFxuICAgIGxhYmVsOiBMQU5HVUFHRV9MQUJFTFNbdmFsdWUgYXMgU3VwcG9ydGVkTGFuZ3VhZ2VdXG59KSk7XG5cbmV4cG9ydCBjb25zdCBQUkVGRVJFTkNFX09QVElPTlMgPSBbXG4gICAgeyB2YWx1ZTogVHJhdmVsUHJlZmVyZW5jZS5DdWx0dXJlLCBsYWJlbDogJ0N1bHR1cmUgYW5kIEhlcml0YWdlJywgaWNvbjogUFJFRkVSRU5DRV9JQ09OU1tUcmF2ZWxQcmVmZXJlbmNlLkN1bHR1cmVdIH0sXG4gICAgeyB2YWx1ZTogVHJhdmVsUHJlZmVyZW5jZS5OYXR1cmUsIGxhYmVsOiAnTmF0dXJlJywgaWNvbjogUFJFRkVSRU5DRV9JQ09OU1tUcmF2ZWxQcmVmZXJlbmNlLk5hdHVyZV0gfSxcbiAgICB7IHZhbHVlOiBUcmF2ZWxQcmVmZXJlbmNlLkZvb2QsIGxhYmVsOiAnRm9vZGllJywgaWNvbjogUFJFRkVSRU5DRV9JQ09OU1tUcmF2ZWxQcmVmZXJlbmNlLkZvb2RdIH0sXG4gICAgeyB2YWx1ZTogVHJhdmVsUHJlZmVyZW5jZS5SZWxheGF0aW9uLCBsYWJlbDogJ0xlaXN1cmUnLCBpY29uOiBQUkVGRVJFTkNFX0lDT05TW1RyYXZlbFByZWZlcmVuY2UuUmVsYXhhdGlvbl0gfSxcbiAgICB7IHZhbHVlOiBUcmF2ZWxQcmVmZXJlbmNlLkFkdmVudHVyZSwgbGFiZWw6ICdBZHZlbnR1cmUnLCBpY29uOiBQUkVGRVJFTkNFX0lDT05TW1RyYXZlbFByZWZlcmVuY2UuQWR2ZW50dXJlXSB9LFxuICAgIHsgdmFsdWU6IFRyYXZlbFByZWZlcmVuY2UuU2hvcHBpbmcsIGxhYmVsOiAnQXJ0cyAmIE11c2V1bScsIGljb246IFBSRUZFUkVOQ0VfSUNPTlNbVHJhdmVsUHJlZmVyZW5jZS5TaG9wcGluZ10gfVxuXTtcblxuZXhwb3J0IGludGVyZmFjZSBDb21wb25lbnRQcm9wcyB7XG4gICAgW0NvbXBvbmVudFR5cGUuRGF0ZVBpY2tlcl06IHtcbiAgICAgICAgc3RhcnREYXRlPzogc3RyaW5nO1xuICAgICAgICBlbmREYXRlPzogc3RyaW5nO1xuICAgICAgICBvbkRhdGVDaGFuZ2U6IChzdGFydERhdGU6IHN0cmluZywgZW5kRGF0ZTogc3RyaW5nKSA9PiB2b2lkO1xuICAgIH07XG4gICAgW0NvbXBvbmVudFR5cGUuUHJlZmVyZW5jZVNlbGVjdG9yXToge1xuICAgICAgICBzZWxlY3RlZFByZWZlcmVuY2VzOiBUcmF2ZWxQcmVmZXJlbmNlW107XG4gICAgICAgIG9uUHJlZmVyZW5jZUNoYW5nZTogKHByZWZlcmVuY2VzOiBUcmF2ZWxQcmVmZXJlbmNlW10pID0+IHZvaWQ7XG4gICAgfTtcbiAgICBbQ29tcG9uZW50VHlwZS5CdWRnZXRTZWxlY3Rvcl06IHtcbiAgICAgICAgc2VsZWN0ZWRCdWRnZXQ/OiBCdWRnZXRMZXZlbDtcbiAgICAgICAgb25CdWRnZXRDaGFuZ2U6IChidWRnZXQ6IEJ1ZGdldExldmVsKSA9PiB2b2lkO1xuICAgIH07XG4gICAgW0NvbXBvbmVudFR5cGUuTGFuZ3VhZ2VTZWxlY3Rvcl06IHtcbiAgICAgICAgc2VsZWN0ZWRMYW5ndWFnZT86IFN1cHBvcnRlZExhbmd1YWdlO1xuICAgICAgICBvbkxhbmd1YWdlQ2hhbmdlOiAobGFuZ3VhZ2U6IFN1cHBvcnRlZExhbmd1YWdlKSA9PiB2b2lkO1xuICAgIH07XG4gICAgW0NvbXBvbmVudFR5cGUuUGxhY2VDYXJkXToge1xuICAgICAgICB0aXRsZTogc3RyaW5nO1xuICAgICAgICBkZXNjcmlwdGlvbjogc3RyaW5nO1xuICAgICAgICBpbWFnZVVybDogc3RyaW5nO1xuICAgICAgICBvbkNsaWNrPzogKCkgPT4gdm9pZDtcbiAgICB9O1xuICAgIFtDb21wb25lbnRUeXBlLlRyYW5zcG9ydFNlbGVjdG9yXToge1xuICAgICAgICBvcHRpb25zOiBzdHJpbmdbXTtcbiAgICAgICAgb25TZWxlY3Q6IChvcHRpb246IHN0cmluZykgPT4gdm9pZDtcbiAgICB9O1xuICAgIFtDb21wb25lbnRUeXBlLkNhcm91c2VsXToge1xuICAgICAgICBpdGVtczogQXJyYXk8e1xuICAgICAgICAgICAgdGl0bGU6IHN0cmluZztcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gICAgICAgICAgICBpbWFnZVVybDogc3RyaW5nO1xuICAgICAgICB9PjtcbiAgICB9O1xuICAgIFtDb21wb25lbnRUeXBlLkRldGFpbHNDYXJkXToge1xuICAgICAgICB0aXRsZTogc3RyaW5nO1xuICAgICAgICBjb250ZW50OiBSZWFjdE5vZGU7XG4gICAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb21wb25lbnRSZWdpc3RyYXRpb248VCBleHRlbmRzIENvbXBvbmVudFR5cGU+IHtcbiAgICBjb21wb25lbnQ6IFJlYWN0LkNvbXBvbmVudFR5cGU8Q29tcG9uZW50UHJvcHNbVF0+O1xuICAgIGRlZmF1bHRQcm9wcz86IFBhcnRpYWw8Q29tcG9uZW50UHJvcHNbVF0+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbXBvbmVudFN0YXRlIHtcbiAgICBpZDogc3RyaW5nO1xuICAgIHR5cGU6IENvbXBvbmVudFR5cGU7XG4gICAgcHJvcHM6IGFueTtcbiAgICBpc1Zpc2libGU6IGJvb2xlYW47XG4gICAgb3JkZXI6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb21wb25lbnRUcmFuc2l0aW9uIHtcbiAgICBpZDogc3RyaW5nO1xuICAgIGZyb206IFBhcnRpYWw8Q29tcG9uZW50U3RhdGU+O1xuICAgIHRvOiBQYXJ0aWFsPENvbXBvbmVudFN0YXRlPjtcbiAgICBkdXJhdGlvbj86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb21wb25lbnRVcGRhdGUge1xuICAgIGlkOiBzdHJpbmc7XG4gICAgdXBkYXRlczogUGFydGlhbDxDb21wb25lbnRTdGF0ZT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWVzc2FnZURhdGEge1xuICAgIHRvb2xOYW1lPzogQ29tcG9uZW50VHlwZTtcbiAgICBjb21wb25lbnRQcm9wcz86IGFueTtcbiAgICBpc0RldGFpbHNDYXJkPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDaGF0TWVzc2FnZSBleHRlbmRzIE9taXQ8QWlNZXNzYWdlLCAnZGF0YSc+IHtcbiAgICBkYXRhPzogTWVzc2FnZURhdGE7XG59XG5cbmV4cG9ydCB0eXBlIFRvb2xSZXNwb25zZTxUIGV4dGVuZHMgQ29tcG9uZW50VHlwZT4gPSB7XG4gICAgdHlwZTogVDtcbiAgICBwcm9wczogQ29tcG9uZW50UHJvcHNbVF07XG4gICAgbWVzc2FnZT86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDaGF0SGlzdG9yeSB7XG4gICAgbWVzc2FnZXM6IENoYXRNZXNzYWdlW107XG4gICAgbWV0YWRhdGE6IENoYXRNZXRhZGF0YTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDaGF0TWV0YWRhdGEge1xuICAgIGxhc3RJbnRlcmFjdGlvblRpbWU6IERhdGU7XG4gICAgY3VycmVudFN0YXRlOiBDaGF0U3RhdGU7XG4gICAgdmFsaWRQYXJhbWV0ZXJzOiBzdHJpbmdbXTtcbiAgICBpbnRlcnJ1cHRlZEF0Pzogc3RyaW5nO1xufVxuXG5leHBvcnQgdHlwZSBDaGF0U3RhdGUgPSAnaW5pdGlhbCcgfCAnZ2F0aGVyaW5nX2luZm8nIHwgJ3BsYW5uaW5nJyB8ICdpbnRlcnJ1cHRlZCcgfCAnY29tcGxldGVkJztcblxuZXhwb3J0IGludGVyZmFjZSBBSVJlc3BvbnNlIHtcbiAgICBtZXNzYWdlOiBzdHJpbmc7XG4gICAgcGFyYW1ldGVycz86IFRyYXZlbERldGFpbHM7XG4gICAgc3VnZ2VzdGVkQWN0aW9uPzogc3RyaW5nO1xuICAgIGVycm9yPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENhY2hlQ29uZmlnIHtcbiAgICBtYXhTaXplOiBudW1iZXI7XG4gICAgdHRsOiBudW1iZXI7IC8vIFRpbWUgdG8gbGl2ZSBpbiBtaWxsaXNlY29uZHNcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDYWNoZUVudHJ5IHtcbiAgICBjb250ZW50OiBzdHJpbmc7XG4gICAgdGltZXN0YW1wOiBudW1iZXI7XG4gICAgbGFuZ3VhZ2U6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb250ZW50UmVzcG9uc2Uge1xuICAgIGNvbnRlbnQ6IHN0cmluZztcbiAgICBjYWNoZWQ6IGJvb2xlYW47XG4gICAgbGFuZ3VhZ2U6IHN0cmluZztcbiAgICBnZW5lcmF0ZWQ6IERhdGU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVG9vbEludm9jYXRpb24ge1xuICAgIHRvb2xOYW1lOiBzdHJpbmc7XG4gICAgdG9vbENhbGxJZDogc3RyaW5nO1xuICAgIHN0YXRlOiAncmVzdWx0JyB8ICdwZW5kaW5nJyB8ICdlcnJvcic7ICBcbiAgICBhcmdzOiBKU09OVmFsdWU7ICBcbiAgICByZXN1bHQ/OiB7XG4gICAgICAgIHR5cGU6IHN0cmluZztcbiAgICAgICAgcHJvcHM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+OyAgXG4gICAgfTtcbiAgICBlcnJvcj86IHN0cmluZzsgIFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1lc3NhZ2Uge1xuICAgIGlkOiBzdHJpbmc7XG4gICAgcm9sZTogJ3VzZXInIHwgJ2Fzc2lzdGFudCcgfCAnc3lzdGVtJzsgIFxuICAgIGNvbnRlbnQ6IHN0cmluZztcbiAgICBjcmVhdGVkQXQ/OiBEYXRlOyAgXG4gICAgZGF0YT86IE1lc3NhZ2VEYXRhO1xuICAgIHRvb2xJbnZvY2F0aW9ucz86IFRvb2xJbnZvY2F0aW9uW107XG4gICAgcGFyZW50TWVzc2FnZUlkPzogc3RyaW5nOyAgXG59XG5cbi8vIFdlYXRoZXIgcmVsYXRlZCB0eXBlc1xuZXhwb3J0IGludGVyZmFjZSBXZWF0aGVyRGF0YSB7XG4gICAgZGF0ZTogc3RyaW5nO1xuICAgIHByZWNpcGl0YXRpb246IHtcbiAgICAgICAgdG90YWw6IG51bWJlcjtcbiAgICB9O1xuICAgIHRlbXBlcmF0dXJlOiB7XG4gICAgICAgIG1heDogbnVtYmVyO1xuICAgIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgV2VhdGhlckNoYXJ0UHJvcHMge1xuICAgIGxhdDogbnVtYmVyO1xuICAgIGxvbjogbnVtYmVyO1xuICAgIGNpdHk6IHN0cmluZztcbiAgICBzdGFydERhdGU6IHN0cmluZztcbiAgICBlbmREYXRlOiBzdHJpbmc7XG4gICAgdW5pdHM/OiAndXMnIHwgJ3VrJyB8ICdtZXRyaWMnO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE9wZW5XZWF0aGVyRGF5UmVzcG9uc2Uge1xuICAgIGxhdDogbnVtYmVyO1xuICAgIGxvbjogbnVtYmVyO1xuICAgIHR6OiBzdHJpbmc7XG4gICAgZGF0ZTogc3RyaW5nO1xuICAgIHVuaXRzOiBzdHJpbmc7XG4gICAgY2xvdWRfY292ZXI6IHtcbiAgICBhZnRlcm5vb246IG51bWJlcjtcbiAgICB9O1xuICAgIGh1bWlkaXR5OiB7XG4gICAgYWZ0ZXJub29uOiBudW1iZXI7XG4gICAgfTtcbiAgICBwcmVjaXBpdGF0aW9uOiB7XG4gICAgdG90YWw6IG51bWJlcjtcbiAgICB9O1xuICAgIHRlbXBlcmF0dXJlOiB7XG4gICAgbWluOiBudW1iZXI7XG4gICAgbWF4OiBudW1iZXI7XG4gICAgYWZ0ZXJub29uOiBudW1iZXI7XG4gICAgbmlnaHQ6IG51bWJlcjtcbiAgICBldmVuaW5nOiBudW1iZXI7XG4gICAgbW9ybmluZzogbnVtYmVyO1xuICAgIH07XG4gICAgcHJlc3N1cmU6IHtcbiAgICBhZnRlcm5vb246IG51bWJlcjtcbiAgICB9O1xuICAgIHdpbmQ6IHtcbiAgICBtYXg6IHtcbiAgICAgICAgc3BlZWQ6IG51bWJlcjtcbiAgICAgICAgZGlyZWN0aW9uOiBudW1iZXI7XG4gICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBXZWF0aGVyUmVzcG9uc2Uge1xuICAgIGRhdGE6IE9wZW5XZWF0aGVyRGF5UmVzcG9uc2U7XG4gICAgeWVhcjogbnVtYmVyOyAgLy8gQWRkIHRoaXMgZmllbGRcbiAgICBlcnJvcj86IHN0cmluZztcbn1cbiJdLCJuYW1lcyI6WyJDb21wb25lbnRUeXBlIiwiQnVkZ2V0TGV2ZWwiLCJUcmF2ZWxQcmVmZXJlbmNlIiwiU3VwcG9ydGVkTGFuZ3VhZ2UiLCJCVURHRVRfREVTQ1JJUFRJT05TIiwiUFJFRkVSRU5DRV9JQ09OUyIsIkxBTkdVQUdFX0xBQkVMUyIsIkJVREdFVF9PUFRJT05TIiwidmFsdWUiLCJsYWJlbCIsImRlc2NyaXB0aW9uIiwiTEFOR1VBR0VfT1BUSU9OUyIsIk9iamVjdCIsImVudHJpZXMiLCJtYXAiLCJrZXkiLCJQUkVGRVJFTkNFX09QVElPTlMiLCJpY29uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./managers/types.ts\n"));

/***/ }),

/***/ "./utils/places-utils.ts":
/*!*******************************!*\
  !*** ./utils/places-utils.ts ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchPlaces: function() { return /* binding */ fetchPlaces; },\n/* harmony export */   formatPrimaryType: function() { return /* binding */ formatPrimaryType; },\n/* harmony export */   getPlaceTypeDisplayName: function() { return /* binding */ getPlaceTypeDisplayName; },\n/* harmony export */   getPlaceTypesFromPreferences: function() { return /* binding */ getPlaceTypesFromPreferences; },\n/* harmony export */   preferenceToPlaceTypes: function() { return /* binding */ preferenceToPlaceTypes; },\n/* harmony export */   searchMultiplePlacesByText: function() { return /* binding */ searchMultiplePlacesByText; },\n/* harmony export */   searchPlaceByText: function() { return /* binding */ searchPlaceByText; }\n/* harmony export */ });\n/* harmony import */ var _managers_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../managers/types */ \"./managers/types.ts\");\n// Place related interfaces\n\n// Updated preference to place types mapping based on travel-rizz.html\nconst preferenceToPlaceTypes = {\n    [_managers_types__WEBPACK_IMPORTED_MODULE_0__.TravelPreference.Culture]: [\n        \"tourist_attraction\",\n        \"museum\",\n        \"cultural_center\",\n        \"monument\",\n        \"historical_landmark\" // For historical places\n    ],\n    [_managers_types__WEBPACK_IMPORTED_MODULE_0__.TravelPreference.Nature]: [\n        \"national_park\",\n        \"park\",\n        \"tourist_attraction\",\n        \"wildlife_park\",\n        \"botanical_garden\"\n    ],\n    [_managers_types__WEBPACK_IMPORTED_MODULE_0__.TravelPreference.Food]: [\n        \"restaurant\",\n        \"cafe\",\n        \"bakery\",\n        \"bar\",\n        \"fine_dining_restaurant\"\n    ],\n    [_managers_types__WEBPACK_IMPORTED_MODULE_0__.TravelPreference.Relaxation]: [\n        \"shopping_mall\",\n        \"tourist_attraction\",\n        \"spa\",\n        \"department_store\",\n        \"store\" // For retail locations\n    ],\n    [_managers_types__WEBPACK_IMPORTED_MODULE_0__.TravelPreference.Adventure]: [\n        \"amusement_park\",\n        \"tourist_attraction\",\n        \"sports_complex\",\n        \"sports_activity_location\",\n        \"hiking_area\"\n    ],\n    [_managers_types__WEBPACK_IMPORTED_MODULE_0__.TravelPreference.Shopping]: [\n        \"museum\",\n        \"art_gallery\",\n        \"tourist_attraction\",\n        \"performing_arts_theater\",\n        \"cultural_center\"\n    ]\n};\n// Helper function to get place types based on preferences\nfunction getPlaceTypesFromPreferences(preferences) {\n    try {\n        // Get unique types from all preferences\n        const types = new Set(preferences.reduce((types, pref)=>{\n            const placeTypes = preferenceToPlaceTypes[pref] || [];\n            return [\n                ...types,\n                ...placeTypes\n            ];\n        }, []));\n        return Array.from(types);\n    } catch (error) {\n        console.error(\"Error getting place types from preferences:\", error);\n        return [\n            \"tourist_attraction\"\n        ]; // Default fallback\n    }\n}\n// Helper function to format primary type\nconst formatPrimaryType = (type)=>{\n    return type.split(\"_\").map((word)=>word.charAt(0).toUpperCase() + word.slice(1)).join(\" \");\n};\n// Helper function to get display name for place type\nconst getPlaceTypeDisplayName = (place)=>{\n    var _place_primaryTypeDisplayName;\n    if (place === null || place === void 0 ? void 0 : (_place_primaryTypeDisplayName = place.primaryTypeDisplayName) === null || _place_primaryTypeDisplayName === void 0 ? void 0 : _place_primaryTypeDisplayName.text) {\n        return place.primaryTypeDisplayName.text;\n    }\n    // Fallback to formatting the primaryType if displayName is not available\n    return place.primaryType ? formatPrimaryType(place.primaryType) : \"Place\";\n};\n// Search for a single place by text query\nconst searchPlaceByText = async (searchText, location)=>{\n    try {\n        var _place_displayName, _place_photos;\n        if (false) {}\n        const requestBody = {\n            textQuery: searchText,\n            locationBias: {\n                circle: {\n                    center: {\n                        latitude: location.latitude,\n                        longitude: location.longitude\n                    },\n                    radius: 20000.0 // 20km radius\n                }\n            }\n        };\n        const headers = new Headers({\n            \"Content-Type\": \"application/json\",\n            \"X-Goog-Api-Key\": \"AIzaSyDvcgBgSprgTRQO_6BWh5EAOPu1vdS6KD4\",\n            \"X-Goog-FieldMask\": \"places.id,places.displayName,places.formattedAddress,places.location,places.primaryType,places.primaryTypeDisplayName,places.photos.name\"\n        });\n        const response = await fetch(\"https://places.googleapis.com/v1/places:searchText\", {\n            method: \"POST\",\n            headers: headers,\n            body: JSON.stringify(requestBody)\n        });\n        if (!response.ok) {\n            const errorData = await response.text();\n            console.error(\"Failed to search place:\", {\n                status: response.status,\n                statusText: response.statusText,\n                error: errorData\n            });\n            return null;\n        }\n        const data = await response.json();\n        // console.log('Places API text search response:', data);\n        if (!data.places || !Array.isArray(data.places) || data.places.length === 0) {\n            console.error(\"No places found for text search:\", searchText);\n            return null;\n        }\n        // Return the first result as we only need one place\n        const place = data.places[0];\n        return {\n            id: place.id,\n            displayName: ((_place_displayName = place.displayName) === null || _place_displayName === void 0 ? void 0 : _place_displayName.text) ? {\n                text: place.displayName.text,\n                languageCode: place.displayName.languageCode\n            } : place.displayName,\n            primaryType: place.primaryType || \"place\",\n            photos: ((_place_photos = place.photos) === null || _place_photos === void 0 ? void 0 : _place_photos.map((photo)=>({\n                    name: photo.name,\n                    widthPx: photo.widthPx,\n                    heightPx: photo.heightPx,\n                    authorAttributions: photo.authorAttributions\n                }))) || [],\n            formattedAddress: place.formattedAddress,\n            location: place.location,\n            primaryTypeDisplayName: place.primaryTypeDisplayName ? {\n                text: place.primaryTypeDisplayName.text,\n                languageCode: place.primaryTypeDisplayName.languageCode\n            } : undefined\n        };\n    } catch (error) {\n        console.error(\"Error searching for place:\", error);\n        return null;\n    }\n};\n// Search for multiple places by text query\nconst searchMultiplePlacesByText = async function(searchText, location) {\n    let maxResults = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 5;\n    try {\n        if (false) {}\n        console.log(\"Executing searchMultiplePlacesByText with params:\", {\n            searchText,\n            location,\n            maxResults\n        });\n        const requestBody = {\n            textQuery: searchText,\n            locationBias: {\n                circle: {\n                    center: {\n                        latitude: location.latitude,\n                        longitude: location.longitude\n                    },\n                    radius: 20000.0 // 20km radius\n                }\n            },\n            maxResultCount: maxResults\n        };\n        const headers = new Headers({\n            \"Content-Type\": \"application/json\",\n            \"X-Goog-Api-Key\": \"AIzaSyDvcgBgSprgTRQO_6BWh5EAOPu1vdS6KD4\",\n            \"X-Goog-FieldMask\": \"places.id,places.displayName,places.formattedAddress,places.location,places.primaryType,places.primaryTypeDisplayName,places.photos.name\"\n        });\n        const response = await fetch(\"https://places.googleapis.com/v1/places:searchText\", {\n            method: \"POST\",\n            headers: headers,\n            body: JSON.stringify(requestBody)\n        });\n        if (!response.ok) {\n            const errorData = await response.text();\n            console.error(\"Failed to search places:\", {\n                status: response.status,\n                statusText: response.statusText,\n                error: errorData\n            });\n            return [];\n        }\n        const data = await response.json();\n        if (!data.places || !Array.isArray(data.places) || data.places.length === 0) {\n            console.log(\"No places found for text search:\", searchText);\n            return [];\n        }\n        return data.places.map((place)=>{\n            var _place_displayName, _place_photos;\n            return {\n                id: place.id,\n                displayName: ((_place_displayName = place.displayName) === null || _place_displayName === void 0 ? void 0 : _place_displayName.text) ? {\n                    text: place.displayName.text,\n                    languageCode: place.displayName.languageCode\n                } : place.displayName,\n                primaryType: place.primaryType || \"place\",\n                photos: ((_place_photos = place.photos) === null || _place_photos === void 0 ? void 0 : _place_photos.map((photo)=>({\n                        name: photo.name\n                    }))) || [],\n                formattedAddress: place.formattedAddress,\n                location: place.location,\n                primaryTypeDisplayName: place.primaryTypeDisplayName ? {\n                    text: place.primaryTypeDisplayName.text,\n                    languageCode: place.primaryTypeDisplayName.languageCode\n                } : undefined\n            };\n        });\n    } catch (error) {\n        console.error(\"Error searching for places:\", error);\n        return [];\n    }\n};\n// Fetch places from Google Places API\nconst fetchPlaces = async function(latitude, longitude, preferences) {\n    let maxResults = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 5, placeTypes = arguments.length > 4 ? arguments[4] : void 0;\n    try {\n        if (false) {}\n        const fromPreferences = !!preferences && preferences.length > 0;\n        const fromPlaceTypes = !!placeTypes && placeTypes.length > 0;\n        if (!fromPreferences && !fromPlaceTypes) {\n            console.error(\"No preferences or place types provided\");\n            return [];\n        }\n        // Use preferences if provided, otherwise use placeTypes, otherwise use defaults\n        let includedTypes = [];\n        if (fromPreferences) {\n            includedTypes = getPlaceTypesFromPreferences(preferences);\n        } else if (fromPlaceTypes) {\n            includedTypes = placeTypes;\n        }\n        console.log(\"Executing fetchplaces with params:\", {\n            latitude,\n            longitude,\n            includedTypes,\n            maxResults,\n            fromPreferences: !!(preferences === null || preferences === void 0 ? void 0 : preferences.length),\n            fromPlaceTypes: !!(placeTypes === null || placeTypes === void 0 ? void 0 : placeTypes.length)\n        });\n        // First try nearby search\n        try {\n            const requestBody = {\n                includedTypes,\n                maxResultCount: maxResults,\n                locationRestriction: {\n                    circle: {\n                        center: {\n                            latitude: latitude,\n                            longitude: longitude\n                        },\n                        radius: 20000.0 // 20km radius\n                    }\n                }\n            };\n            const headers = new Headers({\n                \"Content-Type\": \"application/json\",\n                \"X-Goog-Api-Key\": \"AIzaSyDvcgBgSprgTRQO_6BWh5EAOPu1vdS6KD4\",\n                \"X-Goog-FieldMask\": \"places.id,places.displayName,places.formattedAddress,places.location,places.primaryType,places.primaryTypeDisplayName,places.photos.name\"\n            });\n            const response = await fetch(\"https://places.googleapis.com/v1/places:searchNearby\", {\n                method: \"POST\",\n                headers: headers,\n                body: JSON.stringify(requestBody)\n            });\n            if (response.ok) {\n                const data = await response.json();\n                if (data.places && Array.isArray(data.places) && data.places.length > 0) {\n                    return data.places.map((place)=>{\n                        var _place_displayName, _place_photos;\n                        return {\n                            id: place.id,\n                            displayName: ((_place_displayName = place.displayName) === null || _place_displayName === void 0 ? void 0 : _place_displayName.text) ? {\n                                text: place.displayName.text,\n                                languageCode: place.displayName.languageCode\n                            } : place.displayName,\n                            primaryType: place.primaryType || \"place\",\n                            photos: ((_place_photos = place.photos) === null || _place_photos === void 0 ? void 0 : _place_photos.map((photo)=>({\n                                    name: photo.name\n                                }))) || [],\n                            formattedAddress: place.formattedAddress,\n                            location: place.location,\n                            primaryTypeDisplayName: place.primaryTypeDisplayName ? {\n                                text: place.primaryTypeDisplayName.text,\n                                languageCode: place.primaryTypeDisplayName.languageCode\n                            } : undefined\n                        };\n                    });\n                }\n            }\n            const errorData = await response.text();\n            console.error(\"Failed to fetch places:\", {\n                status: response.status,\n                statusText: response.statusText,\n                error: errorData\n            });\n        } catch (error) {\n            console.error(\"Error in nearby search:\", error);\n        }\n        // If nearby search fails, try text search as fallback\n        console.log(\"Falling back to text search...\");\n        const searchQuery = fromPlaceTypes ? placeTypes[0] : preferences[0];\n        return await searchMultiplePlacesByText(searchQuery, {\n            latitude,\n            longitude\n        }, maxResults);\n    } catch (error) {\n        console.error(\"Error fetching places:\", error);\n        return [];\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFRUixTQUFTUSxNQUFNO2dCQUN2QkMsWUFBWVQsU0FBU1MsVUFBVTtnQkFDL0J6QyxPQUFPdUM7WUFDWDtRQUNKLEVBQUUsT0FBT3ZDLE9BQU87WUFDWkMsUUFBUUQsS0FBSyxDQUFDLDJCQUEyQkE7UUFDN0M7UUFFQSxzREFBc0Q7UUFDdERDLFFBQVEyRCxHQUFHLENBQUM7UUFDWixNQUFNTyxjQUFjSCxpQkFBaUJuRSxVQUFXLENBQUMsRUFBRSxHQUFHTCxXQUFZLENBQUMsRUFBRTtRQUNyRSxPQUFPLE1BQU1rRSwyQkFBMkJTLGFBQWE7WUFBRXhDO1lBQVVDO1FBQVUsR0FBRytCO0lBRWxGLEVBQUUsT0FBTzNELE9BQU87UUFDWkMsUUFBUUQsS0FBSyxDQUFDLDBCQUEwQkE7UUFDeEMsT0FBTyxFQUFFO0lBQ2I7QUFDSixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3V0aWxzL3BsYWNlcy11dGlscy50cz81NTVjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFBsYWNlIHJlbGF0ZWQgaW50ZXJmYWNlc1xuZXhwb3J0IGludGVyZmFjZSBQbGFjZSB7XG4gICAgaWQ6IHN0cmluZztcbiAgICBkaXNwbGF5TmFtZToge1xuICAgICAgICB0ZXh0OiBzdHJpbmc7XG4gICAgICAgIGxhbmd1YWdlQ29kZTogc3RyaW5nO1xuICAgIH0gfCBzdHJpbmc7XG4gICAgZm9ybWF0dGVkQWRkcmVzcz86IHN0cmluZztcbiAgICBsb2NhdGlvbj86IHtcbiAgICAgICAgbGF0aXR1ZGU6IG51bWJlcjtcbiAgICAgICAgbG9uZ2l0dWRlOiBudW1iZXI7XG4gICAgfTtcbiAgICBwcmltYXJ5VHlwZTogc3RyaW5nO1xuICAgIHByaW1hcnlUeXBlRGlzcGxheU5hbWU/OiB7XG4gICAgICAgIHRleHQ6IHN0cmluZztcbiAgICAgICAgbGFuZ3VhZ2VDb2RlOiBzdHJpbmc7XG4gICAgfTtcbiAgICBwaG90b3M/OiB7IFxuICAgICAgICBuYW1lOiBzdHJpbmc7XG4gICAgICAgIHdpZHRoUHg/OiBudW1iZXI7XG4gICAgICAgIGhlaWdodFB4PzogbnVtYmVyO1xuICAgICAgICBhdXRob3JBdHRyaWJ1dGlvbnM/OiBBcnJheTx7XG4gICAgICAgICAgICBkaXNwbGF5TmFtZT86IHN0cmluZztcbiAgICAgICAgICAgIHVyaT86IHN0cmluZztcbiAgICAgICAgICAgIHBob3RvVXJpPzogc3RyaW5nO1xuICAgICAgICB9PjtcbiAgICB9W107XG59XG5cbmltcG9ydCB7IFRyYXZlbFByZWZlcmVuY2UgfSBmcm9tICcuLi9tYW5hZ2Vycy90eXBlcyc7XG5cbi8vIFVwZGF0ZWQgcHJlZmVyZW5jZSB0byBwbGFjZSB0eXBlcyBtYXBwaW5nIGJhc2VkIG9uIHRyYXZlbC1yaXp6Lmh0bWxcbmV4cG9ydCBjb25zdCBwcmVmZXJlbmNlVG9QbGFjZVR5cGVzOiBSZWNvcmQ8VHJhdmVsUHJlZmVyZW5jZSwgc3RyaW5nW10+ID0ge1xuICAgIFtUcmF2ZWxQcmVmZXJlbmNlLkN1bHR1cmVdOiBbXG4gICAgICAgICd0b3VyaXN0X2F0dHJhY3Rpb24nLCAgLy8gRm9yIGhpc3RvcmljYWwgc2l0ZXNcbiAgICAgICAgJ211c2V1bScsICAgICAgICAgICAgIC8vIEZvciBtdXNldW1zIGFuZCBjdWx0dXJhbCBpbnN0aXR1dGlvbnNcbiAgICAgICAgJ2N1bHR1cmFsX2NlbnRlcicsICAgIC8vIEZvciBjdWx0dXJhbCB2ZW51ZXNcbiAgICAgICAgJ21vbnVtZW50JywgICAgICAgICAgIC8vIEZvciBtb251bWVudHMgYW5kIGxhbmRtYXJrc1xuICAgICAgICAnaGlzdG9yaWNhbF9sYW5kbWFyaycgLy8gRm9yIGhpc3RvcmljYWwgcGxhY2VzXG4gICAgXSxcbiAgICBbVHJhdmVsUHJlZmVyZW5jZS5OYXR1cmVdOiBbXG4gICAgICAgICduYXRpb25hbF9wYXJrJyxcbiAgICAgICAgJ3BhcmsnLFxuICAgICAgICAndG91cmlzdF9hdHRyYWN0aW9uJywgLy8gRm9yIG5hdHVyYWwgYXR0cmFjdGlvbnNcbiAgICAgICAgJ3dpbGRsaWZlX3BhcmsnLFxuICAgICAgICAnYm90YW5pY2FsX2dhcmRlbidcbiAgICBdLFxuICAgIFtUcmF2ZWxQcmVmZXJlbmNlLkZvb2RdOiBbXG4gICAgICAgICdyZXN0YXVyYW50JyxcbiAgICAgICAgJ2NhZmUnLFxuICAgICAgICAnYmFrZXJ5JyxcbiAgICAgICAgJ2JhcicsXG4gICAgICAgICdmaW5lX2RpbmluZ19yZXN0YXVyYW50J1xuICAgIF0sXG4gICAgW1RyYXZlbFByZWZlcmVuY2UuUmVsYXhhdGlvbl06IFtcbiAgICAgICAgJ3Nob3BwaW5nX21hbGwnLFxuICAgICAgICAndG91cmlzdF9hdHRyYWN0aW9uJywgIC8vIEZvciBnZW5lcmFsIGF0dHJhY3Rpb25zXG4gICAgICAgICdzcGEnLFxuICAgICAgICAnZGVwYXJ0bWVudF9zdG9yZScsXG4gICAgICAgICdzdG9yZScgICAgICAgICAgICAgICAvLyBGb3IgcmV0YWlsIGxvY2F0aW9uc1xuICAgIF0sXG4gICAgW1RyYXZlbFByZWZlcmVuY2UuQWR2ZW50dXJlXTogW1xuICAgICAgICAnYW11c2VtZW50X3BhcmsnLFxuICAgICAgICAndG91cmlzdF9hdHRyYWN0aW9uJywgLy8gRm9yIGFkdmVudHVyZSBzaXRlc1xuICAgICAgICAnc3BvcnRzX2NvbXBsZXgnLFxuICAgICAgICAnc3BvcnRzX2FjdGl2aXR5X2xvY2F0aW9uJyxcbiAgICAgICAgJ2hpa2luZ19hcmVhJ1xuICAgIF0sXG4gICAgW1RyYXZlbFByZWZlcmVuY2UuU2hvcHBpbmddOiBbXG4gICAgICAgICdtdXNldW0nLFxuICAgICAgICAnYXJ0X2dhbGxlcnknLFxuICAgICAgICAndG91cmlzdF9hdHRyYWN0aW9uJywgLy8gRm9yIGFydCBpbnN0YWxsYXRpb25zXG4gICAgICAgICdwZXJmb3JtaW5nX2FydHNfdGhlYXRlcicsXG4gICAgICAgICdjdWx0dXJhbF9jZW50ZXInXG4gICAgXVxufTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGdldCBwbGFjZSB0eXBlcyBiYXNlZCBvbiBwcmVmZXJlbmNlc1xuZXhwb3J0IGZ1bmN0aW9uIGdldFBsYWNlVHlwZXNGcm9tUHJlZmVyZW5jZXMocHJlZmVyZW5jZXM6IFRyYXZlbFByZWZlcmVuY2VbXSk6IHN0cmluZ1tdIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBHZXQgdW5pcXVlIHR5cGVzIGZyb20gYWxsIHByZWZlcmVuY2VzXG4gICAgICAgIGNvbnN0IHR5cGVzID0gbmV3IFNldChwcmVmZXJlbmNlcy5yZWR1Y2UoKHR5cGVzOiBzdHJpbmdbXSwgcHJlZikgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGxhY2VUeXBlcyA9IHByZWZlcmVuY2VUb1BsYWNlVHlwZXNbcHJlZl0gfHwgW107XG4gICAgICAgICAgICByZXR1cm4gWy4uLnR5cGVzLCAuLi5wbGFjZVR5cGVzXTtcbiAgICAgICAgfSwgW10pKTtcblxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0eXBlcyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBwbGFjZSB0eXBlcyBmcm9tIHByZWZlcmVuY2VzOicsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIFsndG91cmlzdF9hdHRyYWN0aW9uJ107IC8vIERlZmF1bHQgZmFsbGJhY2tcbiAgICB9XG59O1xuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gZm9ybWF0IHByaW1hcnkgdHlwZVxuZXhwb3J0IGNvbnN0IGZvcm1hdFByaW1hcnlUeXBlID0gKHR5cGU6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gICAgcmV0dXJuIHR5cGUuc3BsaXQoJ18nKVxuICAgICAgICAubWFwKHdvcmQgPT4gd29yZC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHdvcmQuc2xpY2UoMSkpXG4gICAgICAgIC5qb2luKCcgJyk7XG59O1xuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IGRpc3BsYXkgbmFtZSBmb3IgcGxhY2UgdHlwZVxuZXhwb3J0IGNvbnN0IGdldFBsYWNlVHlwZURpc3BsYXlOYW1lID0gKHBsYWNlOiBhbnkpOiBzdHJpbmcgPT4ge1xuICAgIGlmIChwbGFjZT8ucHJpbWFyeVR5cGVEaXNwbGF5TmFtZT8udGV4dCkge1xuICAgICAgICByZXR1cm4gcGxhY2UucHJpbWFyeVR5cGVEaXNwbGF5TmFtZS50ZXh0O1xuICAgIH1cbiAgICAvLyBGYWxsYmFjayB0byBmb3JtYXR0aW5nIHRoZSBwcmltYXJ5VHlwZSBpZiBkaXNwbGF5TmFtZSBpcyBub3QgYXZhaWxhYmxlXG4gICAgcmV0dXJuIHBsYWNlLnByaW1hcnlUeXBlID8gZm9ybWF0UHJpbWFyeVR5cGUocGxhY2UucHJpbWFyeVR5cGUpIDogJ1BsYWNlJztcbn07XG5cbi8vIFNlYXJjaCBmb3IgYSBzaW5nbGUgcGxhY2UgYnkgdGV4dCBxdWVyeVxuZXhwb3J0IGNvbnN0IHNlYXJjaFBsYWNlQnlUZXh0ID0gYXN5bmMgKFxuICAgIHNlYXJjaFRleHQ6IHN0cmluZyxcbiAgICBsb2NhdGlvbjogeyBsYXRpdHVkZTogbnVtYmVyOyBsb25naXR1ZGU6IG51bWJlciB9XG4pOiBQcm9taXNlPFBsYWNlIHwgbnVsbD4gPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICghcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfR09PR0xFX01BUFNfQVBJX0tFWSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignR29vZ2xlIE1hcHMgQVBJIGtleSBpcyBtaXNzaW5nJyk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlcXVlc3RCb2R5ID0ge1xuICAgICAgICAgICAgdGV4dFF1ZXJ5OiBzZWFyY2hUZXh0LFxuICAgICAgICAgICAgbG9jYXRpb25CaWFzOiB7XG4gICAgICAgICAgICAgICAgY2lyY2xlOiB7XG4gICAgICAgICAgICAgICAgICAgIGNlbnRlcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGF0aXR1ZGU6IGxvY2F0aW9uLmxhdGl0dWRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9uZ2l0dWRlOiBsb2NhdGlvbi5sb25naXR1ZGVcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiAyMDAwMC4wIC8vIDIwa20gcmFkaXVzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyh7XG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgJ1gtR29vZy1BcGktS2V5JzogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfR09PR0xFX01BUFNfQVBJX0tFWSxcbiAgICAgICAgICAgICdYLUdvb2ctRmllbGRNYXNrJzogJ3BsYWNlcy5pZCxwbGFjZXMuZGlzcGxheU5hbWUscGxhY2VzLmZvcm1hdHRlZEFkZHJlc3MscGxhY2VzLmxvY2F0aW9uLHBsYWNlcy5wcmltYXJ5VHlwZSxwbGFjZXMucHJpbWFyeVR5cGVEaXNwbGF5TmFtZSxwbGFjZXMucGhvdG9zLm5hbWUnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJ2h0dHBzOi8vcGxhY2VzLmdvb2dsZWFwaXMuY29tL3YxL3BsYWNlczpzZWFyY2hUZXh0Jywge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocmVxdWVzdEJvZHkpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBzZWFyY2ggcGxhY2U6Jywge1xuICAgICAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yRGF0YVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdQbGFjZXMgQVBJIHRleHQgc2VhcmNoIHJlc3BvbnNlOicsIGRhdGEpO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFkYXRhLnBsYWNlcyB8fCAhQXJyYXkuaXNBcnJheShkYXRhLnBsYWNlcykgfHwgZGF0YS5wbGFjZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdObyBwbGFjZXMgZm91bmQgZm9yIHRleHQgc2VhcmNoOicsIHNlYXJjaFRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXR1cm4gdGhlIGZpcnN0IHJlc3VsdCBhcyB3ZSBvbmx5IG5lZWQgb25lIHBsYWNlXG4gICAgICAgIGNvbnN0IHBsYWNlID0gZGF0YS5wbGFjZXNbMF07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogcGxhY2UuaWQsXG4gICAgICAgICAgICBkaXNwbGF5TmFtZTogcGxhY2UuZGlzcGxheU5hbWU/LnRleHQgPyB7XG4gICAgICAgICAgICAgICAgdGV4dDogcGxhY2UuZGlzcGxheU5hbWUudGV4dCxcbiAgICAgICAgICAgICAgICBsYW5ndWFnZUNvZGU6IHBsYWNlLmRpc3BsYXlOYW1lLmxhbmd1YWdlQ29kZVxuICAgICAgICAgICAgfSA6IHBsYWNlLmRpc3BsYXlOYW1lLFxuICAgICAgICAgICAgcHJpbWFyeVR5cGU6IHBsYWNlLnByaW1hcnlUeXBlIHx8ICdwbGFjZScsXG4gICAgICAgICAgICBwaG90b3M6IHBsYWNlLnBob3Rvcz8ubWFwKChwaG90bzogYW55KSA9PiAoeyBcbiAgICAgICAgICAgICAgICBuYW1lOiBwaG90by5uYW1lLFxuICAgICAgICAgICAgICAgIHdpZHRoUHg6IHBob3RvLndpZHRoUHgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0UHg6IHBob3RvLmhlaWdodFB4LFxuICAgICAgICAgICAgICAgIGF1dGhvckF0dHJpYnV0aW9uczogcGhvdG8uYXV0aG9yQXR0cmlidXRpb25zXG4gICAgICAgICAgICB9KSkgfHwgW10sXG4gICAgICAgICAgICBmb3JtYXR0ZWRBZGRyZXNzOiBwbGFjZS5mb3JtYXR0ZWRBZGRyZXNzLFxuICAgICAgICAgICAgbG9jYXRpb246IHBsYWNlLmxvY2F0aW9uLFxuICAgICAgICAgICAgcHJpbWFyeVR5cGVEaXNwbGF5TmFtZTogcGxhY2UucHJpbWFyeVR5cGVEaXNwbGF5TmFtZSA/IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBwbGFjZS5wcmltYXJ5VHlwZURpc3BsYXlOYW1lLnRleHQsXG4gICAgICAgICAgICAgICAgbGFuZ3VhZ2VDb2RlOiBwbGFjZS5wcmltYXJ5VHlwZURpc3BsYXlOYW1lLmxhbmd1YWdlQ29kZVxuICAgICAgICAgICAgfSA6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNlYXJjaGluZyBmb3IgcGxhY2U6JywgZXJyb3IpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuXG4vLyBTZWFyY2ggZm9yIG11bHRpcGxlIHBsYWNlcyBieSB0ZXh0IHF1ZXJ5XG5leHBvcnQgY29uc3Qgc2VhcmNoTXVsdGlwbGVQbGFjZXNCeVRleHQgPSBhc3luYyAoXG4gICAgc2VhcmNoVGV4dDogc3RyaW5nLFxuICAgIGxvY2F0aW9uOiB7IGxhdGl0dWRlOiBudW1iZXI7IGxvbmdpdHVkZTogbnVtYmVyIH0sXG4gICAgbWF4UmVzdWx0czogbnVtYmVyID0gNVxuKTogUHJvbWlzZTxQbGFjZVtdPiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKCFwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19HT09HTEVfTUFQU19BUElfS0VZKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdHb29nbGUgTWFwcyBBUEkga2V5IGlzIG1pc3NpbmcnKTtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKCdFeGVjdXRpbmcgc2VhcmNoTXVsdGlwbGVQbGFjZXNCeVRleHQgd2l0aCBwYXJhbXM6Jywge1xuICAgICAgICAgICAgc2VhcmNoVGV4dCxcbiAgICAgICAgICAgIGxvY2F0aW9uLFxuICAgICAgICAgICAgbWF4UmVzdWx0c1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCByZXF1ZXN0Qm9keSA9IHtcbiAgICAgICAgICAgIHRleHRRdWVyeTogc2VhcmNoVGV4dCxcbiAgICAgICAgICAgIGxvY2F0aW9uQmlhczoge1xuICAgICAgICAgICAgICAgIGNpcmNsZToge1xuICAgICAgICAgICAgICAgICAgICBjZW50ZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhdGl0dWRlOiBsb2NhdGlvbi5sYXRpdHVkZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvbmdpdHVkZTogbG9jYXRpb24ubG9uZ2l0dWRlXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHJhZGl1czogMjAwMDAuMCAvLyAyMGttIHJhZGl1c1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtYXhSZXN1bHRDb3VudDogbWF4UmVzdWx0c1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyh7XG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgJ1gtR29vZy1BcGktS2V5JzogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfR09PR0xFX01BUFNfQVBJX0tFWSxcbiAgICAgICAgICAgICdYLUdvb2ctRmllbGRNYXNrJzogJ3BsYWNlcy5pZCxwbGFjZXMuZGlzcGxheU5hbWUscGxhY2VzLmZvcm1hdHRlZEFkZHJlc3MscGxhY2VzLmxvY2F0aW9uLHBsYWNlcy5wcmltYXJ5VHlwZSxwbGFjZXMucHJpbWFyeVR5cGVEaXNwbGF5TmFtZSxwbGFjZXMucGhvdG9zLm5hbWUnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJ2h0dHBzOi8vcGxhY2VzLmdvb2dsZWFwaXMuY29tL3YxL3BsYWNlczpzZWFyY2hUZXh0Jywge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocmVxdWVzdEJvZHkpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBzZWFyY2ggcGxhY2VzOicsIHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvckRhdGFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgXG4gICAgICAgIGlmICghZGF0YS5wbGFjZXMgfHwgIUFycmF5LmlzQXJyYXkoZGF0YS5wbGFjZXMpIHx8IGRhdGEucGxhY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ05vIHBsYWNlcyBmb3VuZCBmb3IgdGV4dCBzZWFyY2g6Jywgc2VhcmNoVGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0YS5wbGFjZXMubWFwKChwbGFjZTogYW55KSA9PiAoe1xuICAgICAgICAgICAgaWQ6IHBsYWNlLmlkLFxuICAgICAgICAgICAgZGlzcGxheU5hbWU6IHBsYWNlLmRpc3BsYXlOYW1lPy50ZXh0ID8ge1xuICAgICAgICAgICAgICAgIHRleHQ6IHBsYWNlLmRpc3BsYXlOYW1lLnRleHQsXG4gICAgICAgICAgICAgICAgbGFuZ3VhZ2VDb2RlOiBwbGFjZS5kaXNwbGF5TmFtZS5sYW5ndWFnZUNvZGVcbiAgICAgICAgICAgIH0gOiBwbGFjZS5kaXNwbGF5TmFtZSxcbiAgICAgICAgICAgIHByaW1hcnlUeXBlOiBwbGFjZS5wcmltYXJ5VHlwZSB8fCAncGxhY2UnLFxuICAgICAgICAgICAgcGhvdG9zOiBwbGFjZS5waG90b3M/Lm1hcCgocGhvdG86IGFueSkgPT4gKHsgXG4gICAgICAgICAgICAgICAgbmFtZTogcGhvdG8ubmFtZVxuICAgICAgICAgICAgfSkpIHx8IFtdLFxuICAgICAgICAgICAgZm9ybWF0dGVkQWRkcmVzczogcGxhY2UuZm9ybWF0dGVkQWRkcmVzcyxcbiAgICAgICAgICAgIGxvY2F0aW9uOiBwbGFjZS5sb2NhdGlvbixcbiAgICAgICAgICAgIHByaW1hcnlUeXBlRGlzcGxheU5hbWU6IHBsYWNlLnByaW1hcnlUeXBlRGlzcGxheU5hbWUgPyB7XG4gICAgICAgICAgICAgICAgdGV4dDogcGxhY2UucHJpbWFyeVR5cGVEaXNwbGF5TmFtZS50ZXh0LFxuICAgICAgICAgICAgICAgIGxhbmd1YWdlQ29kZTogcGxhY2UucHJpbWFyeVR5cGVEaXNwbGF5TmFtZS5sYW5ndWFnZUNvZGVcbiAgICAgICAgICAgIH0gOiB1bmRlZmluZWRcbiAgICAgICAgfSkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNlYXJjaGluZyBmb3IgcGxhY2VzOicsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbn07XG5cbi8vIEZldGNoIHBsYWNlcyBmcm9tIEdvb2dsZSBQbGFjZXMgQVBJXG5leHBvcnQgY29uc3QgZmV0Y2hQbGFjZXMgPSBhc3luYyAoXG4gICAgbGF0aXR1ZGU6IG51bWJlcixcbiAgICBsb25naXR1ZGU6IG51bWJlcixcbiAgICBwcmVmZXJlbmNlcz86IFRyYXZlbFByZWZlcmVuY2VbXSxcbiAgICBtYXhSZXN1bHRzOiBudW1iZXIgPSA1LFxuICAgIHBsYWNlVHlwZXM/OiBzdHJpbmdbXVxuKTogUHJvbWlzZTxQbGFjZVtdPiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKCFwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19HT09HTEVfTUFQU19BUElfS0VZKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdHb29nbGUgTWFwcyBBUEkga2V5IGlzIG1pc3NpbmcnKTtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZyb21QcmVmZXJlbmNlcyA9ICEhcHJlZmVyZW5jZXMgJiYgcHJlZmVyZW5jZXMubGVuZ3RoID4gMDtcbiAgICAgICAgY29uc3QgZnJvbVBsYWNlVHlwZXMgPSAhIXBsYWNlVHlwZXMgJiYgcGxhY2VUeXBlcy5sZW5ndGggPiAwO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFmcm9tUHJlZmVyZW5jZXMgJiYgIWZyb21QbGFjZVR5cGVzKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdObyBwcmVmZXJlbmNlcyBvciBwbGFjZSB0eXBlcyBwcm92aWRlZCcpO1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXNlIHByZWZlcmVuY2VzIGlmIHByb3ZpZGVkLCBvdGhlcndpc2UgdXNlIHBsYWNlVHlwZXMsIG90aGVyd2lzZSB1c2UgZGVmYXVsdHNcbiAgICAgICAgbGV0IGluY2x1ZGVkVHlwZXM6IHN0cmluZ1tdID0gW107XG4gICAgICAgIGlmIChmcm9tUHJlZmVyZW5jZXMpIHtcbiAgICAgICAgICAgIGluY2x1ZGVkVHlwZXMgPSBnZXRQbGFjZVR5cGVzRnJvbVByZWZlcmVuY2VzKHByZWZlcmVuY2VzISk7XG4gICAgICAgIH0gZWxzZSBpZiAoZnJvbVBsYWNlVHlwZXMpIHtcbiAgICAgICAgICAgIGluY2x1ZGVkVHlwZXMgPSBwbGFjZVR5cGVzITtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKCdFeGVjdXRpbmcgZmV0Y2hwbGFjZXMgd2l0aCBwYXJhbXM6Jywge1xuICAgICAgICAgICAgbGF0aXR1ZGUsXG4gICAgICAgICAgICBsb25naXR1ZGUsXG4gICAgICAgICAgICBpbmNsdWRlZFR5cGVzLFxuICAgICAgICAgICAgbWF4UmVzdWx0cyxcbiAgICAgICAgICAgIGZyb21QcmVmZXJlbmNlczogISFwcmVmZXJlbmNlcz8ubGVuZ3RoLFxuICAgICAgICAgICAgZnJvbVBsYWNlVHlwZXM6ICEhcGxhY2VUeXBlcz8ubGVuZ3RoXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEZpcnN0IHRyeSBuZWFyYnkgc2VhcmNoXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0Qm9keSA9IHtcbiAgICAgICAgICAgICAgICBpbmNsdWRlZFR5cGVzLFxuICAgICAgICAgICAgICAgIG1heFJlc3VsdENvdW50OiBtYXhSZXN1bHRzLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uUmVzdHJpY3Rpb246IHtcbiAgICAgICAgICAgICAgICAgICAgY2lyY2xlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZW50ZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXRpdHVkZTogbGF0aXR1ZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9uZ2l0dWRlOiBsb25naXR1ZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICByYWRpdXM6IDIwMDAwLjAgLy8gMjBrbSByYWRpdXNcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyh7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgICAnWC1Hb29nLUFwaS1LZXknOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19HT09HTEVfTUFQU19BUElfS0VZLFxuICAgICAgICAgICAgICAgICdYLUdvb2ctRmllbGRNYXNrJzogJ3BsYWNlcy5pZCxwbGFjZXMuZGlzcGxheU5hbWUscGxhY2VzLmZvcm1hdHRlZEFkZHJlc3MscGxhY2VzLmxvY2F0aW9uLHBsYWNlcy5wcmltYXJ5VHlwZSxwbGFjZXMucHJpbWFyeVR5cGVEaXNwbGF5TmFtZSxwbGFjZXMucGhvdG9zLm5hbWUnXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnaHR0cHM6Ly9wbGFjZXMuZ29vZ2xlYXBpcy5jb20vdjEvcGxhY2VzOnNlYXJjaE5lYXJieScsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcXVlc3RCb2R5KVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEucGxhY2VzICYmIEFycmF5LmlzQXJyYXkoZGF0YS5wbGFjZXMpICYmIGRhdGEucGxhY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEucGxhY2VzLm1hcCgocGxhY2U6IGFueSkgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBwbGFjZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlOYW1lOiBwbGFjZS5kaXNwbGF5TmFtZT8udGV4dCA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBwbGFjZS5kaXNwbGF5TmFtZS50ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlQ29kZTogcGxhY2UuZGlzcGxheU5hbWUubGFuZ3VhZ2VDb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICB9IDogcGxhY2UuZGlzcGxheU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmltYXJ5VHlwZTogcGxhY2UucHJpbWFyeVR5cGUgfHwgJ3BsYWNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBob3RvczogcGxhY2UucGhvdG9zPy5tYXAoKHBob3RvOiBhbnkpID0+ICh7IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHBob3RvLm5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKSB8fCBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZEFkZHJlc3M6IHBsYWNlLmZvcm1hdHRlZEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbjogcGxhY2UubG9jYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmltYXJ5VHlwZURpc3BsYXlOYW1lOiBwbGFjZS5wcmltYXJ5VHlwZURpc3BsYXlOYW1lID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHBsYWNlLnByaW1hcnlUeXBlRGlzcGxheU5hbWUudGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYW5ndWFnZUNvZGU6IHBsYWNlLnByaW1hcnlUeXBlRGlzcGxheU5hbWUubGFuZ3VhZ2VDb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICB9IDogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBwbGFjZXM6Jywge1xuICAgICAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yRGF0YVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBuZWFyYnkgc2VhcmNoOicsIGVycm9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIG5lYXJieSBzZWFyY2ggZmFpbHMsIHRyeSB0ZXh0IHNlYXJjaCBhcyBmYWxsYmFja1xuICAgICAgICBjb25zb2xlLmxvZygnRmFsbGluZyBiYWNrIHRvIHRleHQgc2VhcmNoLi4uJyk7XG4gICAgICAgIGNvbnN0IHNlYXJjaFF1ZXJ5ID0gZnJvbVBsYWNlVHlwZXMgPyBwbGFjZVR5cGVzIVswXSA6IHByZWZlcmVuY2VzIVswXTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHNlYXJjaE11bHRpcGxlUGxhY2VzQnlUZXh0KHNlYXJjaFF1ZXJ5LCB7IGxhdGl0dWRlLCBsb25naXR1ZGUgfSwgbWF4UmVzdWx0cyk7XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBwbGFjZXM6JywgZXJyb3IpO1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxufTsiXSwibmFtZXMiOlsiVHJhdmVsUHJlZmVyZW5jZSIsInByZWZlcmVuY2VUb1BsYWNlVHlwZXMiLCJDdWx0dXJlIiwiTmF0dXJlIiwiRm9vZCIsIlJlbGF4YXRpb24iLCJBZHZlbnR1cmUiLCJTaG9wcGluZyIsImdldFBsYWNlVHlwZXNGcm9tUHJlZmVyZW5jZXMiLCJwcmVmZXJlbmNlcyIsInR5cGVzIiwiU2V0IiwicmVkdWNlIiwicHJlZiIsInBsYWNlVHlwZXMiLCJBcnJheSIsImZyb20iLCJlcnJvciIsImNvbnNvbGUiLCJmb3JtYXRQcmltYXJ5VHlwZSIsInR5cGUiLCJzcGxpdCIsIm1hcCIsIndvcmQiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInNsaWNlIiwiam9pbiIsImdldFBsYWNlVHlwZURpc3BsYXlOYW1lIiwicGxhY2UiLCJwcmltYXJ5VHlwZURpc3BsYXlOYW1lIiwidGV4dCIsInByaW1hcnlUeXBlIiwic2VhcmNoUGxhY2VCeVRleHQiLCJzZWFyY2hUZXh0IiwibG9jYXRpb24iLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfR09PR0xFX01BUFNfQVBJX0tFWSIsInJlcXVlc3RCb2R5IiwidGV4dFF1ZXJ5IiwibG9jYXRpb25CaWFzIiwiY2lyY2xlIiwiY2VudGVyIiwibGF0aXR1ZGUiLCJsb25naXR1ZGUiLCJyYWRpdXMiLCJoZWFkZXJzIiwiSGVhZGVycyIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsIm9rIiwiZXJyb3JEYXRhIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsImRhdGEiLCJqc29uIiwicGxhY2VzIiwiaXNBcnJheSIsImxlbmd0aCIsImlkIiwiZGlzcGxheU5hbWUiLCJsYW5ndWFnZUNvZGUiLCJwaG90b3MiLCJwaG90byIsIm5hbWUiLCJ3aWR0aFB4IiwiaGVpZ2h0UHgiLCJhdXRob3JBdHRyaWJ1dGlvbnMiLCJmb3JtYXR0ZWRBZGRyZXNzIiwidW5kZWZpbmVkIiwic2VhcmNoTXVsdGlwbGVQbGFjZXNCeVRleHQiLCJtYXhSZXN1bHRzIiwibG9nIiwibWF4UmVzdWx0Q291bnQiLCJmZXRjaFBsYWNlcyIsImZyb21QcmVmZXJlbmNlcyIsImZyb21QbGFjZVR5cGVzIiwiaW5jbHVkZWRUeXBlcyIsImxvY2F0aW9uUmVzdHJpY3Rpb24iLCJzZWFyY2hRdWVyeSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./utils/places-utils.ts\n"));

/***/ }),

/***/ "./node_modules/next/script.js":
/*!*************************************!*\
  !*** ./node_modules/next/script.js ***!
  \*************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./dist/client/script */ \"./node_modules/next/dist/client/script.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9zY3JpcHQuanMiLCJtYXBwaW5ncyI6IkFBQUEsNkdBQWdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L3NjcmlwdC5qcz9lNGJhIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L2NsaWVudC9zY3JpcHQnKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/script.js\n"));

/***/ })

}]);